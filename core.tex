\begin{abstract}
 

It is well-known that first-order unification corresponds to the construction
of equalisers in a (multi-sorted) Lawvere theory. We show that second-order
unification in Miller's decidable pattern can be interpreted similarly;
the involved Lawvere theories are no longer freely generated by operations.
More specifically, we present a generic unification algorithm that
we actually implemented in Agda, and justify its correctness based
on the semantic analysis sketched above. The syntax with metavariables
given as input of the algorithm is parameterised by a notion of signature
generalising binding signatures, covering a wide range of examples,
including ordered $\lambda$-calculus, (intrinsic) polymorphic syntax
such as System F, and of course Miller's original example, normalised
simply-typed $\lambda$-calculus. 
\end{abstract}
\title{Semantics of pattern unification}

\maketitle
\global\long\def\type{\ \mathrm{type}}%
\global\long\def\Th#1{\mathrm{MCon}(#1)}%
\global\long\def\arSep{\rightarrow}%
\global\long\def\Thbot#1{\mathrm{MCon_{\bot}}(#1)}%
\global\long\def\Fsep{|}%
\global\long\def\substofrenamings#1{\overline{#1}}%
\global\long\def\lamrenaming#1{#1\uparrow}%
\global\long\def\lamsubst#1#2{#1\uparrow^{#2}}%
\global\long\def\wk#1{\textrm{wk }#1}%

\global\long\def\catbot#1{#1_{\bot}}%
\global\long\def\rename#1#2{#1\{#2\}}%
\global\long\def\ntharvec#1{\alpha_{#1}}%
\global\long\def\indexedO{{\cal O}}%
\global\long\def\Oby#1{\indexedO_{#1}}%
\global\long\def\Oop#1#2{\Oby{#1}(#2)}%

\global\long\def\ntharvecaction#1#2#3{#2_{#3}^{#1}}%

\global\long\def\ntharvecfunct{\ntharvec{}}%

\global\long\def\nthar#1#2{\overline{#1}_{#2}}%

\global\long\def\nthaarvec#1{\alpha'_{#1}}%
\global\long\def\nthaarvecfunct{\nthaarvec{}}%
\global\long\def\nthaar#1#2{\alpha'_{#1,#2}}%

\global\long\def\Inj{\mathrm{Inj}}%
\global\long\def\veciflyx#1#2{\vecif{#1}{#2}}%
\global\long\def\var#1{#1}%
\global\long\def\lcvar#1{\underline{#1}}%
\global\long\def\dotmcontext#1{\boldsymbol{#1}}%

\global\long\def\refruletwo#1#2{\hyperlink{#2}{\textsc{#1}}}%
\global\long\def\refrule#1{\refruletwo{#1}{#1}}%
\global\long\def\maybold#1{#1}%

\global\long\def\refULrule#1{\refruletwo{U\ensuremath{\Lambda}-#1}{UL-#1}}%
$
\global\long\def\niton{\not\owns}%
$
\global\long\def\refPLrule#1{\refruletwo{P\ensuremath{\Lambda}-#1}{PL-#1}}%
\global\long\def\labelrule#1#2{\hypertarget{#2}{#1}}%

\global\long\def\highlighted#1{\texHighlighted{\ensuremath{#1}}}%

\global\long\def\labelruletwo#1#2#3{\labelrule{#1\textsc{#2}}{#3}}%

\global\long\def\labelULrule#1#2{\labelruletwo{#1}{U\ensuremath{\Lambda}-#2}{UL-#2}}%

\global\long\def\labelPLrule#1#2{\labelruletwo{#1}{P\ensuremath{\Lambda}-#2}{PL-#2}}%
\global\long\def\labellabelrule#1#2{\labelruletwo{#1}{#2}{#2}}%
\global\long\def\Kl#1{Kl_{#1}}%
\global\long\def\arg#1{#1}%
\global\long\def\Eil#1{#1\text{-alg}}%
\global\long\def\something#1{\underline{#1}}%
\global\long\def\prunecat#1#2#3#4#5{\vdash_{#5}#1\boldsymbol{:>}#2\Rightarrow#4;#3}%
\global\long\def\prune#1#2#3#4{\prunecat{#1}{#2}{#3}{#4}{}}%
 
\global\long\def\B{\mathscr{B}}%
\global\long\def\D{\mathscr{D}}%
\global\long\def\C{\mathscr{C}}%
\global\long\def\colim{\mathrm{colim}\ }%
\global\long\def\Set{\mathrm{Set}}%
\global\long\def\FinSet{\mathrm{FinSet}}%
\global\long\def\Nom{\mathrm{Nom}}%
\global\long\def\KlD{\Kl{\D^{+}}}%
\global\long\def\op#1{#1^{op}}%
\global\long\def\bang{\oc}%
\global\long\def\none{\bang}%

\global\long\def\unificationtopconcl{\bot\vdash\vec{t}=\vec{u}\Rightarrow\bang\dashv\bot}%
\global\long\def\unificationtop{\dfrac{}{\unificationtopconcl}}%

\global\long\def\unificationemptyconcl{\Gamma\vdash()=()\Rightarrow1_{\Gamma}\dashv\Gamma}%
\global\long\def\unificationempty{\dfrac{}{\unificationemptyconcl}}%

\global\long\def\unificationstepwisenovec{\inferruletwo{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{t_{2}}\Rightarrow\sigma\dashv\Delta}{\Delta\vdash\delta_{1}[\text{\ensuremath{\sigma]}}=\delta_{2}[\text{\ensuremath{\sigma]}}\Rightarrow\sigma'\dashv\Delta'}{\Gamma\vdash\veciflyx{}{t_{1}},\delta_{1}=t_{2},\delta_{2}\Rightarrow\sigma[\sigma']\dashv\Delta'}}%

\global\long\def\unificationstepwisenolabel#1{\inferruletwo{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{u_{1}}\Rightarrow\sigma_{1}\dashv\Delta_{1}}{\Delta_{1}\vdash\veciflyx{#1}{t_{2}}[\text{\ensuremath{\sigma_{1}]}}=\veciflyx{#1}{u_{2}}[\text{\ensuremath{\sigma_{1}]}}\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash\veciflyx{}{t_{1}},\veciflyx{#1}{t_{2}}=\veciflyx{}{u_{1}},\veciflyx{#1}{u_{2}}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}}%

\global\long\def\unificationstepwise#1{\unificationstepwisenolabel{#1}\textsc{U-Split}}%

\global\long\def\unificationrigrignolabel{\dfrac{\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash o(\vec{t})=o(\vec{u})\Rightarrow\sigma\dashv\Delta}}%
\global\long\def\unificationrigrigneqo{\dfrac{o\neq o'}{\Gamma\vdash o(\vec{t})=o'(\vec{u})\Rightarrow\bang\dashv\bot}}%

\global\long\def\pruningemptyconcl{\Gamma\prune{()}{()}{1_{\Gamma}}{()}\dashv\Gamma}%
\global\long\def\pruningempty{\dfrac{}{\pruningemptyconcl}}%

\keywords{Unification, Category theory, Syntax}

\section{Introduction}

Unification is one of the basic algorithms of type inference. It takes
two terms $t$ and $u$, each containing some metavariables, and returns
a substitution $\sigma$ which assigns a term to each metavariable,
such that $t[\sigma]=u[\sigma]$. This substitution is typically the
most general one, in the sense that that every other unifier for these
two terms factors through it. That is, given any other unifier $\delta$,
there exists a unique $\delta'$ such that $\delta=\sigma[\delta']$.

Unification is useful in type inference because it offers a convenient
way of handling the instantiation of quantifiers: whenever a polymorphic
type of the form $\forall a.$ is eliminated, a fresh metavariable
can be substituted for the quantified variable $a$, and then unification
can be used to incrementally deduce what the instantiation should
have been, thereby sparing the programmer from having to instantiate
quantifiers manually. 

However, while recent results in type inference, such as Dunfield
and Krishnaswami~\citet{DBLP:journals/pacmpl/DunfieldK19}, or Jinxu
et. al~\citet{DBLP:journals/pacmpl/ZhaoOS19}, make heavy use of
unification in their algorithms, they do not do so in a well-abstracted
way. They present a set of rules (i.e., a first-order functional program)
which explicitly re-implement unification, and as a result their correctness
proofs have to re-establish many of the fundamental results of unification
theory individually. Almost no lemmas in the proof of the one algorithm
can be re-used in the other, which is particularly problematic given
the sizes of the proofs involved: DK comes with a 190 page appendix,
and Zhao et al's Coq proof is many thousands of lines long.

Worse still, if any modifications to the unification algorithm were
needed, then the entire metatheory would need to be redone. For example,
both of these systems make use of first-order unification (i.e., for
types without binders in them), by retaining the ML-style monotype/polytype
distinction. Something as simple as innocuous as the addition of a
monomorphic type with a binder (for example, a recursive type $\mu a.A[a]$)
would require moving from first-order unification to something like
Miller pattern unification~\citet{DBLP:journals/logcom/Miller91},
which would in turn require completely redoing all of the proofs in
the two systems. Type inference for dependent types also uses Miller
patterns, of course, but the example of recursive types shows that
this issue arises long before we reach the most sophisticated type
theories.

Fixing this problem would require doing two things. First, these type
inference algorithms need to be rephrased in such a way that they
invoke unification as a subroutine, which would enable us to make
use of generic results about unification theory. Second, the unification
algorithm needs to be formulated generically enough that it can be
plugged into multiple contexts without needing substantial modifications
to the guts of the proof. 


\subsection*{Contributions}

In this paper, we take a first step towards addressing the modularity
problem in the theory of type inference, by showing how to formulate
Miller pattern unification in a generic, abstract style. Like many
prior developments~\citet{10.1007/978-3-540-45220-1_41}, we parameterise
the algorithm over a binding signature. However, our notion of signature
is considerably more general than the ones used in prior formulations
of pattern unification. It has a customisable notion of context, which
makes it possible to handle examples such as simply-typed second-order
syntax, ordered lambda calculi, and intrinsic polymorphic syntax (such
as System F). This lets us derive several new unification algorithms
simply as instantiations of our framework. 

Furthermore, our notion of signature can be axiomatised in a categorical
style, which leads to an almost purely categorical proof of the correctness
of our algorithm -{}- each of the rules of our pattern unification
algorithm end up corresponding to some standard categorical construction,
and each part of our proof essentially just shows that the construction
actually has the expected properties. This is similar to Rydeheard
and Burstall's similar reconstruction of first-order unification~\citet{DBLP:books/daglib/0068768},
and serves as evidence that we have correctly factored the unification
algorithm.

\subsection*{Plan of the paper}

In \secref{summary-algo}, we present our generic pattern unification
algorithm, parameterised by our generalised notion of binding signature.
We introduce categorical semantics of pattern unification in \Secref{cat-settings}.
We show correctness of the two phases of the unification algorithm
in \Secref{pruning-phase} and \Secref{coequalising-phase}. Termination
and completeness are justified in \Secref[s]{termination-completeness}.
Related work is finally discussed in \Secref{related-work}.

\subsection*{General notations}

Given a list $\vec{x}=(x_{1},\dots,x_{n})$ and a list of positions
$\vec{p}=(p_{1},\dots,p_{m})$ taken in $\{1,\dots,n\}$, we denote
$(x_{p_{1}},\dots,x_{p_{m}})$ by $x_{\vec{p}}$. 

Given a category $\B$, we denote its opposite category by $\op{\B}$.
If $a$ and $b$ are two objects of $\B$, we denote the set of morphisms
between $a$ and $b$ by $\hom_{\B}(a,b)$. We denote the identity
morphism at an object $x$ by $1_{x}$. We denote the coproduct of
two objects $A$ and $B$ by $A+B$ and the coproduct of a family
of objects $(A_{i})_{i\in I}$ by $\coprod_{i\in I}A_{i}$, and similarly
for morphisms. If $f:A\rightarrow B$ and $g:A'\rightarrow B$, we
 denote the induced morphism $A+A'\rightarrow B$ by $f,g$. Coproduct
injections $A_{i}\rightarrow\coprod_{i\in I}A_{i}$ are typically
denoted by $in_{i}$. Let $T$ be a monad on a category $\B$. We
denote its unit by $\eta$, and its Kleisli category by $\Kl T$:
the objects are the same as those of $\B$, and a Kleisli morphism
from $A$ to $B$ is a morphism $A\rightarrow TB$ in $\B$. We denote
the Kleisli composition of $f:A\rightarrow TB$ and $g:B\rightarrow TC$
by $f[g]:A\rightarrow TC$. 

\section{Presentation of the algorithm}

\label{sec:summary-algo}

In this section, we start by describing a pattern unification algorithm
for pure $\lambda$-calculus, summarised in \Figref{unif-full-lam}.
Then we present our generic algorithm (\Figref{unif-full-gen}). The
type signatures of the implemented functions are listed in \Figref{type-signatures}
and will be explained in the following subsections.

We show the most relevant parts of the Agda code. \begin{full}; the
interested reader can check the full implementation in the supplemental
material.\end{full} We tend to use Agda as a programming language
rather than as a theorem prover. This means that the definitions of
our data structures typically do not mention the properties (such
as associativity for a category), and we leave for future work the
task of mechanising the correctness proof of the algorithm. (The proper
formalisation of category theory in proof assistants remains a significant
challenge in its own right.) Furthermore, we disable the termination
checker and provide instead a termination proof on paper in \Subsecref{termination}.
Even used purely as a programming language, dependent types are very
helpful in structuring the implementation. The Agda code is much simpler
than an earlier, less-strongly typed, version written in OCaml.


\subsection{An example: pure $\lambda$-calculus.}

\label{subsec:example-lambda}

\begin{figure*}
\caption{Syntax of $\lambda$-calculus (\Subsecref{example-lambda})\label{fig:syntax-lam}}

\begin{raggedright}
\begin{minipage}[b]{0.4\textwidth}%
%%%
\agdacode{lc-syntax-decl}%
\end{minipage}%
\begin{minipage}[b]{0.33\textwidth}%
%%%
\agdacode{lc-metacontext}%
\end{minipage}%
\begin{minipage}[b]{0.45\columnwidth}%
%%%
\agdacode{lc-renamings}%
\end{minipage}
\par\end{raggedright}
\begin{minipage}[b]{0.4\textwidth}%
%%
\agdacode{lc-syntax-ind}%
\end{minipage}%
\fbox{\begin{minipage}[b]{0.45\textwidth}%
\noindent \begin{flushleft}
\[
\dfrac{1\leq i\leq n}{\dotmcontext{\Gamma};n\vdash\lcvar i}\quad\dfrac{\dotmcontext{\Gamma};n\vdash t\quad\dotmcontext{\Gamma};n\vdash u}{\dotmcontext{\Gamma};n\vdash t\ u}\quad\dfrac{\dotmcontext{\Gamma};n+1\vdash t}{\dotmcontext{\Gamma};n\vdash\lambda t}
\]
\par\end{flushleft}
\[
\dfrac{M:m\in\dotmcontext{\Gamma}\quad\overbrace{x:m\Rightarrow n}^{x_{1},\mydots,x_{m}\in\{1,\mydots,n\}\text{ distinct}}}{\dotmcontext{\Gamma};n\vdash M(\var{x_{1}},\mydots,\var{x_{m}})}
\]
\[
\dfrac{}{\bot;a\vdash\bang}
\]
%
\end{minipage}}
\begin{raggedright}
\begin{minipage}[c]{0.4\textwidth}%
%%%
\AgdaNoSpaceAroundCode{}
\agdacode{lc-syntax-app-decl}%
\agdacode{lc-syntax-app-def}
\AgdaSpaceAroundCode{}%
\end{minipage}%
\begin{minipage}[c]{0.33\textwidth}%
%%%
\AgdaNoSpaceAroundCode{}
\agdacode{lc-syntax-lam-decl}%
\agdacode{lc-syntax-lam-def}%
\AgdaSpaceAroundCode{}%
\end{minipage}%
\begin{minipage}[c]{0.33\textwidth}%
%%%
\AgdaNoSpaceAroundCode{}
\agdacode{lc-syntax-var-decl}%
\agdacode{lc-syntax-var-def}%
\AgdaSpaceAroundCode{}%
\end{minipage}
\par\end{raggedright}
\raggedright{}
\end{figure*}

\begin{figure*}
\caption{Pattern unification for $\lambda$-calculus (\Subsecref{example-lambda})
\label{fig:unif-full-lam}}

\noindent\fbox{\begin{minipage}[t]{1\textwidth - 2\fboxsep - 2\fboxrule}%
\vspace{-0em}%
\begin{tabular}{cc|c}
\begin{minipage}[c]{0.35\columnwidth}%
\begin{flushleft}
%%
\agdacode{lc-prune-flex}
\par\end{flushleft}%
\end{minipage} & $\labellabelrule{\dfrac{\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}}{\begin{array}{r}
\dotmcontext{\Gamma}[M:m]\vdash M(x):>y\Rightarrow\qquad\\
P(y');M\mapsto P(x')\dashv\dotmcontext{\Gamma}[P:p]
\end{array}}}{P-Flex}$ & %
\begin{minipage}[c]{0.3\columnwidth}%
\begin{center}
%%%
\agdacode{prune-fail}\vspace{-1em}
\[
\labellabelrule{\dfrac{}{\bot\prune{\bang}x{\bang_{s}}{\bang}\dashv\bot}}{P-Fail}
\]
\par\end{center}%
\end{minipage}\tabularnewline
\end{tabular}

\vspace{-0em}%
\begin{tabular}{c|c|c}
\begin{minipage}[c]{0.3\columnwidth}%
\begin{center}
%
\agdacode{prune-app}
\par\end{center}%
\end{minipage} & %
\begin{minipage}[c]{0.28\columnwidth}%
\begin{center}
%
\agdacode{prune-lam}
\par\end{center}%
\end{minipage} & %
\begin{minipage}[c]{0.25\columnwidth}%
\begin{center}
%%%
\agdacode{prune-var}
\par\end{center}%
\end{minipage}\tabularnewline
$\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{u[\sigma_{1}]}x{\sigma_{2}}{u'}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}]\ u'}\dashv\Delta_{2}}$ & $\dfrac{\dotmcontext{\Gamma}\prune t{x\uparrow\ }{\sigma}{t'}\dashv\Delta}{\dotmcontext{\Gamma}\prune{\lambda t}x{\sigma}{\lambda t'}\dashv\Delta}$ & $\dfrac{i\notin x}{\dotmcontext{\Gamma}\prune{\lcvar i}x{\bang_{s}}{\bang}\dashv\bot}\quad\dfrac{i=x_{j}}{\dotmcontext{\Gamma}\prune{\lcvar i}x{1_{\dotmcontext{\Gamma}}}{\lcvar j}\dashv\dotmcontext{\Gamma}}$\tabularnewline
\end{tabular}%
\end{minipage}}
\begin{raggedright}
\noindent\fbox{\begin{minipage}[t]{1\textwidth - 2\fboxsep - 2\fboxrule}%
\begin{flushleft}
\vspace{-0.5em}%
\begin{minipage}[t]{0.35\columnwidth}%
\begin{flushleft}
%%%%%%%%%%%
\agdacode{unify-flex}
\par\end{flushleft}
%
\end{minipage}%
\begin{minipage}[t]{0.3\columnwidth}%
\begin{flushleft}
%%%%%%%%%%%
\agdacode{lc-unify-flex-def}
%
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[t]{0.3\columnwidth}%
\begin{center}
\[
\labellabelrule{\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\begin{array}{r}
\dotmcontext{\Gamma}[M:m]\vdash M(x)=M(y)\Rightarrow\qquad\\
M\mapsto P(z)\dashv\dotmcontext{\Gamma}[P:p]
\end{array}}}{Same-MVar}
\]
\par\end{center}
\begin{center}
\[
\labellabelrule{\dfrac{M\in t\qquad t\neq M(\dots)}{\dotmcontext{\Gamma},M:m\vdash M(x)=t\Rightarrow\bang_{s}\dashv\bot}}{Cycle}
\]
\par\end{center}
\vspace{0.2em}
\[
\labellabelrule{\dfrac{\begin{array}{c}
M\notin t\quad\dotmcontext{\Gamma}\backslash M\prune tx{\sigma}{t'}\dashv\Delta\end{array}}{\dotmcontext{\Gamma}\vdash M(x)=t\Rightarrow M\mapsto t',\sigma\dashv\Delta}}{No-cycle}
\]

\begin{center}
\vspace{1em}(+ symmetric rules)
\par\end{center}%
\end{minipage}
\par\end{flushleft}
\vspace{0.2em}

\begin{tabular}{c|c|c}
\begin{minipage}[c]{0.33\columnwidth}%
%
\vspace{0pt}
\agdacode{unify-app}%
\end{minipage} & %
\begin{minipage}[c]{0.28\columnwidth}%
%
\vspace{0pt}
\agdacode{unify-lam}%
\end{minipage} & %
\begin{minipage}[c]{0.3\columnwidth}%
%%%
\vspace{0pt}
\agdacode{unify-var}%
\end{minipage}\tabularnewline
$\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma_{1}\dashv\Delta_{1}\\
\dotmcontext{\Gamma}\vdash u[\sigma_{1}]=u'[\sigma_{2}]\Rightarrow\sigma_{2}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\vdash t\ u=t'\ u'\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}$ & $\dfrac{\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma\dashv\Delta}{\dotmcontext{\Gamma}\vdash\lambda t=\lambda t'\Rightarrow\sigma\dashv\Delta}$ & $\dfrac{i\neq j}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar j\Rightarrow\bang_{s}\dashv\bot}\qquad\dfrac{}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar i\Rightarrow1_{\Gamma}\dashv\dotmcontext{\Gamma}}$\tabularnewline
\end{tabular}

\vspace{1em}
\begin{center}
\begin{tabular}{cc|ccc}
\begin{minipage}[t]{0.15\columnwidth}%
\vspace{-1em}
\agdacode{unify-bot}%
\end{minipage}$\text{\ensuremath{\labellabelrule{\dfrac{}{\bot\vdash\bang=\bang\Rightarrow\bang_{s}\dashv\bot}}{U-Fail}}}$ &  &  & %
\begin{minipage}[t]{0.15\columnwidth}%
\begin{flushleft}
\vspace{-1em}
\agdacode{unify-last}%
\par\end{flushleft}%
\end{minipage} & $\text{\ensuremath{\dfrac{o\neq o'\ \text{(\emph{rigid} term constructors)}}{\dotmcontext{\Gamma}\vdash o(\vec{t})=o'(\vec{t'})\Rightarrow\bang_{s}\dashv\bot}}}$\tabularnewline
\end{tabular}
\par\end{center}
%
\end{minipage}}
\par\end{raggedright}
\end{figure*}
\begin{figure*}
\begin{raggedright}
\caption{Type signatures of the functions implemented in \Figref{unif-full-lam}
and \Figref{unif-full-gen}\label{fig:type-signatures}}
\par\end{raggedright}
\begin{raggedright}
\begin{minipage}[c]{0.28\textwidth}%
\begin{flushleft}
%%
\agdacode{substfrom}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.33\textwidth}%
\begin{flushleft}
%%
\agdacode{prune-type}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.33\textwidth}%
\begin{flushleft}
\agdacode{prune-sigma-return-type}
\par\end{flushleft}%
\end{minipage}
\par\end{raggedright}
\begin{minipage}[t]{0.5\textwidth}%
\begin{flushleft}
\AgdaNoSpaceAroundCode{}
\agdacode{prune-proto}%
\agdacode{prune-sigma-proto}%
\AgdaSpaceAroundCode{}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}%
\begin{flushleft}
\AgdaNoSpaceAroundCode{}
\agdacode{unify-flex-prototype}%
\agdacode{unifyprototype}%
\agdacode{unify-sigma-prototype}%
\AgdaSpaceAroundCode{}
\par\end{flushleft}%
\end{minipage}
\end{figure*}
\begin{figure*}
\begin{raggedright}
\caption{Our generic pattern unification algorithm \label{fig:unif-full-gen}}
\noindent\fbox{\begin{minipage}[t]{1\textwidth - 2\fboxsep - 2\fboxrule}%

\begin{tabular}{cc|c}
\begin{minipage}[c]{0.35\columnwidth}%
\begin{flushleft}
%%%%
\agdacode{prune-flex}
\par\end{flushleft}%
\end{minipage} & Same as the rule $\refrule{P-Flex}$ in \Figref{unif-full-lam}. & %
\begin{minipage}[c]{0.3\columnwidth}%
\begin{center}
%%%
\agdacode{prune-fail}\vspace{-1em}
\par\end{center}
Same as the rule $\refrule{P-Fail}$ in \Figref{unif-full-lam}.%
\end{minipage}\tabularnewline
\end{tabular}

\begin{minipage}[c]{0.49\textwidth}%
\begin{flushleft}
%%%
\agdacode{prune-rigid}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.5\columnwidth}%
\begin{flushleft}
\[
\labellabelrule{\dfrac{o\neq\rename{\dots}x}{\dotmcontext{\Gamma}\prune{o(\delta)}{\arg x}{\bang_{s}}{\bang}\dashv\bot}}{P-Rig-Fail}
\]
\[
\labellabelrule{\inferruletwo{\dotmcontext{\Gamma}\prune{\delta}{x^{o'}}{\sigma}{\delta'}\dashv\Delta}{o=\rename{o'}x}{\dotmcontext{\Gamma}\prune{o(\delta)}{\arg x}{\sigma}{o'(\delta')}\dashv\Delta}}{P-Rig}
\]
\par\end{flushleft}%
\end{minipage}

\begin{minipage}[c]{0.49\textwidth}%
\begin{flushleft}
%%%
\agdacode{prune-subst}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.5\columnwidth}%
\begin{flushleft}
\[
\labellabelrule{\dfrac{}{\pruningemptyconcl}}{P-Empty}
\]
\par\end{flushleft}
\begin{flushleft}
\[
\labellabelrule{\dfrac{\begin{array}{c}
\Gamma\prune t{x_{0}}{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{\delta[\sigma_{1}]}x{\sigma_{2}\dashv\Delta_{2}}{\delta'}
\end{array}}{\begin{array}{r}
\Gamma\vdash t,\delta:>x_{0},x\Rightarrow\quad\\
t'[\sigma_{2}],\delta';\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}
\end{array}}}{\textsc{P-Split}}
\]
\par\end{flushleft}
%
\end{minipage}%
\end{minipage}}
\par\end{raggedright}
\begin{raggedright}
\noindent\fbox{\begin{minipage}[t]{1\textwidth - 2\fboxsep - 2\fboxrule}%
\begin{flushleft}
$\AgdaFunction{unify-flex-*}$ is defined as in \Figref{unif-full-lam},
replacing $\AgdaFunction{commonPositions}$ with $\AgdaFunction{equaliser}$.
\par\end{flushleft}
\begin{flushleft}
\begin{minipage}[c]{0.55\textwidth}%
\begin{flushleft}
%%%%%
%\agdacode{unify-flex-def}
%
\agdacode{unify-flex}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.43\columnwidth}%
\vspace{-1em}See the rules $\refrule{Same-MVar}$, $\refrule{Cycle}$,
and $\refrule{No-Cycle}$ in \Figref{unif-full-lam}.%
\end{minipage}
\par\end{flushleft}
\vspace{-1em}%
\begin{minipage}[c]{0.49\textwidth}%
\begin{flushleft}
%%%
\agdacode{unify-rigid}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.5\columnwidth}%
\begin{flushleft}
\[
\labellabelrule{\dfrac{o\neq o'}{\dotmcontext{\Gamma}\vdash o(\delta)=o'(\delta')\Rightarrow\bang_{s}\dashv\bot}}{Clash}
\]
\par\end{flushleft}
\begin{flushleft}
\[
\labellabelrule{\dfrac{\dotmcontext{\Gamma}\vdash\delta=\delta'\Rightarrow\sigma\dashv\Delta}{\dotmcontext{\Gamma}\vdash o(\delta)=o(\delta')\Rightarrow\sigma\dashv\Delta}}{U-Rig}
\]
\par\end{flushleft}%
\end{minipage}

\vspace{0.2em}

\begin{minipage}[c]{0.4\textwidth}%
\begin{flushleft}
%%%
\agdacode{unify-fail}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.6\columnwidth}%
\begin{center}
Same as the rule $\refrule{U-Fail}$ in \Figref{unif-full-lam}.
\par\end{center}%
\end{minipage}

\begin{minipage}[c]{0.49\columnwidth}%
\begin{flushleft}
%%%
\agdacode{unify-subst}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.5\columnwidth}%
\[
\labellabelrule{\unificationempty}{U-Empty}
\]
\[
\labellabelrule{\unificationstepwisenovec}{U-Split}
\]

\[
\labellabelrule{\dfrac{}{\bot\vdash1_{\bot}=1_{\bot}\Rightarrow\bang_{s}\dashv\bot}}{U-Id-Fail}
\]
%
\end{minipage}%
\end{minipage}}
\par\end{raggedright}
\end{figure*}

Consider the syntax of pure $\lambda$-calculus extended with pattern
metavariables. We list the Agda code in \Figref{syntax-lam}, together
with a corresponding presentation as inductive rules generating the
syntax. We write $\Gamma;n\vdash t$ to mean $t$ is a well-formed
$\lambda$-term in the context $\Gamma;n$, consisting of two parts:
\begin{enumerate}
\item a metavariable context (or \emph{metacontext}) $\Gamma$, which is
either a formal error context $\bot$, or a \emph{proper }context,
as a list $(M_{1}:m_{1},\dots,M_{p}:m_{p})$, of metavariable declarations
specifying metavariable symbols $M_{i}$ together with their arities,
i.e, their number of arguments $m_{i}$;
\item a variable context, which is a mere natural number indicating the
highest possible free variable.
\end{enumerate}
The error metacontext $\bot$ will prove useful to handle failure
in the unification algorithm. The unification algorithm is fundamentally
a partial one, since unifiers may not exist. Instead of modelling
partiality with some kind of error monad, we instead make our unification
algorithm total by adding a formal error, so that a metacontext is
either a proper metacontext or a formal error metacontext, and the
unification algorithm either returns a proper substitution or an error
substitution. Our approach to failure is actually arises from the
categorical semantics (see \Subsecref{categorification}). 

In the inductive rules, we use the bold face $\dotmcontext{\Gamma}$
for any proper metacontext. In the Agda code, we adopt a nameless
encoding of proper metacontexts: they are mere lists of metavariable
arities, and metavariables are referred to by their index in the list.
The type of metacontexts $\AgdaFunction{MetaContext}$ is formally
defined as $\AgdaDatatype{Maybe}\ (\AgdaDatatype{List}\ \mathbb{N})$,
where $\AgdaDatatype{Maybe}\ X$ is an inductive type with an error
constructor $\bot$ and a success constructor $\lfloor-\rfloor$ taking
as argument an element of type $X$. Therefore, $\dotmcontext{\Gamma}$
typically translates into $\lfloor\Gamma\rfloor$ in the implementation.
To alleviate notations, we also adopt a dotted convention in Agda
to mean that a successful metacontext is involved. For example, $\AgdaFunction{MetaContext\ensuremath{\cdot}}$
and $\AgdaFunction{Tm\ensuremath{\cdot}}\ \Gamma\ n$ are respectively
defined as $\AgdaDatatype{List}\ \mathbb{N}$ and $\AgdaDatatype{Tm}\ \lfloor\Gamma\rfloor\ n$. 

The last term constructor $\bang$ builds a well-formed term in any
error context $\bot;n$. We call it an \emph{error} term: it is the
only one available in such contexts.\emph{ Proper }terms, i.e., terms
well-formed in a proper metacontext, are built from application, $\lambda$-abstraction
and variables: they generate the (proper) syntax of $\lambda$-calculus.
Note that $\bang$ cannot occur as a sub-term of a proper term.
\begin{remark}
\label{rem:non-dotted-version} The names of constructors of $\lambda$-calculus
for application, $\lambda$-abstraction, and variables, are dotted
to indicate that they are only available in a proper metacontext.
``Improper'' versions of those, defined in any metacontext, are
also implemented in the obvious way, coinciding with the constructors
in a proper context, or returning $\bang$ in the error context.
\end{remark}
Free variables are indexed from $1$ and we use the De Bruijn level
convention: the variable bound in $\dotmcontext{\Gamma};n\vdash\lambda t$
is $\var n+1$, not $0$, as it would be using De Bruijn indices~\citet{DB}.
In Agda, variables in the variable context $n$ consist of elements
of $\AgdaDatatype{Fin}\ n$, the type of natural numbers between\footnote{$\AgdaDatatype{Fin}\ n$ is actually defined in the standard library
as an inductive type designed to be (canonically) isomorphic with
$\{0,\dots,n-1\}$.} $1$ and $n$. We also use a nameless encoding of metacontexts: they
are mere lists of metavariable arities, and metavariables are referred
to by their index in the list. Let us focus on the last constructor
building a metavariable application in the context $\dotmcontext{\Gamma};n$.
The argument of type $m\in\dotmcontext{\Gamma}$ is an index of any
element $m$ in the list $\dotmcontext{\Gamma}$. The constructor
also takes an argument of type $m\Rightarrow n$, which unfolds as
$\AgdaDatatype{Vec}\ \AgdaSymbol{(}\AgdaDatatype{Fin}\ \AgdaBound{n}\AgdaSymbol{)}\ \AgdaBound{m}$:
this is the type of lists of size $m$ consisting of elements of $\AgdaFunction{Fin}\ n$,
that is, natural numbers between $1$ and $n$. Note this does not
fully enforce the pattern restriction: metavariable arguments are
not required to be distinct. However, our unification algorithm is
guaranteed to produce correct outputs only if this constraint is satisfied
in the inputs.

  

The Agda implementation of metavariable substitutions for $\lambda$-calculus
is listed in the first box of \Figref{subst-code}. We call a substitution
\emph{successful} if it targets a proper metacontext, \emph{proper}
if the domain is proper. Note that any successful substitution is
proper because there is only one metavariable substitution $1_{\bot}$
from the error context: it is a formal identity substitution, targeting
itself. A \emph{metavariable substitution} $\sigma:\dotmcontext{\Gamma}\rightarrow\Delta$
from a proper context assigns to each metavariable $M$ of arity $m$
in $\dotmcontext{\Gamma}$ a term $\Delta;m\vdash\sigma_{M}$.

\begin{figure}
\begin{raggedright}
\caption{Metavariable substitution \label{fig:subst-code}}
\par\end{raggedright}
\begin{raggedright}
\begin{minipage}[c]{0.5\columnwidth}%
\begin{flushleft}
%%%
\agdacode{dotted-substitution}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.5\columnwidth}%
\begin{flushleft}
%%%
\agdacode{successful-substitution}
\par\end{flushleft}%
\end{minipage}
\par\end{raggedright}
\begin{raggedright}
\vspace{-1em}%
\begin{minipage}[c]{0.4\columnwidth}%
\begin{flushleft}
%%%
\agdacode{substitution-def}
\par\end{flushleft}%
\end{minipage}
\par\end{raggedright}
\noindent\fbox{\begin{minipage}[t]{1\columnwidth - 2\fboxsep - 2\fboxrule}%
\begin{center}
$\lambda$-calculus (\Subsecref{example-lambda})
\par\end{center}
\begin{minipage}[c]{0.6\columnwidth}%
\begin{flushleft}
%%%%%%%%%%%%
\agdacode{lc-substitution}%
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.29\columnwidth}%
\begin{flushleft}
\vspace{0.3em}
\par\end{flushleft}
\begin{flushleft}
\[
\dfrac{\Gamma;n\vdash t\qquad\sigma:\Gamma\rightarrow\Delta}{\Delta;n\vdash t[\sigma]}
\]
\par\end{flushleft}%
\end{minipage}

\begin{minipage}[c]{0.6\columnwidth}%
\begin{flushleft}
%%%%%%
\AgdaNoSpaceAroundCode{}
\agdacode{compose-substitution-proto}%
\agdacode{compose-substitution-def}%
\AgdaSpaceAroundCode{}
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c][1\totalheight][b]{0.29\columnwidth}%
\begin{flushleft}
\vspace{0.3em}
\par\end{flushleft}
\begin{flushleft}
\[
\dfrac{\delta:\Gamma\rightarrow\Delta\quad\sigma:\Delta\rightarrow E}{\underbrace{\delta[\sigma]}_{M\mapsto\delta_{M}[\sigma]}:\Gamma\rightarrow E}
\]
\par\end{flushleft}%
\end{minipage}%
\end{minipage}}

\noindent\fbox{\begin{minipage}[t]{1\columnwidth - 2\fboxsep - 2\fboxrule}%
\begin{center}
Generic syntax (\Subsecref{intro-generic})
\par\end{center}
\begin{minipage}[c]{0.6\columnwidth}%
\begin{flushleft}
%%%%%%%%%%%
\AgdaNoSpaceAroundCode{}
\agdacode{gen-substitution-proto}%
\agdacode{compose-substitution-proto}%
\AgdaSpaceAroundCode{}%
\par\end{flushleft}%
\end{minipage}

\begin{minipage}[c]{0.6\columnwidth}%
\begin{flushleft}
%%%%%%%%%%%
\agdacode{gen-substitution-def}%
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.29\columnwidth}%
\begin{flushleft}
\[
\dfrac{\Gamma;a\vdash t\qquad\sigma:\Gamma\rightarrow\Delta}{\Delta;a\vdash t[\sigma]}
\]
\par\end{flushleft}%
\end{minipage}

\begin{minipage}[c]{0.6\columnwidth}%
\begin{flushleft}
\agdacode{compose-substitution-def}%
\par\end{flushleft}%
\end{minipage}%
\begin{minipage}[c]{0.29\columnwidth}%
\begin{flushleft}
\[
\dfrac{\delta:\Gamma\rightarrow\Delta\quad\sigma:\Delta\rightarrow E}{\underbrace{\delta[\sigma]}_{M\mapsto\delta_{M}[\sigma]}:\Gamma\rightarrow E}
\]
\par\end{flushleft}%
\end{minipage}%
\end{minipage}}

\end{figure}

This assignment extends (through a recursive definition) to any term
$\dotmcontext{\Gamma};n\vdash t$, yielding a term $\Delta;n\vdash t[\sigma]$.
Note that the congruence cases involve improper versions of the operations
(\Remref{non-dotted-version}), as the target metacontext may not
be proper. The base case is $M(x_{1},\dots,x_{m})[\sigma]=\rename{\sigma_{M}}x,$
where $\rename -x$ is variable renaming, defined by recursion. Renaming
a $\lambda$-abstraction requires extending the renaming $x:p\Rightarrow q$
to $x\uparrow\ :p+1\Rightarrow q+1$ to take into account additional
the bound variable $\lcvar{p+1}$, which is renamed to $\lcvar{q+1}$.
Then, $(\lambda t)\{x\}$ is defined as $\lambda(t\{x\uparrow\})$.
While metavariable substitutions change the metacontext of the substituted
term, renamings change the variable context.

The identity substitution $1_{\dotmcontext{\Gamma}}:\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Gamma}$
is defined by the term $M(1,\dots,m)$ for each metavariable declaration
$M:m\in\dotmcontext{\Gamma}$. The composition $\delta[\sigma]:\dotmcontext{\Gamma_{1}}\rightarrow\Gamma_{3}$
of two substitutions $\delta:\dotmcontext{\Gamma_{1}}\rightarrow\Gamma_{2}$
and $\sigma:\Gamma_{2}\rightarrow\Gamma_{3}$ is defined as $M\mapsto\delta_{M}[\sigma]$. 

A \emph{unifier} of two terms $\Gamma;n\vdash t,u$ is a substitution
$\sigma:\Gamma\rightarrow\Delta$ such that $t[\sigma]=u[\sigma]$.
A \emph{most general unifier }(later abbreviated as mgu) of $t$ and
$u$ is a unifier $\sigma:\Gamma\rightarrow\Delta$ that uniquely
factors any other unifier $\delta:\Gamma\rightarrow\Delta'$, in the
sense that there exists a unique $\delta':\Delta\rightarrow\Delta'$
such that $\delta=\sigma[\delta']$. 
\begin{remark}
\label{rem:terminal-unifier}Given a metacontext $\Gamma$, there
is a single \emph{terminal} substitution $\bang_{s}:\Gamma\rightarrow\bot$,
which maps any metavariable to the only available term $\bang$ if
$\Gamma$ is proper, or is the identity substitution $1_{\bot}$ otherwise.
Any term substituted by $\bang_{s}$ yields the error term $\bang$,
since it is the only one in the metacontext $\bot$. As a consequence,
\begin{itemize}
\item $\bang_{s}:\Gamma\rightarrow\bot$ is uniquely factored by any other
substitution $\sigma:\Gamma\rightarrow\Delta$ as the composition
of $\sigma$ with $\bang_{s}:\Delta\rightarrow\bot$
\item $\bang_{s}$ unifies any pair of terms.
\end{itemize}
\end{remark}
%
\begin{remark}
\label{rem:mgus-standard}Because of the additional error context,
our notion of unification differs from the standard presentation,
which is recovered by focusing only on successful substitutions. However,
it follows from \Remref{terminal-unifier} that mgus in the standard
setting are still mgus in our setting. Moreover, when there is no
successful unifier, the terminal substitution is a mgu. 
\end{remark}
The main property of pattern unification is that the mgu of any pair
of terms exists as soon as there exists a unifier. \Remref{mgus-standard}
shows that we can actually get rid of the latter condition: the non-existence
of unifiers (for example, when unifying $t_{1}\ t_{2}$ with $\lambda u$)
is restated as $\bang_{s}$ being the mgu. Accordingly, our implementation
does not explicitly fail. Given two terms $\Gamma;n\vdash t,u$ as
input, the Agda function $\AgdaFunction{unify}$ returns a context
$\Delta$, which is $\bot$ in case there is no successful unifier,
and a substitution $\sigma:\Gamma\rightarrow\Delta$. We denote such
a situation by $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$, leaving
the variable context $n$ implicit: the symbol $\Rightarrow$ separates
the input and the output of the unification algorithm, which is the
mgu of $t$ and $u$, although this property of the output substitution
is not explicit in the type signature (see \Figref{type-signatures}).

This unification function recursively inspects the structure of the
given terms until reaching a metavariable at the top-level, as seen
in the second box of \Figref{unif-full-lam}. The last two cases handle
unification of two error terms, and unification of two different \emph{rigid}
term constructors (application, $\lambda$-abstraction, or variables),
resulting in failure.

When reaching a metavariable application $M(x)$ at the top-level
of either term in a metacontext $\dotmcontext{\Gamma}$, denoting
by $t$ the other term, three situations must be considered:
\begin{enumerate}
\item $t$ is a metavariable application $M(y)$;
\item $t$ is not a metavariable application and $M$ occurs deeply in $t$;
\item $M$ does not occur in $t$.
\end{enumerate}
The $\AgdaFunction{occur-check}$ function returns $\AgdaInductiveConstructor{Same-MVar}\ y$
in the first case, $\AgdaInductiveConstructor{Cycle}$ in the second
case, and $\AgdaInductiveConstructor{No-Cycle}\ t'$ in the last case,
where $t'$ is $t$ but considered in the context $\dotmcontext{\Gamma}$
without $M$, denoted by $\dotmcontext{\Gamma}\backslash M$. 

 

In the first case, the line $\AgdaKeyword{let}\ p,z=\AgdaFunction{commonPositions}\ m\ x\ y$
computes the \emph{vector of common positions }of $x$ and $y$, that
is, the maximal vector of (distinct) positions $(z_{1},\dots,z_{p})$
such that $x_{\vec{z}}=y_{\vec{z}}$. We denote\footnote{The similarity with the above introduced notation is no coincidence:
as we will see (\Remref{equaliser-notation}), both are (co)equalisers.} such a situation by $\highlighted{m\vdash x=y\Rightarrow z\dashv p}$.
The most general unifier $\sigma$ coincides with the identity substitution
except that $M:m$ is replaced by a fresh metavariable $P:p$ in the
context $\dotmcontext{\Gamma}$, and $\sigma$ maps $M$ to $P(z)$. 
\begin{example}
Let $x,y,z$ be three distinct variables, and let us consider unification
of $M(x,y)$ and $M(z,x)$. Given a unifier $\sigma$, since $M(x,y)[\sigma]=\rename{\sigma_{M}}{\lcvar 1\mapsto x,\lcvar 2\mapsto y}$
and $M(z,x)[\sigma]=\rename{\sigma_{M}}{\lcvar 1\mapsto z,\lcvar 2\mapsto x}$
must be equal, $\sigma_{M}$ cannot depend on the variables $\lcvar 1$
and $\lcvar 2$. It follows that the most general unifier is $M\mapsto P$,
replacing $M$ with a fresh constant metavariable $P$. A similar
argument shows that the most general unifier of $M(x,y)$ and $M(z,y)$
is $M\mapsto P(\lcvar 2)$.
\end{example}
The corresponding rule $\refrule{Same-MVar}$ does not stipulate how
to generate the fresh metavariable symbol $P$, although there is
an obvious choice, consisting in taking $M$ which has just been removed
from the context $\dotmcontext{\Gamma}$. Accordingly, the implementation
keeps $M$ but changes its arity to $p$, resulting in a context denoted
by $\dotmcontext{\Gamma}[M:p]$. 

The second case tackles unification of a metavariable application
with a term in which the metavariable occurs deeply. It is handled
by the failing rule $\refrule{Cycle}$: there is no unifier because
the size of both hand sides can never match after substitution.

The last case described by the rule $\refrule{No-cycle}$ is unification
of $M(x)$ with a term $t$ in which $M$ does not occur. This kind
of unification problem is handled specifically by a previously defined
function $\AgdaFunction{prune}$, which we now describe. The intuition
is that $M(x)$ and $t$ should be unified by replacing $M$ with
$t[x_{i}\mapsto\var i]$. However, this only makes sense if the free
variables of $t$ are in $x$. For example, if $t$ is a variable
that does not occur in $x$, then obviously there is no unifier. Nonetheless,
it is possible to prune the \emph{outbound} variables in $t$ as long
as they only occur in metavariable arguments, by restricting the arities
of those metavariables. As an example, if $t$ is a metavariable application
$N(x,y)$, then although the free variables are not all included in
$x$, the most general unifier still exists, essentially replacing
$N$ with $M$, discarding the outbound variables $y$. 

For this pruning phase, we use the notation $\Gamma\prune tx{\sigma\dashv\Delta}{t'}$,
where $t$ is a term in the metacontext $\Gamma$, while $x$ is the
argument of the metavariable whose arity $m$ is left implicit, as
well as its (irrelevant) name. The output is a metacontext $\Delta$,
together with a term $t'$ in context $\Delta;m$, and a substitution
$\sigma:\Gamma\rightarrow\Delta$. If $\Gamma$ is proper, this is
precisely the data for the most general unifier of $t$ and $M(x)$,
considered in the extended metacontext $M:m,\Gamma$. Following the
above pruning intuition, $t'$ is the term $t$ where the outbound
variables have been pruned, in case of success. This justifies the
type signature of the $\AgdaFunction{prune}$ in \Figref{type-signatures}.
This function recursively inspects its argument. The base metavariable
case corresponds to unification of $M(x)$ and $M'(y)$ where $M$
and $M'$ are distinct metavariables. In this case, the line $\AgdaKeyword{let}\ p,x',y'=\AgdaFunction{commonValues}\ m\ x\ y$
computes the vectors of \emph{common value positions }$(x_{1}',\dots,x_{p}')$
and $(y_{1}',\dots,y'_{p})$ between $x_{1},\dots,x_{m}$ and $y_{1},\dots,y_{m'}$,
i.e., the pair of maximal lists $(\vec{x'},\vec{y'})$ of distinct
positions such that $x_{\vec{x'}}=y_{\vec{y'}}$. We denote\footnote{The similarity with the notation for the pruning phase is no coincidence:
both can be interpreted as pullbacks (or pushouts), as we will see
in \Remref{pushout-notation}.} such a situation by $\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}$.
The most general unifier $\sigma$ coincides with the identity substitution
except that the metavariables $M$ and $M'$ are removed from the
context and replaced by a single metavariable declaration $P:p$.
Then, $\sigma$ maps $M$ to $P(x')$ and $M'$ to $P(y')$.
\begin{example}
Let $x,y,z$ be three distinct variables. The most general unifier
of $M(x,y)$ and $N(z,x)$ is $M\mapsto N'(\var 1),N\mapsto N'(\var 2)$.
The most general unifier of $M(x,y)$ and $N(z)$ is $M\mapsto N',N\mapsto N'$.
\end{example}
As for the rule $\refrule{Same-Var}$, the corresponding rule $\refrule{P-Flex}$
does not stipulate how to generate the fresh metavariable symbol $P$,
although the implementation makes an obvious choice, reusing the name
$M$.

The intuition for the application case is that if we want to unify
$M(x)$ with $t\ u$, we can refine $M(x)$ to be $M_{1}(x)\ M_{2}(x)$,
where $M_{1}$ and $M_{2}$ are two fresh metavariables to be unified
with $t$ and $u$. Assume that those two unification problems yield
$t'$ and $u'$ as replacements for $t$ and $u$, as well as substitution
$\sigma_{1}$ and $\sigma_{2}$, then $M$ should be replaced accordingly
with $t'[\sigma_{2}]\ u'$. Note that this really involves improper
application, taking into account the following three subcases at once.
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\dotmcontext{\Delta_{1}}\\
\dotmcontext{\Delta_{1}}\prune{u[\sigma_{1}]}x{\sigma_{2}}{u'}\dashv\dotmcontext{\Delta_{2}}
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}]\ u'}\dashv\dotmcontext{\Delta_{2}}}
\]
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\dotmcontext{\Delta_{1}}\\
\dotmcontext{\Delta_{1}}\prune{u[\sigma_{1}]}x{\bang_{s}}{\bang}\dashv\bot
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\bang_{s}}{\bang}\dashv\bot}\quad\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\bang_{s}}{\bang}\dashv\bot\\
\bot\prune{\bang}x{\bang_{s}}{\bang}\dashv\bot
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\bang_{s}}{\bang}\dashv\bot}
\]

The same intuition applies for $\lambda$-abstraction, but here we
apply the fresh metavariable corresponding to the body of the $\lambda$-abstraction
to the bound variable $\var{n+1}$, which needs not be pruned. In
the variable case, $i\{x\}^{-1}$ returns the index $j$ such that
$i=x_{j}$, or fails if no such $j$ exist.

This ends our description of the unification algorithm, in the specific
case of pure $\lambda$-calculus. The purpose of this work is to present
a generalisation, parameterising the algorithm by a signature specifying
a syntax.


\subsection{Generalisation}

\label{subsec:intro-generic}In this section, we show how to abstract
over $\lambda$-calculus to get a generic algorithm for pattern unification,
parameterised by a new notion of signature to account for syntax with
metavariables. We split this notion in two parts: 
\begin{enumerate}
\item a notion of generalised binding signature, or GB-signature (formally
introduced in \Defref{GB-signature}), specifying a syntax with metavariables,
for which unification problems can be stated; 
\item some additional structures used in the algorithm to solve those unification
problems, as well as properties ensuring its correctness, making the
GB-signature \emph{pattern-friendly} (see \Defref{pattern-friendly}).
\end{enumerate}
This separation is motivated by the fact that in the case of $\lambda$-calculus,
the vectors of common (value) positions as well as inverse renaming
$-\{-\}^{-1}$ of variables are involved in the algorithm, but not
in the definition of the syntax and associated operations (renaming,
metavariable substitution).

Let us first focus on the notion of GB-signature, starting from binding
signatures~\citet{aczel2016general}: the latter consist in a set
of operation symbols, and for each $o\in O$, an arity $\ntharvec o=(\nthar o1,\dots,\nthar on)$,
i.e., a list of natural numbers specifying how many variables are
bound in each argument. For example, pure $\lambda$-calculus is specified
by $O=\{lam,app\}$, with $\ntharvec{app}=(0,0)$, $\ntharvec{lam}=(1)$.
Now, a GB-signature consists in a tuple $({\cal A},O,\ntharvecfunct)$
consisting of 
\begin{itemize}
\item a small category ${\cal A}$ whose objects are called \emph{arities}\textit{
}\textit{\emph{or}}\textit{ variable contexts}\textit{\emph{,}} and
whose morphisms are called \textit{renamings};
\item for each variable context $a$, a set of operation symbols $O(a)$;
\item for each operation symbol $o\in O(a)$, a list of variable contexts
$\ntharvec o=(\nthar o1,\dots,\nthar on)$.
\end{itemize}
such that $O$ and $\ntharvecfunct$ are functorial in a suitable
sense (see \Remref{bgsig-functorial} below). Intuitively, $O(a)$
is the set of operation symbols available in the variable context
$a$. The Agda implementation in \Figref{sig-agda} does not include
properties such as associativity of morphism composition, although
they are assumed in the proof of correctness. For example, the latter
associativity property ensures that composition of metavariable substitutions
is associative.

\begin{figure}
\raggedright{}\caption{Generalised binding signatures in Agda\label{fig:sig-agda}}
\begin{minipage}[b]{0.65\columnwidth}%
\begin{flushleft}
%%%
\begin{AgdaAlign}
\agdacode{signature-core}
\agdacode{signature-functoriality}
\end{AgdaAlign}
\par\end{flushleft}%
\end{minipage}
\end{figure}
\begin{figure*}
\begin{raggedright}
\caption{Syntax generated by a GB-signature\label{fig:sig-syntax}}
\par\end{raggedright}
\raggedright{}%
\begin{minipage}[c]{0.65\columnwidth}%
%%%%%%%
\agdacode{metacontext}%
\agdacode{syntax-decl}%%
\end{minipage}%
\begin{minipage}[c]{0.65\columnwidth}%
%%%%%%%
\agdacode{syntax-def}%
\end{minipage}%
\begin{minipage}[c]{0.8\columnwidth}%
\[
\labellabelrule{\dfrac{o\in O(a)\quad\overbrace{\dotmcontext{\Gamma};\nthar o1\vdash t_{1}\quad\dots\quad\Gamma;\nthar on\vdash t_{n}}^{"\alpha_{o}\xrightarrow{\vec{t}}\Gamma"}}{\dotmcontext{\Gamma};a\vdash o(t_{1},\dots,t_{n})}}{Rig}
\]

\[
\labellabelrule{\dfrac{M:m\in\dotmcontext{\Gamma}\quad x\in\hom_{{\cal A}}(m,a)}{\dotmcontext{\Gamma};a\vdash M(x)}}{Flex}
\]

\[
\dfrac{}{\bot;n\vdash\bang}
\]
%
\end{minipage}
\end{figure*}

The syntax specified by a GB-signature $({\cal A},O,\ntharvecfunct)$
is inductively defined in \Figref{sig-syntax}, where a context $\Gamma;a$
is defined as in \Subsecref{example-lambda} for $\lambda$-calculus,
except that variables contexts and metavariable arities are objects
of ${\cal A}$ instead of natural numbers. We call a term \emph{rigid
}if it is of the shape $o(\dots)$, \emph{flexible} if it is some
metavariable application $M(\dots)$.
\begin{remark}
\label{rem:arg-op-subst}Recall that the Agda code uses a nameless
convention for metacontexts: they are just lists of variable contexts.
Therefore, the arity \textup{$\alpha_{o}$} of an operation $o$ can
be considered as a metacontext. It follows that the argument of an
operation $o$ in the context $\dotmcontext{\Gamma};a$ can be specified
either as a metavariable substitution (defined in \Figref{subst-code})
from $\alpha_{o}=(\nthar o1,\dots,\nthar on)$ to $\dotmcontext{\Gamma}$,
as in the Agda code, or explicitly as a list of terms $(t_{1},\dots,t_{n})$
such that $\dotmcontext{\Gamma};\nthar oi\vdash t_{i}$, as in the
rule $\refrule{Rig}$. In the following, we will use either interpretation.
\end{remark}
%
\begin{remark}
The syntax in the empty metacontext does not depend on the morphisms
in ${\cal A}$. In fact, by restricting the morphisms in ${\cal A}$
to identity morphisms, any GB-signature induces an indexed container~\citet{DBLP:conf/lics/AltenkirchM09}
generating the same syntax without metavariables.
\end{remark}
\begin{example}
\label{ex:gbsig-bsig}Binding signatures can be compiled into GB-signatures.
More specifically, a syntax specified by a binding signature $(O,\alpha)$
is also generated by the GB-signature $(\mathbb{F}_{m},O',\nthaarvecfunct$),
where
\begin{itemize}
\item $\mathbb{F}_{m}$ is the category of finite cardinals and injections
between them;
\item $O'(p)=\{\lcvar 1,\dots,\lcvar p\}\sqcup\{o_{p}|o\in O\}$;
\item $\nthaarvec{\lcvar i}=()$ and $\nthaarvec{o_{p}}=(p+\nthar o1,\dots,p+\nthar on)$
for any $i,p\in\mathbb{N}$ and $n$-ary operation symbol $o\in O$.
\end{itemize}
Note that variables $\lcvar i$ are explicitly specified as nullary
operations and thus do not require a dedicated generating rule, contrary
to what happens with binding signatures. Moreover, the choice of renamings
(i.e., morphisms in the category of arities) is motivated by the $\refrule{Flex}$
rule. Indeed, if $M$ has arity $m\in\mathbb{N}$, then a choice of
arguments in the variable context $a\in\mathbb{N}$ consists of a
list of distinct variables in the variable context $a$, or equivalently,
an injection between the cardinal sets $m$ and $a$, that is, a morphism
in $\mathbb{F}_{m}$ between $m$ and $a$.

GB-signatures capture multi-sorted binding signatures such as simply-typed
$\lambda$-calculus, or polymorphic syntax such as System F (see \Appref{applications}).
Although equations are not explicitly supported, simply-typed $\lambda$-calculus
modulo $\beta$- and $\eta$- equations can be handled by working
on the normalised syntax (see \Subsecref{normalised-lc}).
\end{example}
%
\begin{remark}
\label{rem:bgsig-functorial}In the notion of GB-signature, functoriality
ensures that the generated syntax supports renaming: given a morphism
$x:a\rightarrow b$ in ${\cal A}$ and a term $\Gamma;a\vdash t$,
we can recursively define a term $\Gamma;b\vdash\rename tx$. The
metavariable base case is the same as in \Subsecref{example-lambda}:
$\rename{M(y)}x=M(x\circ y)$. For an operation $o(t_{1},\dots,t_{n})$,
functoriality provides the following components:
\begin{enumerate}
\item a $n$-ary operation symbol $\rename ox\in O(b)$;
\item a list of morphisms $(x_{1}^{o},\dots,x_{n}^{o})$ in ${\cal A}$
such that $\ntharvecaction oxi:\nthar oi\rightarrow\nthar{\rename ox}i$
for each $i\in\{1,\dots,n\}$. 
\end{enumerate}
Then, $\rename{o(t_{1},\mydots,t_{n})}x$ is defined as $\rename ox(\rename{t_{1}}{\ntharvecaction ox1},\mydots,\rename{t_{n}}{\ntharvecaction oxn})$.

\end{remark}
\begin{notation}
\label{not:vector-renamings}If $\dotmcontext{\Gamma}$ and $\dotmcontext{\Delta}$
are two metacontexts $M_{1}:m_{1},\dots,M_{p}:m_{p}$ and $N_{1}:n_{1},\dots,N_{p}:n_{p}$
of the same length, we write $\delta:\dotmcontext{\Gamma}\Longrightarrow\dotmcontext{\Delta}$
to mean that $\delta$ is a \emph{vector of renamings} $(\delta_{1},\dots,\delta_{n})$
between $\dotmcontext{\Gamma}$ and $\dotmcontext{\Delta}$, in the
sense that each $\delta_{i}$ is a morphism between $m_{i}$ and \textbf{$n_{i}$}.
The second functoriality component in \Remref{bgsig-functorial} is
accordingly specified as a vector of renamings $x^{o}:\alpha_{o}\Longrightarrow\alpha_{\rename of}$
in \Figref{sig-syntax}, considering operation arities as nameless
metacontexts (\Remref{arg-op-subst}). We extend the renaming notation
to substitutions: given $\delta:\Gamma\rightarrow\dotmcontext{\Delta}$
and $x:\dotmcontext{\Delta'}\Longrightarrow\dotmcontext{\Delta}$,
we define $\rename{\delta}x:\Gamma\rightarrow\dotmcontext{\Delta'}$
as $(\rename{\delta_{1}}{x_{1}},\dots,\rename{\delta_{n}}{x_{n}})$
where $n$ is the length of $\Delta$, so that $\rename{o(\delta)}x$
can be equivalently defined as $\rename ox(\rename{\delta}{x^{o}})$.
Note that a vector of renamings $\delta:\dotmcontext{\Gamma}\Longrightarrow\dotmcontext{\Delta}$
canonically induces a metavariable substitution $\substofrenamings{\delta}:\dotmcontext{\Delta}\rightarrow\dotmcontext{\Gamma}$,
mapping $N_{i}$ to $M_{i}(\delta_{i})$.
\end{notation}
The Agda code adapting the definitions of \Subsecref{example-lambda}
to a syntax generated by a generic signature is usually shorter because
the application, $\lambda$-abstraction, and variable cases are replaced
with a single rigid case. Because of \Remref{arg-op-subst}, it is
more convenient define operations on terms mutually with the corresponding
operations on substitutions. For example, composition of substitutions
is defined mutually with substitution of terms in the second box of
\Figref{subst-code}. The same applies for renaming of terms and substitution
as in \Notref{vector-renamings}. 

We are similarly led to generalise unification of terms to unification
of proper substitutions, and we extend accordingly the notation. Given
two substitutions $\delta_{1},\delta_{2}:\dotmcontext{\Gamma'}\rightarrow\Gamma$,
we write $\Gamma\vdash\delta_{1}=\delta_{2}\Rightarrow\sigma\dashv\Delta$
to mean that $\sigma:\Gamma\rightarrow\Delta$ unifies $\delta_{1}$
and $\delta_{2}$, in the sense that $\delta_{1}[\sigma]=\delta_{2}[\sigma]$,
and is the most general one, i.e., it uniquely factors any other unifier
of $\delta_{1}$ and $\delta_{2}$. The main unification function
is thus split in two functions, $\AgdaFunction{unify}$ for single
terms, and $\AgdaFunction{unify-\ensuremath{\sigma}}$ for substitutions
as seen in \Figref{type-signatures}. Similarly, we define pruning
of terms mutually with pruning of proper substitutions. We thus also
extend the pruning notation: given a substitution $\delta:\dotmcontext{\Gamma'}\rightarrow\Gamma$
and a vector $x:\dotmcontext{\Gamma''}\Longrightarrow\dotmcontext{\Gamma'}$
of renamings, the judgement $\Gamma\prune{\delta}x{\sigma}{\delta'}\dashv\Delta$
means that the substitution $\sigma:\Gamma\rightarrow\Delta$ extended
with $\delta':\dotmcontext{\Gamma''}\rightarrow\Delta$ is the most
general unifier of $\delta$ and $\substofrenamings x$ as substitutions
from $\Gamma,\dotmcontext{\Gamma'}$ to $\Delta$. This justifies
the return type of $\AgdaFunction{unify-\ensuremath{\sigma}}$ in
\Figref{type-signatures}.
\begin{flushleft}
\par\end{flushleft}

In the $\lambda$-calculus implementation (\Figref{unif-full-lam}),
unification of two metavariable applications requires computing the
vector of common positions or value positions of their arguments,
depending on whether the involved metavariables are identical. Both
vectors are characterised as equalisers or pullbacks in the category
$\mathbb{F}_{m}$ defined in \Exref{gbsig-bsig}, thus providing a
canonical replacement in the generic algorithm, along with new interpretations
of the notations $\highlighted{m\vdash x=y\Rightarrow z\dashv p}$
and $\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}$ and as equalisers
and pullbacks.
\begin{notation}
\label{not:highlighted-cat-notations}We denote an equaliser $\xymatrix{p\ar[r]^{z} & m\coeqr{x}{y} & \dots}
$ in ${\cal A}$ by $\highlighted{m\vdash x=y\Rightarrow z\dashv p}$.
Similarly, $\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}$ denotes
a pullback in ${\cal A}$ of the shape $\begin{array}{c}
\xymatrix{p\ar[r]^{x'}\ar[d]_{y'} & m\ar[d]^{x}\\
\dots\ar[r]_{y} & \dots
}
\end{array}.$
\end{notation}
Let us now comment on pruning rigid terms, when we want to unify an
operation $o(\delta)$ with a fresh metavariable application $M(x)$.
Any unifier must replace $M$ with an operation $o'(\delta')$, such
that $\rename{o'}x(\rename{\delta'}{x^{o'}})=o(\delta)$, so that,
in particular, $\rename{o'}x=o$. In other words, $o$ must be have
a preimage $o'$ for renaming by $x$. This is precisely the point
of the inverse renaming $\rename ox^{-1}$ in the Agda code: it returns
a preimage $o'$ if it exists, or fails. In the $\lambda$-calculus
case, this check is only explicit for variables, since there is a
single version of application and $\lambda$-abstraction symbols in
any variable context. Inverse renaming is a function provided by \emph{friendly
}GB-signatures, which are GB-signatures with additional components
listed in \Figref{friendly-gb-agda} on which the algorithm relies
on. To sum up, 
\begin{itemize}
\item equalisers and pullbacks are used when unifying two metavariable applications;
\item equality of operation symbols is used when unifying two rigid terms;
\item inverse renaming is used when pruning a rigid term.
\end{itemize}
The formal notion of pattern-friendly signatures (\Defref{pattern-friendly})
includes additional properties ensuring correctness of the algorithm.

\begin{figure}
\raggedright{}\caption{Friendly GB-signatures in Agda\label{fig:friendly-gb-agda}}
\agdacode{friendlysignature}
\end{figure}


\section{Categorical semantics}

\label{sec:cat-settings}To prove that the algorithm is correct, we
show in the next sections that the inductive rules describing the
implementation are sound. For instance, the rule $\refrule{U-Split}$
is sound on the condition that the output of the conclusion is a most
general unifier whenever the output of the premises are most general
unifiers. We rely on the categorical semantics of pattern unification
that we introduce in this section. In \Subsecref{categorification},
we relate pattern unification to a coequaliser construction, and in
\subsecref{GB-sig}, we provide a formal definition of GB-signatures
with Initial Algebra Semantics for the generated syntax. 

\subsection{Pattern unification as a coequaliser construction}

\label{subsec:categorification}

In this section, we assume given a GB-signature $S=({\cal A},O,\ntharvecfunct)$
and explain how most general unifiers can be thought of as equalisers
in a multi-sorted Lawvere theory, as is well-known in the first-order
case~\citet{DBLP:books/daglib/0068768,10.5555/92134}. We furthermore
provide a formal justification for the error metacontext $\bot$.
\begin{lemma}
Proper metacontexts and substitutions (with their composition) between
them define a category $\Th S$.
\end{lemma}
This relies on functoriality of GB-signatures that we will spell out
formally in the next section. There, we will see in \Lemref{mcon-kleisli}
that this category fully faithfully embeds in a Kleisli category for
a monad generated by $S$ on $[{\cal A},\Set]$.
\begin{remark}
The opposite category of $\Th S$ is equivalent to a multi-sorted
Lawvere theory whose sorts are the objects of ${\cal A}$. In general,
this theory is not freely generated by operations unless ${\cal A}$
is discrete, in which case we recover (multi-sorted) first-order unification.
Note that even the GB-signature induced (as in \Exref{gbsig-bsig})
by an empty binding signature is not ``free'' in this sense.
\end{remark}
\begin{lemma}
The most general unifier of two parallel substitutions $\xymatrix{\dotmcontext{\Gamma'}\coeqr{\delta_{1}}{\delta_{2}} & \dotmcontext{\Gamma}}
$ is characterised as their coequaliser.
\end{lemma}
This motivates a new interpretation of the unification notation, that
we introduce later in \Notref{cat-coeq}, after explaining how failure
is categorically handled. Indeed, pattern unification is typically
stated as the existence of a coequaliser on the condition that there
is a unifier in this category $\Th S$. But we can get rid of this
condition by considering the category $\Th S$ freely extended with
a terminal object $\bot$, resulting in the full category of metacontexts
and substitutions.

\begin{definition}
Given a category $\mathscr{B}$, let $\catbot{\B}$ denote the category
$\mathscr{B}$ extended freely with a terminal object $\bot$.
\end{definition}
\begin{notation}
We denote by $\bang_{s}$ any terminal morphism to $\bot$ in $\B_{\bot}$.
\end{notation}
\begin{lemma}
metacontexts and substitutions between them define a category which
is isomorphic to $\Thbot S$.
\end{lemma}
In \Subsecref{example-lambda}, we already made sense of this extension.
Let us rephrase our explanations from a categorical perspective. Adding
a terminal object results in adding a terminal cocone to all diagrams.
As a consequence, we have the following lemma.
\begin{lemma}
Let $J$ be a diagram in a category $\mathscr{B}$. The following
are equivalent:
\begin{enumerate}
\item $J$ has a colimit as long as there exists a cocone;
\item $J$ has a colimit in $\catbot{\B}$.
\end{enumerate}
\end{lemma}
\begin{longproof}
Straightforward, because a colimit is defined as an initial cocone.
\end{longproof}
%
The following results are also useful.
\begin{lemma}
Let $\mathscr{B}$ be a category.
\begin{enumerate}[label=(\roman{enumi}), ref=\thelemma.(\roman{enumi})]
\item \label{lem:bot-creates}The canonical embedding functor $\mathscr{B}\rightarrow\catbot{\mathscr{B}}$
creates colimits. 
\item \label{lem:diag-bot}Any diagram $J$ in $\B_{\bot}$ such that $\bot$
is in its image has a colimit given by the terminal cocone on $\bot$.
\end{enumerate}
\end{lemma}
This ensures in particular that coproducts in $\Th S$, which are
computed as union of metacontexts, are also coproducts in $\Thbot S$.
It also justifies defining the union of a proper metacontext with
$\bot$ as $\bot$.

The main property of this extension for our purposes is the following
corollary.
\begin{corollary}
\label{cor:completeness-algo}Any coequaliser in $\Th S$ is also
a coequaliser in $\Thbot S$. Moreover, whenever there is no unifier
of two lists of terms, then the coequaliser of the corresponding parallel
arrows in $\Thbot S$ exists: it is the terminal cocone on $\bot$.
\end{corollary}
This justifies the following interpretation to the unification notation.
\begin{notation}
\label{not:cat-coeq}$\Gamma\vdash\delta_{1}=\delta_{2}\Rightarrow\sigma\dashv\Delta$
denotes a coequaliser $\xymatrix{\dots\coeqr{\delta_{1}}{\delta_{2}} & \Gamma\ar[r]^{\sigma} & \Delta}
$ in $\Thbot S$.
\end{notation}
\begin{remark}
\label{rem:equaliser-notation}This is the same interpretation as
in \Notref{highlighted-cat-notations} for equaliser, taking ${\cal A}$
to be the opposite category of $\Thbot S$.
\end{remark}
Categorically speaking, our pattern-unification algorithm provides
an explicit proof of the following statement, where the conditions
for a signature to be \emph{pattern-friendly }are introduced in the
next section (\Defref{pattern-friendly}).
\begin{theorem}
Given any pattern-friendly signature $S$, the category $\Thbot S$
has coequalisers.
\end{theorem}
\begin{full}
\begin{remark}
\label{rem:res-monad} The main property that justifies unification
of two metavariables as an equaliser or a pullback in ${\cal A}$
is that given any metacontext $\Gamma$, the functor $T\Gamma:{\cal A}\rightarrow\Set$
preserves them, i.e., $T\Gamma\in\C$. In fact, the argument works
not only in the category of metacontexts and substitutions, but also
in the (larger) category of objects of $\C$ and Kleisli morphisms
between them. However, counter-examples can be found in the total
Kleisli category. Consider indeed the unification problem $M(x,y)=M(y,x)$,
in the example of pure $\lambda$-calculus. We can define\footnote{Define $P_{n}$ as the set of two-elements sets of $\{0,\dots,n-1\}$.}
a functor $P$ that does not preserve finite connected colimits such
that $T(P)$ is the syntax extended with a binary commutative metavariable
$M'(-,-)$. Then, the most general unifier, computed in the total
Kleisli category, replaces $M$\textcolor{red}{{} }with $P$. But in
the Kleisli category restricted to coproducts of representable functors,
or more generally, to objects of $\C$, the coequaliser replaces $M$
with a constant metavariable, as expected.
\end{remark}
\end{full}

\subsection{Initial Algebra Semantics for GB-signatures}

\label{subsec:GB-sig}
\begin{definition}
\label{def:GB-signature}A \emph{generalised binding signature}, or
\emph{GB-signature, }is a tuple $({\cal A},\indexedO,\ntharvecfunct)$
consisting of
\begin{itemize}
\item a small category ${\cal A}$ of arities and renamings between them;
\item a functor $\Oop --:\mathbb{N}\times{\cal A}\rightarrow\Set$ of operation
symbols;
\item a functor $\alpha:\int J\rightarrow{\cal A}$
\end{itemize}
where $\int J$ denotes the category of elements of $J:\mathbb{N}\times{\cal A}\rightarrow\Set$
mapping $(n,a)$ to $\Oop na\times\{1,\dots.,n\}$, defined as follows:
\begin{itemize}
\item objects are tuples $(n,a,o,i)$ such that $o\in\Oop na$ and $i\in\{1,\dots,n\}$;
\item a morphism between $(n,a,o,i)$ and $(n',a',o',i')$ is a morphism
$f:a\rightarrow a'$ such that $n=n'$, $i=i'$ and $\rename of=o'$
where $o\{f\}$ denotes the image of $o$ by the function $\Oop nf:\Oop na\rightarrow\Oop n{a'}$.
\end{itemize}
\end{definition}
\begin{remark}
This definition of GB-signatures superficially differs from the one
we informally introduced in \Subsecref{intro-generic}, in the sense
that the set of operation symbols $O(a)$ in a variable context $a$
was not indexed by natural numbers. The two descriptions are equivalent:
$\Oop na$ is recovered as the subset of $n$-ary operation symbols
in $O(a)$, and conversely, $O(a)$ is recovered as the union of all
the $\Oop na$ for every natural number $n$.
\end{remark}
We now introduce our conditions for the generic unification algorithm
to be correct.
\begin{definition}
\label{def:pattern-friendly}A GB-signature $S=({\cal A},\indexedO,\ntharvecfunct)$
is said \emph{pattern-friendly }if 
\begin{enumerate}
\item ${\cal A}$ has finite connected limits;
\item all morphisms in ${\cal A}$ are monomorphic;
\item each $\Oop n-:{\cal A}\rightarrow\Set$ preserves finite connected
limits;
\item $\alpha$ preserves finite connected limits.
\end{enumerate}
\end{definition}
\begin{full}
\begin{remark}
The first condition is equivalent to the existence of equalisers and
pullbacks in ${\cal A}$, since any finite connected limit can be
constructed from those.
\end{remark}
\end{full}

These conditions ensure the following two properties.
\begin{property}[proved in~$\S$\ref{app:proof-L-preserves}]
\label{assu:main-properties}The following properties hold.
\begin{enumerate}[label=(\roman{enumi}), ref=\theproperty.(\roman{enumi})]
\item \label{assu:O-mono}The action of $\Oby n:{\cal A}\rightarrow\Set$
on any renaming is an injection: given any $o\in\Oop nb$ and renaming
$f:a\rightarrow b$, there is at most one $o'\in\Oop na$ such that
$o=\rename{o'}f$.
\item \label{assu:L-finite-conncted}Let ${\cal L}$ be the functor $\op{{\cal A}}\xrightarrow{}\Thbot S$
mapping a morphism $x\in\hom_{{\cal A}}(b,a)$ to the substitution
$(X:a)\rightarrow(X:b)$ selecting (by the Yoneda Lemma) the term
$X(x)$. Then, ${\cal L}$ preserves finite connected colimits: it
maps pullbacks and equalisers in ${\cal A}$ to pushouts and coequalisers
in $\Thbot S$.
\end{enumerate}
\end{property}
The first property is used for soundness of the rules $\refrule{P-Rig}$
and $\refrule{P-Rig-Fail}$. The second one is used to justify unification
of two metavariables applications as pullbacks and equalisers in ${\cal A}$,
in the rules $\refrule{Same-MVar}$ and $\refrule{P-Flex}$.
\begin{remark}
\label{rem:functor-L-intuition}A metavariable application $\dotmcontext{\Gamma};a\vdash M(x)$
corresponds to the composition ${\cal L}x[in_{M}]$ as a substitution
from $X:a$ to $\dotmcontext{\Gamma}$, where $in_{M}$ is the coproduct
injection $(X:m)\cong(M:m)\hookrightarrow\dotmcontext{\Gamma}$ mapping
$M$ to $M(1_{m})$.
\end{remark}
The rest of this section, we provide Initial Algebra Semantics for
the generated syntax (this is used in the proof of \Assuref{L-finite-conncted}). 

Any GB-signature $S=({\cal A},\indexedO,\ntharvecfunct)$, generates
an endofunctor $F_{S}$ on $[{\cal A},\Set]$, that we denote by just
$F$ when the context is clear, defined by
\[
F_{S}(X)_{a}=\coprod_{n\in\mathbb{N}}\coprod_{o\in\Oop na}X_{\nthar o1}\times\dots\times X_{\nthar on}.
\]
%
\begin{lemma}[proved in~$\S$\ref{app:F-finitary}]
\label{lem:F-finitary}$F$ is finitary and generates a free monad
$T$. Moreover, $TX$ is the initial algebra of $Z\mapsto X+FZ$.

\label{lem:free-alg-syntax}The proper syntax generated by a GB-signature
(see \Figref{sig-syntax}) is recovered as free algebras for $F$.
More precisely, given a metacontext $\dotmcontext{\Gamma}=(M_{1}:m_{1},\dots,M_{p}:m_{p})$,
\[
T(\underline{\Gamma})_{a}\cong\{t\ |\ \Gamma;a\vdash t\}
\]

where $\underline{\dotmcontext{\Gamma}}:{\cal A}\rightarrow\Set$
is defined as the coproduct of representable functors $\coprod_{i}ym_{i}$,
mapping $a$ to $\coprod_{i}\hom_{{\cal A}}(m_{i},a)$. Moreover,
the action of $T(\underline{\dotmcontext{\Gamma}})$ on morphisms
of ${\cal A}$ correspond to renaming.

\end{lemma}
\begin{notation}
Given a proper metacontext $\dotmcontext{\Gamma}$. We sometimes denote
$\underline{\dotmcontext{\Gamma}}$ just by $\dotmcontext{\Gamma}$.
\end{notation}
If $\dotmcontext{\Gamma}=(M_{1}:m_{1},...,M_{p}:m_{p})$ and $\dotmcontext{\Delta}$
are metacontexts, a Kleisli morphism $\sigma:\dotmcontext{\Gamma}\rightarrow T\dotmcontext{\Delta}$
is equivalently given (by combining the above lemma, the Yoneda Lemma,
and the universal property of coproducts) by a metavariable substitution
from $\dotmcontext{\Gamma}$ to $\dotmcontext{\Delta}$. Moreover,
Kleisli composition corresponds to composition of substitutions. This
provides a formal link between the category of metacontexts $\Th S$
and the Kleisli category of $T$
\begin{lemma}
\label{lem:mcon-kleisli}The category $\Th S$ is equivalent to the
full subcategory of $\Kl T$ spanned by coproducts of representable
functors.
\end{lemma}
%
We exploit this characterisation to prove various properties of this
category when the signature is \emph{pattern-friendly}.

\begin{full}
\begin{remark}
It follows from \Lemref{mcon-kleisli} and \citet[Exercise VI.5.1][]{MacLane:cwm}
that $\Th S$ fully faithfully embeds in the category of algebras
of $T$, by mapping a metacontext $\dotmcontext{\Gamma}$ to the free
algebra $T\dotmcontext{\Gamma}$. In fact, $\Thbot S$ also fully
faithfully embeds in the category of algebras by mapping $\bot$ to
the terminal algebra, whose underlying functor maps any object of
${\cal A}$ to a singleton set.
\end{remark}
\end{full}
\begin{lemma}[proved in~$\S$\ref{app:resF-direct}]
\label{lem:res-F}Given a GB-signature $S=({\cal A},\indexedO,\ntharvecfunct)$
such that ${\cal A}$ has finite connected limits, $F_{S}$ restricts
as an endofunctor on the full subcategory $\C$ of $[{\cal A},\Set]$
consisting of functors preserving finite connected limits if and only
if the last two conditions of \Defref{pattern-friendly} holds.
\end{lemma}
We now assume given a pattern-friendly signature $S=({\cal A},\indexedO,\ntharvecfunct)$.
\begin{lemma}[proved in~$\S$\ref{app:lims-coprod-pw}]
\label{lem:lims-coprod-pw}$\C$ is closed under limits, coproducts,
and filtered colimits. Moreover, it is cocomplete.
\end{lemma}
\begin{corollary}[proved in~$\S$\ref{app:T-res}]
\label{cor:-T-res}$T$ restricts as a monad on $\C$ freely generated
by the restriction of $F$ as an endofunctor on $\C$ (\Lemref{res-F}).
\end{corollary}

\section{Soundness of the pruning phase}

\label{sec:pruning-phase}In this section, we assume a pattern-friendly
GB-signature $S$ and discuss soundness of the main rules of the two
mutually recursive functions $\AgdaFunction{prune}$ and $\AgdaFunction{prune-\ensuremath{\sigma}}$
listed in \Figref{unif-full-gen}, which handles unification of two
substitutions $\delta:\dotmcontext{\Gamma'_{1}}\rightarrow\Gamma$
and $\substofrenamings x:\dotmcontext{\Gamma'_{1}}\rightarrow\dotmcontext{\Gamma'_{2}}$
where $\substofrenamings x$ is induced by a vector of renamings $x:\dotmcontext{\Gamma'_{2}}\Longrightarrow\dotmcontext{\Gamma'_{1}}$.
Strictly speaking, this is not unification as we introduced it because
$\delta$ and $\substofrenamings x$ do not target the same context,
but it is straightforward to adapt the definition: a unifier is given
by two substitutions $\sigma:\Gamma\rightarrow\Delta$ and $\sigma':\dotmcontext{\Gamma'_{2}}\rightarrow\Delta$
such that the following equation holds
\begin{equation}
\delta[\sigma]=\substofrenamings x[\sigma']\label{eq:unif-pruning}
\end{equation}
As usual, the mgu is defined as the unifier uniquely factoring any
other unifier. 
\begin{remark}
\label{rem:cocone-pruning}The right hand-side $\substofrenamings x[\sigma']$
in (\ref{eq:unif-pruning}) is actually equal to $\rename{\sigma'}x$.
Indeed, $\substofrenamings x=(\dots,M_{i}(x_{i}),\dots)$ and $M_{i}(x_{i})[\sigma']=\rename{\sigma'_{i}}{x_{i}}$.
\end{remark}
From a categorical point of view, such a mgu is characterised as a
pushout.
\begin{notation}
Given $\delta:\dotmcontext{\Gamma'_{1}}\rightarrow\Gamma$, $x:\dotmcontext{\Gamma'_{2}}\Longrightarrow\dotmcontext{\Gamma'_{1}}$,
$\sigma:\Gamma\rightarrow\Delta$, and $\sigma':\dotmcontext{\Gamma'_{2}}\rightarrow\Delta$,
the notation $\Gamma\prunecat{\delta}x{\sigma}{\sigma'}{}\dashv\Delta$
means that the square $\begin{array}{c}
\xymatrix{\dotmcontext{\Gamma'_{1}}\ar[r]^{\substofrenamings x}\ar[d]_{\delta} & \dotmcontext{\Gamma'_{2}}\ar[d]^{\sigma'}\\
\Gamma\ar[r]_{\sigma} & \Delta
}
\end{array}$ is a pushout in $\Thbot S$.
\end{notation}
\begin{remark}
\label{rem:pushout-notation}This justifies the similarity between
the pruning notation $-\prunecat ----{}$ and the pullback notation
of \Notref{highlighted-cat-notations}, since pushouts in a category
are nothing but pullbacks in the opposite category.
\end{remark}
In the following subsections, we detail soundness of the rules for
the rigid case (\Subsecref{case-KA-RiTC}) and then for the flex case
(\Subsecref{pruning-metavar}).

The rules $\refrule{P-Empty}$ and $\refrule{P-Split}$ are straightforward
adaptions specialised to those specific unification problems of the
rules $\refrule{U-Empty}$ and $\refrule{U-Split}$ described later
in \Subsecref{u-sequential}. The failing rule $\refrule{P-Fail}$
is justified by \Lemref{diag-bot}.

\subsection[Rigid (rules P-Rig and P-Rig-Fail)]{Rigid (rules $\protect\refrule{P-Rig}$ and $\protect\refrule{P-Rig-Fail}$)}

\label{subsec:case-KA-RiTC}
\begin{personalquestion}
Maybe it would be clearer to use the epimorphic properties of coequalisers
exposed in \citet[Chapter 9]{DBLP:books/daglib/0068768}?
\end{personalquestion}
The rules $\refrule{P-Rig}$ and $\refrule{P-Rig-Fail}$ handle non-cyclic
unification of $M(x)$ with $\dotmcontext{\Gamma};a\vdash o(\delta)$
for some $o\in\Oop na$, where $M\notin\dotmcontext{\Gamma}$. By
\Remref{cocone-pruning}, a unifier is given by a substitution $\sigma:\Gamma\rightarrow\Delta$
and a term $u$ such that 
\begin{equation}
o(\delta[\sigma])=\rename ux.\label{eq:unif-prig}
\end{equation}
Now, $u$ is either some $M(\arg y)$ or $o'(\vec{v})$. But in the
first case, $\rename ux=\rename{M(y)}x=M(\arg x\circ\arg y)$, contradicting
\Eqref{unif-prig}. Therefore, $u=o'(\delta')$ for some $o'\in\Oop nm$
and $\delta'$ is a substitution from $\alpha_{o'}$ to $\Delta$.
Then, $\rename ux=\rename{o'}x(\rename{\delta}{\ntharvecaction{o'}x{}})$.
It follows from \Eqref{unif-prig} that $o=\rename{o'}x$, and $\delta[\sigma]=\rename{\delta'}{\ntharvecaction{o'}x{}}$.

Note that there is at most one $o'$ such that $o=\rename{o'}x$,
by \Assuref{O-mono}. In this case, a unifier is equivalently given
by substitutions $\sigma:\Gamma\rightarrow\Delta$ and $\sigma':\alpha_{o'}\rightarrow\Delta$
such that $\delta[\sigma]=\rename{\sigma'}{\ntharvecaction{o'}x{}}$.
But, by \Remref{cocone-pruning}, this is precisely the data for a
unifier of $\delta$ and $x^{o'}$. This actually induces an isomorphism
between the two categories of unifiers, thus justifying the rules
$\refrule{P-Rig}$ and $\refrule{P-Rig-Fail}$. 

\subsection[Flex (rule P-Flex)]{Flex (rule $\protect\refrule{P-Flex}$)}

\label{subsec:pruning-metavar}

The rule $\refrule{P-Flex}$ handles unification of $M(x)$ with $N(y)$
where $M\neq N$ in a variable context $a$. More explicitly, this
is about computing the pushout of $(X:a)\xrightarrow{{\cal L}x}(X:m)\cong(M:m)\xhookrightarrow{in_{M}}\dotmcontext{\Gamma}$
and $(X:a)\xrightarrow{{\cal L}x}(X:n)\cong(N:n)$.

Thanks to the following lemma, it is actually enough to compute the
pushout of ${\cal L}\arg x$ and ${\cal L}\arg y$, taking $A=(X:a)$,
$B=(X:m)$, $C=(X:N)$, $Y=\dotmcontext{\Gamma}\backslash M$, so
that $B+Y\cong\dotmcontext{\Gamma}$.
\begin{lemma}

In any category,  if the square below left is a pushout, then so
is the square below right.

\vspace{-1.5em}
\[
\begin{array}{c}
\xymatrix{A\ar[r]^{f}\ar[d]_{g} & B\ar@{-->}[d]^{\sigma}\\
C\ar@{-->}[r]_{u} & Z
}
\end{array}\quad\begin{array}{c}
\xymatrix{A\ar[r]^{f}\ar[d]_{g} & B\ar[r]^{in_{1}} & B+Y\ar@{-->}[d]^{\sigma+Y}\\
C\ar@{-->}[r]_{u} & Z\ar@{-->}[r]_{in_{1}} & Z+Y
}
\end{array}.
\]
By \Assuref{L-finite-conncted}, the pushout of ${\cal L}\arg x$
and ${\cal L}\arg y$ is the image by ${\cal L}$ of the pullback
of $\arg x$ and $\arg y$ in ${\cal A}$, thus justifying the rule
$\refrule{P-Flex}$.
\end{lemma}

\section{Soundness of the unification phase}

\label{sec:coequalising-phase}

In this section, we assume a pattern-friendly GB-signature $S$ and
discuss soundness of the main rules of the two mutually recursive
functions $\AgdaFunction{unify}$ and $\AgdaFunction{unify-\ensuremath{\sigma}}$
listed in \Figref{unif-full-gen}, which compute coequalisers in $\Thbot S$. 

The failing rules $\refrule{U-Fail}$ and $\refrule{U-Id-Fail}$ are
justified by \Lemref{diag-bot}. Both rules $\refrule{Clash}$ and
$\refrule{U-Rig}$ handle unification of two rigid terms $o(\delta)$
and $o'(\delta')$. If $o\neq o'$, they do not have any unifier:
this is the rule $\refrule{Clash}$. If $o=o'$, then a substitution
is a unifier if and only if it unifies $\delta$ and $\delta'$, thus
justifying the $\refrule{U-Rig}$.

In the next subsections, we discuss the rule sequential rules $\refrule{U-Empty}$
and $\refrule{U-Split}$ (\Subsecref{u-sequential}), the rule $\refrule{No-Cycle}$
transitioning to the pruning phase (\Subsecref{no-cycle}), the rule
$\refrule{Same-MVar}$ unifying metavariable with itself (\subsecref{flex-flex-same-metavar}),
and the failing rule $\refrule{Cycle}$ for cyclic unification of
a metavariable with a term which includes it deeply (\Subsecref{flex-rig-cyclic}).

\subsection[Sequential unification (rules U-Empty and U-Split)]{Sequential unification (rules $\protect\refrule{U-Empty}$ and $\protect\refrule{U-Split}$)}

\label{subsec:u-sequential}The rule $\refrule{U-Empty}$ is a direct
application of the following general lemma.
\begin{lemma}
If $A$ is initial in a category, then any diagram of the shape $\xymatrix{A\coeqr{}{} & B\ar[r]^{1_{B}} & B}
$ is a coequaliser.
\end{lemma}
The rule $\refrule{U-Split}$ is a direct application of a stepwise
construction of coequalisers valid in any category, as noted by \cite[Theorem 9]{DBLP:books/daglib/0068768}:
if the first two diagrams below are coequalisers, then the last one
as well.

% https://q.uiver.app/?q=WzAsOCxbMCwxLCJBXzEiXSxbMSwxLCJcXEdhbW1hIl0sWzIsMSwiXFxEZWx0YV8xIl0sWzMsMSwiQV8yIl0sWzQsMCwiXFxHYW1tYSJdLFs1LDEsIlxcRGVsdGFfMSJdLFs0LDIsIlxcR2FtbWEiXSxbNiwxLCJcXERlbHRhXzIiXSxbMCwxLCJ0XzEiLDAseyJjdXJ2ZSI6LTF9XSxbMCwxLCJ1XzEiLDIseyJjdXJ2ZSI6MX1dLFsxLDIsIlxcc2lnbWFfMSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFszLDQsInRfMiJdLFs0LDUsIlxcc2lnbWFfMSJdLFszLDYsInVfMiIsMl0sWzYsNSwiXFxzaWdtYV8xIiwyXSxbNSw3LCJcXHNpZ21hXzIiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XV0=
$\begin{tikzcd}[row sep=tiny]
	&&&&[-20pt] \Gamma \\
	{\Gamma'_1} & \Gamma & {\Delta_1} & {\Gamma'_2} &&[-20pt] {\Delta_1} & {\Delta_2} \\
	&&&&[-10pt] \Gamma
	\arrow["{t_1}", curve={height=-6pt}, from=2-1, to=2-2]
	\arrow["{u_1}"', curve={height=6pt}, from=2-1, to=2-2]
	\arrow["{\sigma_1}", dashed, from=2-2, to=2-3]
	\arrow["{t_2}", from=2-4, to=1-5]
	\arrow["{\sigma_1}", from=1-5, to=2-6]
	\arrow["{u_2}"', from=2-4, to=3-5]
	\arrow["{\sigma_1}"', from=3-5, to=2-6]
	\arrow["{\sigma_2}", dashed, from=2-6, to=2-7]
\end{tikzcd}
$
\[
\xymatrix{\Gamma'_{1}+\Gamma'_{2}\coeqr{t_{1},t_{2}}{u_{1},u_{2}} & \Gamma\ar@{-->}[r]^{\sigma_{2}\circ\sigma_{1}} & \Delta_{2}}
\]


\subsection[Flex-Rig, no cycle (rule No-Cycle)]{Flex-Flex, no cycle (rule $\protect\refrule{No-Cycle}$)}

\label{subsec:no-cycle}The rule $\refrule{No-Cycle}$ transitions
from unification to pruning. While unification is a coequaliser construction,
in \Secref{pruning-phase}, we explained that pruning is a pushout
construction. The rule is justified by the following well-known connection
between those two notions, taking $B$ to be $\dotmcontext{\Gamma}\backslash M$
and $C$ to be the singleton context $M:m$, so that the coproduct
of those two contexts in $\Thbot S$ is their disjoint union $\dotmcontext{\Gamma}$.
\begin{lemma}
Consider a commuting square $\begin{array}{c}
\xymatrix{A\ar[r]^{u}\ar[d]_{v} & B\ar[d]^{f}\\
C\ar[r]_{g} & D
}
\end{array}$ in any category. If the coproduct $B+C$ of $B$ and $C$ exists,
then this is a pushout if and only if $B+C\xrightarrow{f,g}D$ is
the coequaliser of $in_{1}\circ u$ and $in_{2}\circ v$. 
\end{lemma}

\subsection[Flex-Flex, same metavariable (rule Same-MVar)]{Flex-Flex, same metavariable (rule $\protect\refrule{Same-MVar}$)}

\label{subsec:flex-flex-same-metavar}Here we detail unification of
$M(x)$ and $M(y)$, for $x,y\in\hom_{{\cal A}}(m,a)$. By \Remref{functor-L-intuition},
$M(\arg x)={\cal L}\arg x[in_{M}]$ and $M(\arg y)={\cal L}\arg y[in_{M}]$.
We exploit the following lemma with $u={\cal L}\arg x$ and $v={\cal L}\arg y$.
\begin{lemma}
In any category, 
\begin{full}
denoting morphism composition $g\circ f$ by $f[g]$ and coequalisers
as in \Notref{cat-coeq}, the following rule applies:
\[
\dfrac{B\vdash u=v\Rightarrow h\dashv C}{B+D\dashv u[in_{B}]=v[in_{B}]\Rightarrow h+1_{D}\dashv C+D}
\]
In other words,
\end{full}
 if the below left diagram is a coequaliser, then so is the below
right diagram. \[
\xymatrix@R=2pt{A\ar@<+.5ex>[r]^{u}\ar@<-.5ex>[r]_{v} & B\ar@{-->}[r]^{h} & C}\quad\begin{array}{c}\xymatrix@C=1.5em@R=2pt{ & B\ar[rd]^{in_{B}}\\A\ar[ru]^{u}\ar[rd]_{v} &  & B+D\ar@{-->}[r]^{h+1_{D}} & C+D\\ & B\ar[ru]_{in_{B}}}\end{array}
\]
\end{lemma}
It follows that it is enough to compute the coequaliser of ${\cal L}\arg x$
and ${\cal L}\arg y$. Furthermore, by \Assuref{L-finite-conncted},
it is the image by ${\cal L}$ of the equaliser of $\arg x$ and $\arg y$,
thus justifying the rule $\refrule{Same-MVar}$.

\subsection[Flex-rigid, cyclic (rule Cycle)]{Flex-rigid, cyclic (rule $\protect\refrule{Cycle}$)}

\label{subsec:flex-rig-cyclic}The rule $\refrule{Cycle}$ handles
unification of $M(\arg x)$ and a term $t$ such that $t$ is rigid
and $M$ occurs in $t$. In this section, we show that indeed there
is no successful unifier. More precisely, we prove \Corref{occurcheck-final}
below, stating that if there is a unifier of a term $t$ and a metavariable
application $M(x)$, then either $M$ occurs at top-level in $t$,
or it does not occur at all. The argument follows the basic intuition
that $\sigma_{M}=t[M\mapsto\sigma_{M}]$ is impossible if $M$ occurs
deeply in $u$ because the sizes of both hand sides can never match.
To make this statement precise, we need some recursive definitions
and properties of size.
\begin{definition}
\label{def:size-occur-check}The size $|t|\in\mathbb{N}$ of a proper
term $t$ is recursively defined by $|M(\arg x)|=0$, and $|o(\vec{t})|=1+|\vec{t}|$,
with $|\vec{t}|=\sum_{i}t_{i}$.
\end{definition}
%
We will also need to count the occurrences of a metavariables in a
term.
\begin{definition}
For any term $t$ we define $|t|_{M}$ recursively by $|M(\arg x)|_{M}=1$,
$|N(\arg x)|_{M}=0$ if $N\neq M$, and $|o(\vec{t})|_{M}=|\vec{t}|_{M}$
with the sum convention as above for $|\vec{t}|_{M}$.
\end{definition}
\begin{lemma}
\label{lem:sizeM-factor}For any term $\text{\ensuremath{\dotmcontext{\Gamma};a\vdash}}t$,
if $|t|_{M}=0$, then $\dotmcontext{\Gamma}\backslash M;a\vdash t$.
Moreover, for any $\dotmcontext{\Gamma}=(M_{1}:m_{1},\dots,M_{n}:m_{n})$,
well-formed term $t$ in context $\dotmcontext{\Gamma};a$, and successful
substitution $\sigma:\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Delta}$,
we have $|t[\sigma]|=|t|+\sum_{i}|t|_{M_{i}}\times|\sigma_{i}|$.
\end{lemma}
%
\begin{corollary}
\label{cor:size-consequences}For any term $t$ in context $\dotmcontext{\Gamma};a$
with $(M:m)\in\dotmcontext{\Gamma}$, successful substitution $\sigma:\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Delta}$,
morphism $x\in\hom_{{\cal A}}(m,a)$ and $u$ in context $\Delta;u$,
we have $|t[\sigma,M\mapsto u]|\geq|t|+|u|\times|t|_{M}$ and $|M(x)[u]|=|u|$.
\end{corollary}
%
\begin{corollary}
\label{cor:occurcheck-final}Let $t$ be a term in context $\dotmcontext{\Gamma};a$
with $(M:m)\in\dotmcontext{\Gamma}$ and $x\in\hom_{{\cal A}}(m,a)$
such that $(M\mapsto u,\sigma):\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Delta}$
unifies $t$ and $M(x)$. Then, either $t=M(y)$ for some $y\in\hom_{{\cal A}}(m,a)$,
or $\dotmcontext{\Gamma};a\vdash t$. 
\end{corollary}
\begin{proof}
Since $t[\sigma,M\mapsto u]=M(x)[u]$, we have $|t[\sigma,M\mapsto u]|=|M(x)[u]|$.
\Corref{size-consequences} implies $|u|\geq|t|+|u|\times|t|_{M}$.
Therefore, either $|t|_{M}=0$ and we conclude by \Lemref{sizeM-factor},
or $|t|_{M}>0$ and $|t|=0$, so that $t$ is $M(\arg y)$ for some
$y$.
\end{proof}

\section{Termination and completeness}

\label{sec:termination-completeness}

\subsection{Termination}

\label{subsec:termination}

 In this section, we sketch an explicit argument to justify termination
of our algorithm described in \Figref{unif-full-gen}. Indeed, it
involves three recursive calls in the pruning phase (cf. the rules
$\refrule{P-Rig}$ and $\refrule{P-Split}$), as well as in the main
unification phase (cf. the rules $\refrule{U-Rig}$ and $\refrule{U-Split}$).
In each phase, the second recursive call for splitting is not structurally
recursive, making Agda unable to check termination. However, we can
devise an adequate notion of input size so that for each recursive
call, the inputs are strictly smaller than the inputs of the calling
site. First, we define the size $|\dotmcontext{\Gamma}|$ of a proper
metacontext $\dotmcontext{\Gamma}$ as its length, while $|\bot|=0$
by definition.  We also recursively define the size\footnote{The difference with the notion of size introduced in \Defref{size-occur-check}
is that metavariable applications are now of size 1 instead of 0. } $||t||$ of a proper term $t$ by $||M(\arg x)||=1$ and $||o(\vec{t})||=1+||\vec{t}||$,
with $||\vec{t}||=\sum_{i}||t_{i}||$. Note that no term is of empty
size. 

Let us first quickly justify termination of the pruning phase. Consider
the above defined size of the input, which is a term $t$ for $\AgdaFunction{prune}$,
or a list of terms $\vec{t}$ for $\AgdaFunction{prune-\ensuremath{\sigma}}$.
It is straightforward to check that the sizes of the inputs of recursive
calls are strictly smaller thanks to the following lemmas.
\begin{lemma}
For any proper term $\dotmcontext{\Gamma};a\vdash t$ and successful
substitution $\sigma:\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Delta}$,
if $\sigma$ is a \emph{metavariable renaming}, i.e., $\sigma_{M}$
is a metavariable application for any $(M:m)\in\dotmcontext{\Gamma}$,
then $||t[\sigma]||=||t||$.
\end{lemma}
%
\begin{lemma}
If there is a finite derivation tree of $\dotmcontext{\Gamma}\prune{\vec{t}}x{\sigma}{\vec{w}}\dashv\dotmcontext{\Delta}$
 then $|\dotmcontext{\Gamma}|=|\dotmcontext{\Delta}|$ and $\sigma$
is a metavariable renaming.
\end{lemma}
\begin{personalquestion}
Can we define it truly recursively?
\end{personalquestion}
The size invariance in the above lemma is actually used in the termination
proof of the main unification phase, where we consider the size of
the input to be the pair $(|\Gamma|,||t||)$ for $\AgdaFunction{unify}$
or $(|\Gamma|,||\vec{t}||)$ for $\AgdaFunction{unify-\ensuremath{\sigma}}$,
given as input a term $t$ or a list of terms $\vec{t}$ in the metacontext
$\Gamma$. More precisely, it is used in the following lemma that
ensures size decreasing (with respect to the lexicographic order).

\begin{lemma}
If there is a finite derivation tree of $\dotmcontext{\Gamma}\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta$,
then $|\dotmcontext{\Gamma}|\geq|\Delta|$, and moreover if $|\dotmcontext{\Gamma}|=|\Delta|$
and $\Delta$ is proper, then $\sigma$ is a metavariable renaming. 
\end{lemma}

\subsection{Completeness}

\label{subsec:completeness}

In this section, we explain why soundness (\Secref{pruning-phase}
and \Secref{coequalising-phase}) and termination (\Subsecref{termination})
entail completeness. Intuitively, one may worry that the algorithm
fails in cases where it should not. In fact, we already checked in
the previous sections that failure only occurs when there is no unifier,
as expected. Indeed, failure is treated as a free ``terminal'' unifier,
as explained in \Subsecref{categorification}, by considering the
category $\Thbot S$ extending category $\Th S$ with an error metacontext
$\bot$. \Corref{completeness-algo} implies that since the algorithm
terminates and computes the coequaliser in $\Thbot S$, it always
finds the most general unifier in $\Th S$ if it exists, and otherwise
returns failure (i.e., the map to the terminal object $\bot$). 

\section{Related work}

\label{sec:related-work}

First-order unification has been explained from a lattice-theoretic
point of view by Plotkin~\citet{plotkinunification}, and later categorically
analysed in~\citet[Section 9.7]{DBLP:books/daglib/0068768,Goguen89whatis,10.5555/92134}
as coequalisers. However, there is little work on understanding pattern
unification algebraically, with the notable exception of \citet{vezzosi2014categorical},
working with normalised terms of simply-typed $\lambda$-calculus.
The present paper can be thought of as a generalisation of their
work.

Although our notion of signature has a broader scope since we are
not specifically focusing on syntax where variables can be substituted,
our work is closer in spirit to the presheaf approach~\citet{fiore:presheaf}
to binding signatures than to the nominal approach~\citet{PittsAM:newaas}
in that everything is explicitly scoped: terms come with their support,
metavariables always appear with their scope of allowed variables.

Nominal unification~\citet{10.1007/978-3-540-45220-1_41} is an alternative
to pattern unification where metavariables are not supplied with the
list of allowed variables. Instead, substitution can capture variables.
Nominal unification explicitly deals with $\alpha$-equivalence as
an external relation on the syntax, and as a consequence deals with
freshness problems in addition to unification problems. 

Cheney~\citet{cheney2005relating} shows that nominal unification
and pattern unification problems are inter-translatable. As he notes,
this result indirectly provides semantic foundations for pattern unification
based on the nominal approach. In this respect, the present work provides
a more direct semantic analysis of pattern unification, leading us
to the generic algorithm we present, parameterised by a general notion
of signature for the syntax.

Pattern unification has also been studied from the viewpoint of logical
frameworks~\citet{pientka2003tabled,DBLP:conf/icfp/NanevskiPP03,DBLP:journals/tocl/NanevskiPP08,DBLP:conf/tlca/AbelP11}
using contextual types to characterise metavariables. LF-style signatures
handle type dependency (which is future work for us), but there are
also GB-signatures which cannot be encoded with an LF signature. For
example, GB-signatures allow us to express pattern unification for
ordered lambda terms (\Subsecref{ordered-calculus}).

Our semantics for metavariables has been engineered so that it can
\emph{only} interpret metavariable instantiations in the pattern fragment,
and cannot interpret full metavariable instantiations, contrary to
prior semantics of metavariables (e.g., \citet{DBLP:journals/tocl/HuPS22}
or \citet{DBLP:conf/aplas/Hamana04}). This restriction gives our
model much stronger properties, enabling us to characterise each part
of the pattern unification algorithm in terms of universal properties.
This lets us extend Rydeheard and Burstall's proof to the pattern
case.

\begin{full}

\section{Conclusion}

We presented a generic unification algorithm for Miller's pattern
fragment with its associated categorical semantics, parameterised
by a new notion of signature for syntax with metavariables. In the
future, we plan to provide fully mechanised proof of correctness.
We also plan to see how this work applies to dependently-typed languages,
going beyond polymorphic syntax. Finally, we are interesting in further
extending the setting to cover unification modulo equations, or linear
syntax without restriction on the order the variables are used.

\end{full}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bib}

\newpage
\startappendix


\secappendix{Proofs of statements in Section~\ref{subsec:GB-sig}}

\label{app:proof-statements}

\subsection{Property~\ref{assu:main-properties}}

\label{app:proof-L-preserves}

We use the notations and definitions of \Subsecref{GB-sig}.

Let us first prove the first item.
\begin{proof}[Proof of Property~\ref{assu:O-mono}]

We show that given any $o\in\Oop nb$ and renaming $f:a\rightarrow b$,
there is at most one $o'\in\Oop na$ such that $o=\rename{o'}f$. 

Since $\Oby n$ preserves finite connected limits, it preserves monomorphisms
because a morphism $f:a\rightarrow b$ is monomorphic if and only
if the following square is a pullback (see \citet[Exercise III.4.4]{MacLane:cwm}).\[\begin{tikzcd} 	A & A \\ 	A & B 	\arrow["f", from=1-2, to=2-2] 	\arrow[equal, from=1-1, to=1-2] 	\arrow["f"', from=2-1, to=2-2] 	\arrow[Rightarrow, no head, from=1-1, to=2-1] \end{tikzcd}\]
\end{proof}
The rest of this section is devoted to the proof of Property~\ref{assu:L-finite-conncted}.

By right continuity of the homset bifunctor, any representable functor
is in $\C$ and thus the embedding $\C\rightarrow[\mathcal{A},\Set]$
factors the Yoneda embedding $\op{\mathcal{A}}\rightarrow[\mathcal{A},\Set]$.
\begin{lemma}
\label{lem:K-finite-connected}Let $\D$ denote the opposite category
of ${\cal A}$ and $K:\D\rightarrow\C$ the factorisation of $\C\rightarrow[{\cal A},\Set]$
by the Yoneda embedding. Then, $K:\D\rightarrow\C$ preserves finite
connected colimits.
\end{lemma}
\begin{proof}
This essentially follows from the fact functors in $\C$ preserves
finite connected limits. Let us detail the argument: let $y:\op{\mathcal{A}}\rightarrow[\mathcal{A},\Set]$
denote the Yoneda embedding and $J:\C\rightarrow[\mathcal{A},\Set]$
denote the canonical embedding, so that 
\begin{equation}
y=J\circ K.\label{eq:def-y-1}
\end{equation}
Now consider a finite connected limit $\lim F$ in $\mathcal{A}$.
Then, 
\begin{align*}
\C(K\lim F,X) & \cong[{\cal A},\Set](JK\lim F,JX)\tag{\ensuremath{J} is fully faithful}\\
 & \cong[\mathcal{A},\Set](y\lim F,JX)\tag{By Equation \prettyref{eq:def-y-1}}\\
 & \cong JX(\lim F)\tag{By the Yoneda Lemma.}\\
 & \cong\lim(JX\circ F)\tag{\ensuremath{X} preserves finite connected limits}\\
 & \cong\lim([\mathcal{A},\Set](yF-,JX)]\tag{By the Yoneda Lemma}\\
 & \cong\lim([\mathcal{A},\Set](JKF-,JX)]\tag{By Equation \prettyref{eq:def-y-1}}\\
 & \cong\lim\C(KF-,X)\tag{\ensuremath{J} is full and faithful}\\
 & \cong\C(\colim KF,X)\tag{By left continuity of the hom-set bifunctor}
\end{align*}
These isomorphisms are natural in $X$ and thus $K\lim F\cong\colim KF$.
\end{proof}

\begin{proof}
[Proof of \Assuref{L-finite-conncted}] Note that ${\cal L}$ factors
as 
\[
\D\xrightarrow{{\cal L}^{\bullet}}\Th S\hookrightarrow\Thbot S,
\]
where the right embedding preserves colimits by \Lemref{bot-creates},
so it is enough to show that ${\cal L}^{\bullet}$ preserves finite
connected colimits. Let $T_{|\C}$ be the monad $T$ restricted to
$\C$, following \Corref{-T-res}. Since $K:\D\rightarrow\C$ preserves
finite connected colimits (\Lemref{K-finite-connected}), composing
it with the left adjoint $\C\rightarrow\Kl{T_{|\C}}$ yields a functor
$\D\rightarrow\Kl{T_{|\C}}$ also preserving those colimits. Since
it factors as $\D\xrightarrow{{\cal L}^{\bullet}}\Th S\hookrightarrow\Kl{T_{|\C}}$,
where the right functor is full and faithful, ${\cal L}^{\bullet}$
also preserves finite connected colimits.
\end{proof}

\subsection{Lemma~\ref{lem:F-finitary}}

\label{app:F-finitary}$F$ is finitary because filtered colimits
commute with finite limits \citet[Theorem IX.2.1]{MacLane:cwm} and
colimits. The free monad construction is due to \citet{Reiterman}.

\subsection{Lemma~\ref{lem:res-F}}

\label{app:resF-direct}
\begin{notation}
Given a functor $F:I\rightarrow\B$, we denote the limit (resp. colimit)
of $F$ by $\int_{i:I}F(i)$ or $\lim F$ (resp. $\int^{i:I}F(i)$
or $\colim F$) and the canonical projection $\lim F\rightarrow Fi$
by $p_{i}$ for any object $i$ of $I$.
\end{notation}
This section is dedicated to the proof of the following lemma.
\begin{lemma}
\label{lem:F-restricts-simpl}Given a GB-signature $S=({\cal A},\indexedO,\ntharvecfunct)$
such that ${\cal A}$ has finite connected limits, $F_{S}$ restricts
as an endofunctor on the full subcategory $\C$ of $[{\cal A},\Set]$
consisting of functors preserving finite connected limits if and only
if each $\Oby n\in\C$, and $\alpha:\int J\rightarrow{\cal A}$ preserves
finite limits.
\end{lemma}
%
We first introduce a bunch of intermediate lemmas.
\begin{lemma}
\label{lem:coprod-filtered}If $\B$ is a small category with finite
connected limits, then a functor $G:\B\rightarrow\Set$ preserves
those limits if and only if $\int\B$ is a coproduct of filtered categories.
\end{lemma}
\begin{proof}
This is a direct application of \citet[Theorem 2.4 and Example 2.3.(iii)]{classificationaccessible}.
\end{proof}
\begin{corollary}
\label{cor:J-preserve}Assume ${\cal A}$ has finite connected limits.
Then $J:\mathbb{N}\times\mathcal{A}\rightarrow{\cal \Set}$ preserves
finite connected limits if and only if each $\Oby n:{\cal A\rightarrow\Set}$
does.
\end{corollary}
%
\begin{proof}
This follows from $\int J\cong\coprod_{n\in\mathbb{N}}\coprod_{j\in\{1,\dots,n\}}\int\Oby n$.
\end{proof}
\begin{lemma}
\label{lem:data-functor-elt}Let $F:\B\rightarrow\Set$ be a functor.
For any functor $G:I\rightarrow\int F$, denoting by $H$ the composite
functor $I\xrightarrow{G}\int F\rightarrow\B$, there exists a unique
$x\in\lim(F\circ H)$ such that $Gi=(Hi,p_{i}(x))$.
\end{lemma}
\begin{proof}
$\int F$ is isomorphic to the opposite of the comma category $y/F$,
where $y:\op{\B}\rightarrow[\B,\Set]$ is the Yoneda embedding. The
statement follows from the universal property of a comma category.
\end{proof}
\begin{lemma}
\label{lem:lim-elt}Let $F:\B\rightarrow\Set$ and $G:I\rightarrow\int F$
such that $F$ preserves the limit of $H:I\xrightarrow{G}\int F\xrightarrow{}\B$.
Then, there exists a unique $x\in F\lim H$ such that $Gi=(Hi,Fp_{i}(x))$
and moreover, $(\lim H,x)$ is the limit of $G$.
\end{lemma}

\begin{proof}
The unique existence of $x\in F\lim H$ such that $Gi=(Hi,Fp_{i}(x))$
follows from \Lemref{data-functor-elt} and the fact that $F$ preserves
$\lim H$. Let $\C$ denote the full subcategory of $[\B,\Set]$ of
functors preserving $\lim G$. Note that $\int F$ is isomorphic to
the opposite of the comma category $K/F$, where $K:\op{\B}\rightarrow\C$
is the Yoneda embedding, which preserves $\colim G$, by an argument
similar to the proof of \Lemref{K-finite-connected}. We conclude
from the fact that the forgetful functor from a comma category $L/R$
to the product of the categories creates colimits that $L$ preserve. 
\end{proof}
%
\begin{corollary}
\label{cor:preserves-elt}Let $I$ be a small category, $\B$ and
$\B'$ be categories with $I$-limits (i.e., limits of any diagram
over $I$). Let $F:\B\rightarrow\Set$ be a functor preserving those
colimits. Then, $\int F$ has $I$-limits, preserved by the projection
$\int F\rightarrow\B$. Moreover, a functor $G:\int F\rightarrow\B'$
preserves them if and only if for any $d:I\rightarrow\B$ and $x\in F\lim d$,
the canonical morphism $G(\lim d,x)\rightarrow\int_{i:I}G(d_{i},Fp_{i}(x))$
is an isomorphism.
\end{corollary}
\begin{proof}
By \Lemref{lim-elt}, a diagram $d':I\rightarrow\int F$ is equivalently
given by $d:I\rightarrow\B$ and $x\in F\lim d$, recovering $d'$
as $d'_{i}=(d_{i},Fp_{i}(x))$, and moreover $\lim d'=(\lim d,x)$. 
\end{proof}
\begin{corollary}
\label{cor:can-iso-app}Assuming that ${\cal A}$ has finite connected
limits and each $\Oby n$ preserves finite connected limits, the finite
limit preservation on $\alpha:\int J\rightarrow{\cal A}$ of \Lemref{F-restricts-simpl}
can be reformulated as follows: given a finite connected diagram $d:D\rightarrow{\cal A}$
and element $o\in\Oop n{\lim d}$, the following canonical morphism
is an isomorphism
\[
\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j
\]
for any $j\in\{1,\dots,n\}$.
\end{corollary}
\begin{proof}
This is a direct application of \Corref{preserves-elt} and \Corref{J-preserve}.
\end{proof}
%
\begin{lemma}
[Limits commute with dependent pairs]\label{lem:lim-commute-dependent-pairs}Given
functors $K:I\rightarrow\Set$ and $G:\int K\rightarrow\Set$, the
following canonical morphism is an isomorphism
\[
\int_{i:I}\coprod_{x\in Ki}G(i,x)\rightarrow\coprod_{\alpha\in\lim K}\int_{i:I}G(i,p_{i}(\alpha))
\]
\end{lemma}
\begin{proof}
It is straightforward to check that both sets share the same universal
property.
\end{proof}
%
\begin{proof}
[Proof of \Lemref{F-restricts-simpl}]Let $d:I\rightarrow{\cal A}$
be a finite connected diagram and $X$ be a functor preserving finite
connected limits. Then,

\begin{align*}
\int_{i:I}F(X)_{d_{i}} & =\int_{i:I}\coprod_{n}\coprod_{o\in\Oop n{d_{i}}}X_{\nthar o1}\times\dots\times X_{\nthar on}\\
 & \cong\coprod_{n}\int_{i:I}\coprod_{o\in\Oop n{d_{i}}}X_{\nthar o1}\times\dots\times X_{\nthar on}\tag{Coproducts commute with connected limits}\\
 & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}\int_{i:I}X_{\nthar{p_{i}(o)}1}\times\dots\times X_{\nthar{p_{i}(o)}n}\tag{By \prettyref{lem:lim-commute-dependent-pairs}}\\
 & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}\int_{i:I}X_{\nthar{p_{i}(o)}1}\times\dots\times\int_{i:I}X_{\nthar{p_{i}(o)}n}\tag{By commutation of limits}
\end{align*}
Thus, since $X$ preserves finite connected limits by assumption,
\begin{align}
\int_{i}F(X)_{d_{i}} & =\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\label{eq:F-restrict-1}
\end{align}

Now, let us prove the only if statement first. Assuming that $\alpha:\int J\rightarrow{\cal A}$
and each $\Oby n$ preserves finite connected limits. Then,

\begin{align*}
\int_{i}F(X)_{d_{i}} & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\tag{By Equation \prettyref{eq:F-restrict-1}}\\
 & \cong\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\int_{i:I}\nthar{\rename o{p_{i}}}1}\times\dots\times X_{\int_{i:I}\nthar{\rename o{p_{i}}}n}\tag{By assumption on \ensuremath{\Oby n}}\\
 & \cong\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\nthar o1}\times\dots\times X_{\nthar on}\tag{By Corollary \prettyref{cor:can-iso-app}}\\
 & =F(X)_{\lim d}
\end{align*}

Conversely, let us assume that $F$ restricts to an endofunctor on
$\C$. Then, $F(1)=\coprod_{n}\Oby n$ preserves finite connected
limits. By \Lemref{coprod-filtered}, each $\Oby n$ preserves finite
connected limits. By \Corref{can-iso-app}, it is enough to prove
that given a finite connected diagram $d:D\rightarrow{\cal A}$ and
element $o\in\Oop n{\lim d}$, the following canonical morphism is
an isomorphism
\[
\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j
\]

Now, we have
\begin{align*}
\int_{i:I}F(X)_{d_{i}} & \cong F(X)_{\lim d}\tag{By assumption}\\
 & =\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\nthar o1}\times\dots\times X_{\nthar on}
\end{align*}

On the other hand,
\begin{align*}
\int_{i:I}F(X)_{d_{i}} & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\tag{By Equation \prettyref{eq:F-restrict-1}}\\
 & =\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\int_{i:I}\nthar{\rename o{p_{i}}}1}\times\dots\times X_{\int_{i:I}\nthar{\rename o{p_{i}}}n}\tag{\ensuremath{\Oby n} preserves finite connected limits}
\end{align*}
It follows from those two chains of isomorphisms that each function
$X_{\nthar oj}\rightarrow X_{\int_{i:I}\nthar{\rename o{p_{i}}}j}$
is a bijection, or equivalently (by the Yoneda Lemma), that $\C(K\nthar oj,X)\rightarrow\C(K\int_{i:I}\nthar{\rename o{p_{i}}}j,X)$
is an isomorphism. Since the Yoneda embedding is fully faithful, $\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j$
is an isomorphism.
\end{proof}

\subsection{Lemma~\ref{lem:lims-coprod-pw}}

\label{app:lims-coprod-pw}

Cocompleteness follows from \citet[Remark 1.56]{Adamek}, since $\C$
is the category of models of a limit sketch, and is thus locally presentable,
by~\citet[Proposition 1.51]{Adamek}. 

For the claimed closure property, all we have to check is that limits,
coproducts, and filtered colimits of functors preserving finite connected
limits still preserve finite connected limits. The case of limits
is clear, since limits commute with limits. Coproducts and filtered
colimits also commute with finite connected limits \citet[Example 1.3.(vi)]{classificationaccessible}.

\subsection{Corollary~\ref{cor:-T-res}}

\label{app:T-res}The result follows from the construction of $T$
using colimits of initial chains, thanks to the closure properties
of $\C$. More specifically, $TX$ can be constructed as the colimit
of the chain $\emptyset\rightarrow H\emptyset\rightarrow HH\emptyset\rightarrow\dots$,
where $\emptyset$ denotes the constant functor mapping anything to
the empty set, and $HZ=FZ+X$.

\secappendix{Applications}

\label{app:applications}In this section, we present various examples
of pattern-friendly signatures. We start in \Subsecref{ex-arg-sets}
with a variant of pure $\lambda$-calculus where metavariable arguments
are sets rather than lists. Then, in \Subsecref{simply-typed-so},
we present simply-typed $\lambda$-calculus, as an example of syntax
specified by a multi-sorted binding signature. We then explain in
\Subsecref{normalised-lc} how we can handle $\beta$ and $\eta$
equations by working on the normalised syntax. Next, we introduce
an example of unification for ordered syntax in \subsecref{ordered-calculus},
and finally we present an example of polymorphic such as System F,
in \Subsecref{system-F}. \begin{full} , whose signature is implemented
in Agda (see the supplemental material). \end{full} 


\subsection{Metavariable arguments as sets}

\label{subsec:ex-arg-sets}If we think of the arguments of a metavariable
as specifying the available variables, then it makes sense to assemble
them in a set rather than in a list. This motivates considering the
category ${\cal A}=\mathbb{I}$ whose objects are natural numbers
and a morphism $n\rightarrow p$ is a subset of $\{1,\dots,p\}$ of
cardinal $n$. For instance, $\mathbb{I}$ can be taken as subcategory
of $\mathbb{F}_{m}$ consisting of strictly increasing injections,
or as the subcategory of the augmented simplex category consisting
of injective functions. Then, a metavariable takes as argument a set
of variables, rather than a list of distinct variables. In this approach,
unifying two metavariables (see the rules $\refrule{U-Flex}$ and
$\refrule{P-Flex}$) amount to computing a set intersection.

\begin{full}

\subsection{Arities as sets}

In this example, we describe pure $\lambda$-calculus extended with
metavariables whose arities are sets of free variables. They do not
take any explicit argument and they cannot be applied to bound variables. 

We adopt a locally nameless approach, with two kinds of variables:
the named ones, chosen in an infinite set ${\cal V}$ of names (e.g.,
$\mathbb{N}$), and the unnamed ones, as before, which will be used
for binding. We thus choose $\mathcal{A}$ to be $\mathbb{S}\times\mathbb{F}_{m}$
where $\mathbb{S}$ is the category of finite subsets of $\mathcal{V}$
and inclusions (not injections!) between them. Pure $\lambda$-calculus
can be specified by an endofunctor $F$ defined by $F(X)_{A,n}=n+A+X_{A,n+1}+X_{A,n}\times X_{A,n}$.

A metavariable arity, as an object of ${\cal A}$, consists of two
components: a finite set of named variables, and a number of arguments
among unnamed variables. Let us define pure arities as those whose
second component is $0$. A metavariable is said pure if its arity
is, and a metacontext is said pure if each metavariable is. 

The pure metavariables are the ones mentioned at the beginning of
this section. Unifying a pure metavariable with itself, as in the
rule $\refrule{U-Flex}$, is a no-op, while unifying a pure metavariable
with another one (rule $\refrule{P-Flex}$) produces a new pure metavariable
whose arity is the intersection of the input metavariable arities.
Exploiting this observation, an easy induction shows that the most
general unifier targets a pure metacontext.
\begin{lemma}
Assume an endofunctor for syntax as in \Subsecref{endo-syntax}. If
$\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$ or $\Gamma\prune t{\coprod_{i}{\cal L}f_{i}}{\sigma}u\dashv\Delta$,
and $\Delta\neq\bot$, then $\Delta$ is pure whenever $\Gamma$ is.
\end{lemma}

\end{full}
\begin{center}
\par\end{center}

\subsection{Simply-typed $\lambda$-calculus}

\label{subsec:simply-typed-so} In this section, we present the example
of simply-typed $\lambda$-calculus. Our treatment generalises to
any multi-sorted binding signature~\citet{FioreHur}. 

Let $T$ denote the set of simple types generated by a set of atomic
types and a binary arrow type construction $-\Rightarrow-$. Let us
now describe the category ${\cal A}$ of arities, or variable contexts,
and renamings between them. An arity $\vec{\sigma}\arSep\tau$ consists
of a list of input types $\vec{\sigma}$ and an output type $\tau$.
A term $t$ in $\vec{\sigma}\arSep\tau$ considered as a variable
context is intuitively a well-typed term $t$ of type $\tau$ potentially
using variables whose types are specified by $\vec{\sigma}$. A valid
choice of arguments for a metavariable $M:(\vec{\sigma}\arSep\tau)$
in variable context $\vec{\sigma}'\arSep\tau'$ first requires $\tau=\tau'$,
and consists of an injective renaming $\vec{r}$ between $\vec{\sigma}=(\sigma_{1},\dots,\sigma_{m})$
and $\vec{\sigma}'=(\sigma'_{1},\dots,\sigma'_{n})$, that is, a choice
of distinct positions $(r_{1},\dots,r_{m})$ in $\{1,\dots,n\}$ such
that $\vec{\sigma}=\sigma'_{\vec{r}}$.

This discussion determines the category of arities as ${\cal A}=\mathbb{F}_{m}[T]\times T$
, where $\mathbb{F}_{m}[T]$ is the category of finite lists of elements
of $T$ and injective renamings between them. \Tabref{all-syntax}
summarises the definition of the endofunctor $F$ on $[{\cal A},\Set]$
specifying the syntax, where $|\vec{\sigma}|_{\tau}$ denotes the
number (as a cardinal set) of occurrences of $\tau$ in $\vec{\sigma}$.

The induced signature is pattern-friendly and so the generic pattern
unification algorithm applies. Equalisers and pullbacks are computed
following the same pattern as in pure $\lambda$-calculus. For example,
to unify $M(\vec{x})$ and $M(\vec{y})$, we first compute the vector
$\vec{z}$ of common positions between $\vec{x}$ and $\vec{y}$,
thus satisfying $x_{\vec{z}}=y_{\vec{z}}$. Then, the most general
unifier maps $M:(\vec{\sigma}\arSep\tau)$ to the term $P(\vec{z})$,
where the arity $\vec{\sigma}'\arSep\tau'$ of the fresh metavariable
$P$ is the only possible choice such that $P(\vec{z})$ is a valid
term in the variable context $\vec{\sigma}\arSep\tau$, that is, $\tau'=\tau$
and $\vec{\sigma}'=\sigma_{\vec{z}}$.

\begin{table*}
\caption{Examples of (pattern-friendly) GB-signatures (\Defref{GB-signature})}
\label{tab:all-syntax}
\begin{centering}
\begin{tabular}{c}
Simply-typed $\lambda$-calculus (\Subsecref{simply-typed-so})\tabularnewline
\end{tabular}
\par\end{centering}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
Typing rule & $O(\vec{\sigma}\arSep\tau)=\mydots+$ & $\alpha_{o}=(\mydots)$\tabularnewline
\hline 
\hline 
$\dfrac{x:\tau\in\Gamma}{\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$ & $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\}$ & $()$\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\vdash t:\tau'\Rightarrow\tau\quad\Gamma\vdash u:\tau'}{\Gamma\vdash t\ u:\tau}$ & $\{a_{\tau'}|\tau'\in T\}$ & $\left(\begin{array}{l}
\vec{\sigma}\arSep(\tau'\Rightarrow\ensuremath{\tau})\\
\vec{\sigma}\arSep\tau'
\end{array}\right)$\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$ & $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$ & $(\vec{\sigma},\tau_{1}\arSep\tau_{2})$\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\vspace{1em}
\begin{centering}
\begin{tabular}{c}
Simply-typed $\lambda$-calculus modulo $\beta\eta$ (\Subsecref{normalised-lc})\tabularnewline
\end{tabular}
\par\end{centering}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
Typing rule & $O(\vec{\sigma}\arSep\tau)=\mydots+$ & $\alpha_{o}=(\mydots)$\tabularnewline
\hline 
\hline 
$\dfrac{x:\vec{\tau}'\Rightarrow\tau\in\Gamma\quad\tau\text{ is a base type}\quad\Gamma\vdash\vec{t}:\vec{\tau}'}{\Gamma\vdash x\vec{t}:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$ & $\{a_{i,\tau'_{1},\dots,\tau'_{n}}|i\in|\vec{\sigma}|_{\vec{\tau}'\Rightarrow\tau}\text{ and \ensuremath{\tau} is a base type}\}$ & $\left(\begin{array}{c}
\vec{\sigma}\arSep\tau'_{1}\\
\dots\\
\vec{\sigma}\arSep\tau'_{n}
\end{array}\right)$\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$ & $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$ & $(\vec{\sigma},\tau_{1}\arSep\tau_{2})$\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\vspace{1em}
\begin{centering}
\begin{tabular}{c}
Ordered $\lambda$-calculus (\Subsecref{ordered-calculus})\tabularnewline
\end{tabular}
\par\end{centering}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
Typing rule & $O(\vec{\sigma}\Fsep\vec{\omega}\arSep\tau)=\mydots+$ & $\alpha_{o}=(\mydots)$\tabularnewline
\hline 
\hline 
$\dfrac{x:\tau\in\Gamma}{\Gamma\Fsep\cdot\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$ & $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\text{\text{ and }\ensuremath{\vec{\omega}=()}}\}$ & $()$\tabularnewline
\hline 
$\dfrac{}{\Gamma\Fsep x:\tau\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$ & $\{v^{>}|\text{\ensuremath{\vec{\omega}=()}}\}$ & $()$\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega\vdash t:\tau'\Rightarrow\tau\quad\Gamma\Fsep\cdot\vdash u:\tau'}{\Gamma\Fsep\Omega\vdash t\ u:\tau}$ & $\{a_{\tau'}|\tau'\in T\}$ & $\left(\begin{array}{l}
\vec{\sigma}\Fsep\vec{\omega}\arSep(\tau'\Rightarrow\ensuremath{\tau})\\
\vec{\sigma}\Fsep()\arSep\tau'
\end{array}\right)$\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega_{1}\vdash t:\tau'\twoheadrightarrow\tau\quad\Gamma\Fsep\Omega_{2}\vdash u:\tau'}{\Gamma\Fsep\Omega_{1},\Omega_{2}\vdash t^{>}\ u:\tau}$ & $\{a_{\tau'}^{\vec{\omega}_{1},\vec{\omega}_{2}}|\tau'\in T\text{ and }\text{\ensuremath{\vec{\omega}=\vec{\omega}_{1},\vec{\omega}_{2}}}\}$ & $\left(\begin{array}{l}
\vec{\sigma}\Fsep\vec{\omega}_{1}\arSep(\tau'\Rightarrow\ensuremath{\tau})\\
\vec{\sigma}\Fsep\vec{\omega}_{2}\arSep\tau'
\end{array}\right)$\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\Fsep\Omega\vdash t:\tau_{2}}{\Gamma\Fsep\Omega\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$ & $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$ & $(\vec{\sigma},\tau_{1}\Fsep\vec{\omega}\arSep\tau_{2})$\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\Fsep\Omega\vdash\lambda^{>}x.t:\tau_{1}\twoheadrightarrow\tau_{2}}$ & $\{l_{\tau_{1},\tau_{2}}^{>}|\tau=(\tau_{1}\twoheadrightarrow\tau_{2})\}$ & $(\vec{\sigma},\tau_{1}\Fsep\vec{\omega}\arSep\tau_{2})$\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\vspace{1em}
\begin{centering}
\begin{tabular}{c}
System F (\Subsecref{system-F})\tabularnewline
\end{tabular}
\par\end{centering}
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
Typing rule & $O(p|\vec{\sigma}\vdash\tau)=\mydots+$ & $\alpha_{o}=(\mydots)$\tabularnewline
\hline 
\hline 
$\dfrac{x:\tau\in\Gamma}{n\Fsep\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$ & $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\}$ & ()\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n\Fsep\Gamma\vdash t:\tau'\Rightarrow\tau\quad n\Fsep\Gamma\vdash u:\tau'}{n\Fsep\Gamma\vdash t\ u:\tau}$ & $\{a_{\tau'}|\tau'\in S_{n}\}$ & $\left(\begin{array}{l}
n\Fsep\vec{\sigma}\arSep\tau'\Rightarrow\ensuremath{\tau}\\
n\Fsep\vec{\sigma}\arSep\tau'
\end{array}\right)$\tabularnewline
\hline 
$\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n\Fsep\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{n\Fsep\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$ & $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$ & $(n\Fsep\vec{\sigma},\tau_{1}\arSep\tau_{2})$\tabularnewline
\hline 
$\dfrac{n\Fsep\Gamma\vdash t:\forall\tau_{1}\quad\tau_{2}\in S_{n}}{n\Fsep\Gamma\vdash t\cdot\tau_{2}:\tau_{1}[\tau_{2}]}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$ & $\{A_{\tau_{1},\tau_{2}}|\tau=\tau_{1}[\tau_{2}]\}$ & $(n\Fsep\vec{\sigma}\arSep\forall\tau_{1})$\tabularnewline
\hline 
$\dfrac{n+1\Fsep wk(\Gamma)\vdash t:\tau}{n\Fsep\Gamma\vdash\Lambda t:\forall\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$ & $\{\Lambda_{\tau'}|\tau=\forall\tau'\}$ & $(n+1\Fsep wk(\vec{\sigma})\arSep\tau')$\tabularnewline
\hline 
\end{tabular}
\par\end{centering}

\end{table*}


\subsection{Simply-typed $\lambda$-calculus modulo $\beta$$\eta$}

\label{subsec:normalised-lc}

Higher-order pattern unification was originally introduced for closed
simply-typed lambda-terms with metavariables applied to distinct variables.
Lambda-terms are considered in $\beta$-short $\eta$-long normal
forms. Although we do not explicitly cover equations, the syntax of
those normal formas is equation free and can be specified by a GB-signature:
we take the same category of arities as in \Subsecref{simply-typed-so},
and we consider the operations as specified in \Tabref{all-syntax}.

\subsection{Ordered $\lambda$-calculus}

\label{subsec:ordered-calculus}

Our setting handles linear ordered $\lambda$-calculus, consisting
of $\lambda$-terms using all the variables in context. In this context,
a metavariable $M$ of arity $m\in\mathbb{N}$ can only be used in
the variable context $m$, and there is no freedom in choosing the
arguments of a metavariable application, since all the variables must
be used, in order. Thus, there is no need to even mention those arguments
in the syntax. It is thus not surprising that ordered $\lambda$-calculus
is already handled by first-order unification, where metavariables
do not take any argument, by considering ordered $\lambda$-calculus
as a multi-sorted Lawvere theory where the sorts are the variable
contexts, and the syntax is generated by operations $L_{n}\times L_{m}\rightarrow L_{n+m}$
and abstractions $L_{n+1}\rightarrow L_{n}$. 

Our generalisation can handle calculi combining ordered and unrestricted
variables, such as the calculus underlying ordered linear logic described
in \citet{Polakow00lfm}. In this section we detail this specific
example. Note that this does not fit into Schack-Nielsen and Schürman's
pattern unification algorithm~\citet{DBLP:journals/corr/abs-1009-2795}
for linear types where exchange is allowed (the order of their variables
does not matter).

The set $T$ of types is generated by a set of atomic types and two
binary arrow type constructions $\Rightarrow$ and $\twoheadrightarrow$.
The syntax extends pure $\lambda$-calculus with a distinct application
$t^{>}\ u$ and abstraction $\lambda^{>}u$. Variables contexts are
of the shape $\vec{\sigma}\Fsep\vec{\omega}\arSep\tau$, where $\vec{\sigma}$,
$\vec{\omega}$, and $\tau$ are taken in $T$. The idea is that a
term in such a context has type $\tau$ and must use all the variables
of $\vec{\omega}$ in order, but is free to use any of the variables
in $\vec{\sigma}$. Assuming a metavariable $M$ of arity $\vec{\sigma}\Fsep\vec{\omega}\arSep\tau$,
the above discussion about ordered $\lambda$-calculus justifies that
there is no need to specify the arguments for $\vec{\omega}$ when
applying $M$. Thus, a metavariable application $M(\vec{x})$ in the
variable context $\vec{\sigma}'\Fsep\vec{\omega}'\arSep\tau'$ is
well-formed if $\tau=\tau'$ and $\vec{x}$ is an injective renaming
from $\vec{\sigma}$ to $\vec{\sigma}'$. Therefore, we take ${\cal A}=\mathbb{F}_{m}[T]\times T^{*}\times T$
for the category of arities, where $T^{*}$ denote the discrete category
whose objects are lists of elements of $T$. The remaining components
of the GB-signature are specified in \Tabref{all-syntax}: we alternate
typing rules for the unrestricted and the ordered fragments (variables,
application, abstraction).

Pullbacks and equalisers are computed essentially as in \Subsecref{simply-typed-so}.
For example, the most general unifier of $M(\vec{x})$ and $M(\vec{y})$
maps $M$ to $P(\vec{z})$ where $\vec{z}$ is the vector of common
positions of $\vec{x}$ and $\vec{y}$, and $P$ is a fresh metavariable
of arity $\sigma_{\vec{z}}\Fsep\vec{\omega}\arSep\tau$.


\subsection{Intrinsic polymorphic syntax}

\label{subsec:system-F}

We present intrinsic System F, in the spirit of~\citet{HamanaPoly}.
\begin{full}The Agda implementation of the following friendly GB-signature
can be found in the supplemental material.\end{full}

The syntax of types in type variable context $n$ is inductively generated
as follows, following the De Bruijn level convention.
\[
\dfrac{1\leq i\leq n}{n\vdash\var i}\qquad\dfrac{n\vdash t\quad n\vdash u}{n\vdash t\Rightarrow u}\qquad\dfrac{n+1\vdash t}{n\vdash\forall t}
\]

Let $S:\mathbb{F}_{m}\rightarrow\Set$ be the functor mapping $n$
to the set $S_{n}$ of types for system $F$ taking free type variables
in $\{1,\dots,n\}$. In other words, $S_{n}=\{\tau|n\vdash\tau\}$.
Intuitively, a metavariable arity $n\Fsep\vec{\sigma}\arSep\tau$
specifies the number $n$ of free type variables, the list of input
types $\vec{\sigma}$, and the output type $\tau$, all living in
$S_{n}$. This provides the underlying set of objects of the category
${\cal A}$ of arities. A term $t$ in $n\Fsep\vec{\sigma}\arSep\tau$
considered as a variable context is intuitively a well-typed term
of type $\tau$ potentially involving ground variables of type $\vec{\sigma}$
and type variables in $\{1,\dots,n\}$.

A metavariable $M:(n\Fsep\sigma_{1},\dots,\sigma_{p}\arSep\tau)$
in the variable context $n'\Fsep\vec{\sigma}'\arSep\tau'$ must be
supplied with
\begin{itemize}
\item a choice $(\eta_{1},\dots,\eta_{n})$ of $n$ distinct type variables
among the set $\{1,\dots n'\}$, such that $\tau[\vec{\eta}]=\tau'$,
and 
\item an injective renaming $\vec{\sigma}[\vec{\eta}]\rightarrow\vec{\sigma}'$,
i.e., a list of distinct positions $r_{1},\dots,r_{p}$ such that
$\vec{\sigma}[\vec{\eta}]=\sigma'_{\vec{r}}$.
\end{itemize}
This defines the data for a morphism in ${\cal A}$ between $(n\Fsep\vec{\sigma}\arSep\tau)$
and $(n'\Fsep\vec{\sigma}'\arSep\tau')$. The intrinsic syntax of
system $F$ can then be specified as in \Tabref{all-syntax}. The
induced GB-signature is pattern-friendly. For example, morphisms in
${\cal A}$ are easily seen to be monomorphic; we detail in \Appref{A-finite-F}
the proof \shortfull{that ${\cal A}$ has finite connected limits.}{
of the following statement.
\begin{lemma}
\label{lem:A-finite-connected}${\cal A}$ has finite connected limits.
\end{lemma}
} Pullbacks and equalisers in ${\cal A}$ are essentially computed
as in \Subsecref{simply-typed-so}, by computing the vector of common
(value) positions. For example, given a metavariable $M$ of arity
$m\Fsep\vec{\sigma}\arSep\tau$, to unify $M(\vec{w}\Fsep\vec{x})$
with $M(\vec{y}\Fsep\vec{z})$, we compute the vector of common positions
$\vec{p}$ between $\vec{w}$ and $\vec{y}$, and the vector of common
positions $\vec{q}$ between $\vec{x}$ and $\vec{z}$. Then, the
most general unifier maps $M$ to the term $P(\vec{p}\Fsep\vec{q})$,
where $P$ is a fresh metavariable. Its arity $m'\Fsep\vec{\sigma}'\arSep\tau'$
is the only possible one for $P(\vec{p}|\vec{q})$ to be well-formed
in the variable context $m\Fsep\vec{\sigma}\arSep\tau$, that is,
$m'$ is the size of $\vec{p}$, while $\tau'=\tau[p_{i}\mapsto i]$
and $\vec{\sigma}'=\text{\ensuremath{\sigma_{\vec{q}}}}[p_{i}\mapsto i]$.

\secappendix{Proof that ${\cal A}$ has finite connected limits (Section~\ref{subsec:system-F}
on system F)}

\label{app:A-finite-F}In this section, we show that the category
${\cal A}$ of arities for System F (\Subsecref{system-F}) has finite
connected limits. First, note that ${\cal A}$ is the op-lax colimit
of the functor from $\mathbb{F}_{m}$ to the category of small categories
mapping $n$ to $\mathbb{F}_{m}[S_{n}]\times S_{n}$. Let us introduce
the category ${\cal A}'$ whose definition follows that of ${\cal A}$,
but without the output types: objects are pairs of a natural number
$n$ and an element of $S_{n}$. Formally, this is the op-lax colimit
of $n\mapsto\mathbb{F}_{m}[S_{n}]$.
\begin{lemma}
\label{lem:A'-lim}${\cal A}'$ has finite connected limits, and the
projection functor ${\cal A}'\rightarrow\mathbb{F}_{m}$ preserves
them.
\end{lemma}
\begin{proof}
The crucial point is that ${\cal A}'$ is not only op-fibred over
$\mathbb{F}_{m}$ by construction, it is also fibred over $\mathbb{F}_{m}$.
Intuitively, if $\vec{\sigma}\in\mathbb{F}_{m}[S_{n}]$ and $f:n'\rightarrow n$
is a morphism in $\mathbb{F}_{m}$, then $f_{!}\vec{\sigma}\in\mathbb{F}_{m}[S_{n'}]$
is essentially $\vec{\sigma}$ restricted to elements of $S_{n}$
that are in the image of $S_{f}$.  We can now apply \citet[Corollary 4.3]{grayfib},
since each $\mathbb{F}_{m}[S_{n}]$ has finite connected limits.
\end{proof}
We are now ready to prove that ${\cal A}$ has finite connected limits.
\begin{lemma}
${\cal A}$ has finite connected limits.
\end{lemma}
\begin{proof}
Since $S:\mathbb{F}_{m}\rightarrow\Set$ preserves finite connected
limits, $\int S$ has finite connected limits and the projection functor
to $\mathbb{F}_{m}$ preserves them by \Corref{preserves-elt}.

Now, the 2-category of small categories with finite connected limits
and functors preserving those between them is the category of algebras
for a 2-monad on the category of small categories \citet{BLACKWELL19891}.
Thus, it includes the weak pullback of ${\cal A}'\rightarrow\mathbb{F}_{m}\leftarrow\int S$.
But since $\int S\rightarrow\mathbb{F}_{m}$ is a fibration, and thus
an isofibration, by \citet{JoyalStreetPullbacks} this weak pullback
can be computed as a pullback, which is ${\cal A}$.
\end{proof}

