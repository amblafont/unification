We thank the referees for their useful comments and suggestions.

OVERVIEW
==================

Review A and C ask about the motivation of our work.
As noted by Review B, pattern unification is used in the implementation 
of various PLs. As a concrete example, consider Dunfield-Krishnaswami's type inference algorithm ("Sound and Complete Bidirectional Typechecking for Higher-Rank Polymorphism with Existentials and Indexed Types", 2019).
It only involves first-order unification, but simply adding a monomorphic type with a binder (for example, a recursive type 𝜇𝑎.𝐴[𝑎]) would require pattern unification. 

In order to avoid reproving everything for each new type system, pattern unification needs to be formulated generically so that it can be used in a variety of contexts without modification. This is our original motivation for this work. To the best of our knowledge, we are the first to give a general definition of pattern unification that works for a wide class of languages, in the vein of Rydeheard-Burstall's first-order analysis.

Review A and C note that Abel-Vezzosi already studied pattern unification using  a categorical approach; however they focused on the single case of normalised simply-typed lambda calculus, and as noted by Review C, our generalisation is not trivial. As a matter of fact, our treatment of lambda-calculus differs. In the revised version, we would make more explicit "how and why this difference".

Review C also mentions the work of Schack-Nielsen and Schurmann that devises
substructural pattern unification using syntactic method [LFMTP 2010]. As mentioned in Section 7.4, we cover a more restricted variant, but again, they focus on a single case, while we provide a general setting.

BETA/ETA EQUALITIES IN SYSTEM F 
====================================

Reviews A and C ask about the treatment of beta or eta equalities in the System F example. In section 7.3  (simply-typed lambda-calculus modulo beta and eta), we explain how to deal with equations in the syntax, by working on normal forms.
The System F example is meant to address an orthogonal complexity related to the type system. In that case, the category of arities is not a mere product category (as suggested by Review A), but a "dependent pair" (formally, an oplax colimit) because the set of possible types for the term variables depends on the available type variables.

We do not consider terms up to beta or eta equalities (this will be more explicit in a revised version). We thank Review C for raising the issue about eta-equality; we are not sure if this is a significant obstacle, since instantiation of metavariables in pattern unification does not involve full substitution, but only (injective) renaming. A preliminary investigation suggests that it may be possible for us to handle the syntax of eta-short beta-long normal forms, exploiting the presentation of System F as a pure type system.
This syntax is generated by the following two rules,  where i denotes a type variable.

Γ,𝑦₁:𝑢₁,…⊢𝑥 : i
__________________________
Γ⊢λy₁….𝑥 : ∏ (y₁ : u₁)….i


Γ,𝑦₁:𝑢₁,… ⊢ 𝑥 : ∏(a₁ : v₁).τ₁
Γ,𝑦₁:𝑢₁,… ⊢ t₁ : v₁     τ₁[a₁ ↦ t₁] = ∏(a₂ : v₂).τ₂
Γ,𝑦₁:𝑢₁,… ⊢ t₂ : v₂     τ₂[a₂ ↦ t₂] = ∏(a₃ : v₃).τ₃
…                        τₙ[aₙ ↦ tₙ] = i
__________________________
Γ ⊢ λy₁….𝑥t₁… : ∏ (y₁ : u₁)….i

RELATED WORK
==================

If accepted, we will include the following related work mentioned by Review B.

Pottier & Pouillard
-------------------
Pottier & Poulliard (ICFP 2010/2011/JFP 2012) provides an agda library to work with syntax with binders. Unlike us, they do not provide a general scheme for syntax (the user typically defines it using Agda's inductive types), nor do they focus on unification. Their library could be used to implement a unification algorithm for a specific syntax. It is not clear if it is possible to reuse their library in our Agda formalisation since the binding structure is not explicit in our signatures.

Gundry
--------------------
In chapter 4, Gundry's thesis presents a pattern unification unification for a dependent type theory, as a component of his type inference algorithm. It falls outside the scope of our setting because of type dependency, but also because it actually implements "dynamic pattern unification", which addresses unification problems that do not necessarily fit into the pattern fragment at first.

Mixed prefix unification (Miller 1992)
--------------------
Miller showed that mixed prefix unification problems can be translated into higher-order pattern unification problems. In that respect, our work equally handles mixed prefix unification.

DETAILED ANSWERS TO REVIEW B
==================

> I also wondered about whether mixed-prefix unification (Miller 1992) would be 
> definable as an instance of this approach (whehter for first or higher order 
> patterns). 

Our setting covers mixed-prefix unification in the higher-order pattern fragment.
  
> can it be explained what corresponds to Lawvere theories here?

The Lawvere theory of a GB-signature is the opposite category of the category of metacontexts and metasubstitutions. One can think of a Lawvere theory as a syntax with substitution, where unification corresponds to computing equalisers of parallel morphisms.

> 41: The rule for FO does not make much sense to me.  In first order terms, 
> metavariables do not take arguments fo m should alkways be zero.

What we mean here is that first-order unification is enough to solve unification problems with the FO rule for metavariable introduction. For example, we explain in the paragraph below how pure lambda-calculus can be specified as a multisorted first-order syntax, where the sorts are the natural numbers. First-order unification readily applies without any further restriction on the sorts of metavariables, hence the absence of restriction in the FO rule. We agree that this might be confusing and propose to clarify this point in the revised version, if accepted.

As a multisorted first-order syntax, pure lambda-calculus is generated by the following operations, for each sort n:
- n constants of that sort (the variables);
- a binary operation n × n → n (application);
- a unary operation n + 1 → n (lambda-abstraction). 


> 560: It might be helpful to illistrate example 2.5 with Agda code showing how > the binding signature specification in figure 6 can be instantiated with 

Here are the main definitions of the Agda code for Example 2.5, which we propose to include and explain in a revised version. 

data O n : Set where
   Var : Fin n → O n
   App : O n
   Lam : O n

α : {n : ℕ} → O n → List ℕ
α (Var x) = []
α {n} App = n ∷ n ∷ []
α {n} Lam = 1 + n ∷ []

_｛_｝ : ∀ {a b : ℕ} → O a → hom a b → O b
Var x ｛ s ｝ = Var (Vec.lookup s x)
App ｛ s ｝ = App
Lam ｛ s ｝ = Lam

_^_ : {a b : ℕ} (x : hom a b) (o : O a) →
      Pointwise hom (α o) (α (o ｛ x ｝))
x ^ Var y = []
x ^ App = x ∷ x ∷ []
x ^ Lam = (x ↑) ∷ []

> l744 Is $J$ in $\int J \to \mathcal{A}$ meant to be $\mathcal{O}$? 

Yes, thanks for pointing out the typo.

> In unifying $M(\vec{x}$ and $M(\vec{y})$ in a typed setting, do we need to check the matching xs and ys have the same types?

Our framework handles typed settings in such a way that knowing that $M(\vec{x}$ and $M(\vec{y})$ are well-formed in the same metacontext and scope is enough to conclude that the types of xs and ys are the same. This fact may be more or less implicit in the typed examples (e.g., simply-typed lambda-calculus, section 7.2); we propose to make it more explicit in the revised version.



