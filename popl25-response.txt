We thank the referees for their useful comments and suggestions.

OVERVIEW
==================

Review A and C ask about the motivation of our work.
As noted by Review B, pattern unification is used in the implementation 
of various PLs. In particular, this is useful in type inference 
algorithms for something as simple as a type system with monomorphic types with a binder (e.g., a recursive type 𝜇𝑎.𝐴[𝑎]). In order to avoid reproving everything for each new type system, pattern unification needs to be formulated generically so that it can be used in a variety of contexts without modification. This is our original motivation for this work. To the best of our knowledge, we are the first to give a general definition of pattern unification that works for a wide class of languages, in the vein of Rydeheard-Burstall's first-order analysis.

Review A and C note that Abel-Vezzosi already studied pattern unification using  a categorical approach; however they focused on the single case of normalised simply-typed lambda calculus, and as noted by Review C, our generalisation is not trivial (our treatment of lambda-calculus differs). 
Review C also mentions the work of Schack-Nielsen and Schurmann that devises
substructural pattern unification using syntactic method (see, for example,  [LFMTP 2010]), but again, they focus on a single case.


DETAILED RESPONSE
==================
  
We give detailed answers to the questions in each of the reviews below.

REVIEW B
--------------

> can it be explained what corresponds to Lawvere theories here?

The Lawvere theory of a GB-signature is the opposite category of the category of metacontexts and metasubstitutions.

> 41: The rule for FO does not make much sense to me.  In first order terms, 
> metavariables do not take arguments fo m should alkways be zero.

First, note that the FO rule entails that you have a single way of instantiating a metavariable, as you would expect from a metavariable not taking
any argument. Second, you are free to restrict to metavariables whose arities are 0. That said, let us explain more carefully in which sense this rule accounts for first-order unification. Pure lambda-calculus can be seen as a multisorted first-order syntax generated by the following components: the sorts are natural numbers; for each natural number n, we have n constants of that sort (the variables), an operation n × n → n (application), and an operation n + 1 → n (lambda-abstraction). Now, if you consider first-order unification in this setting, then metavariables can have any sort, hence the rule FO makes sense.



> 560: It might be helpful to illistrate example 2.5 with Agda code showing how > the binding signature specification in figure 6 can be instantiated with 

Here are the main definitions of the Agda code for Example 2.5:


data O n : Set where
   Var : Fin n → O n
   App : O n
   Lam : O n

α : {n : ℕ} → O n → List ℕ
α (Var x) = []
α {n} App = n ∷ n ∷ []
α {n} Lam = 1 + n ∷ []

_｛_｝ : ∀ {a b : ℕ} → O a → hom a b → O b
Var x ｛ s ｝ = Var (Vec.lookup s x)
App ｛ s ｝ = App
Lam ｛ s ｝ = Lam

_^_ : {a b : ℕ} (x : hom a b) (o : O a) →
      Pointwise hom (α o) (α (o ｛ x ｝))
x ^ Var y = []
x ^ App = x ∷ x ∷ []
x ^ Lam = (x ↑) ∷ []

> l744 Is $J$ in $\int J \to \mathcal{A}$ meant to be $\mathcal{O}$? 

Yes, thanks for pointing out the typo.

> am I right in believing that since the system F syntax is not up to any equational theory / normal form structure, the instantiation as a GB-signature is largely straightforward?

Yes. However, we do not see any obstacle in adapting our treatment of simply-typed lambda-calculus modulo beta/eta to the case of system F.

> In unifying $M(\vec{x}$ and $M(\vec{y})$ in a typed setting, do we need to check the matching xs and ys have the same types?

Our framework handles typed settings (such as simply-typed lambda-calculus, section 7.2) in such a way that knowing that $M(\vec{x}$ and $M(\vec{y})$ are well-formed in the same metacontext and scope is enough to conclude that the types of xs and ys are the same.

REVIEW C
--------------

> eta-long forms are not stable under type substitution. [...]  
> From the rather abbreviated presentation in section 7.5 I couldn't tell 
> whether and how this problem is handled.

We do not deal with beta or eta equalities in the example of system F. However, as said above, we do not see any obstacle in adapting our treatment of simply-typed lambda-calculus modulo beta/eta to the case of system F.

