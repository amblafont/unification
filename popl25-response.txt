We thank the referees for their useful comments and suggestions.

OVERVIEW
==================

Review A and C ask about the motivation of our work.
As noted by Review B, pattern unification is used in the implementation 
of various PLs. As a concrete example, consider Dunfield-Krishnaswami's type inference algorithm ("Sound and Complete Bidirectional Typechecking for Higher-Rank Polymorphism with Existentials and Indexed Types", 2019).
It only involves first-order unification, but simply adding a monomorphic type with a binder (for example, a recursive type 𝜇𝑎.𝐴[𝑎]) would require pattern unification. 

In order to avoid reproving everything for each new type system, pattern unification needs to be formulated generically so that it can be used in a variety of contexts without modification. This is our original motivation for this work. To the best of our knowledge, we are the first to give a general definition of pattern unification that works for a wide class of languages, in the vein of Rydeheard-Burstall's first-order analysis.

Review A and C note that Abel-Vezzosi already studied pattern unification using  a categorical approach; however they focused on the single case of normalised simply-typed lambda calculus, and as noted by Review C, our generalisation is not trivial. As a matter of fact, our treatment of lambda-calculus differs. In the revised version, we would make more explicit "how and why this difference".

Review C also mentions the work of Schack-Nielsen and Schurmann that devises
substructural pattern unification using syntactic method [LFMTP 2010]. As mentioned in Section 7.4, we cover a more restricted variant, but again, they focus on a single case, while we provide a general setting.

BETA/ETA EQUALITIES IN SYSTEM F 
====================================

Reviews A and C ask about the treatment of equalities in the System F example. In section 7.3  (simply-typed lambda-calculus modulo beta and eta), we explain how to deal with equations in the syntax, by working on normal forms.
The System F example is meant to address an orthogonal complexity related to the type system. In that case, the category of arities is not a mere product category (as suggested by Review A) because the set of possible types for the term variables depends on the available type variables.

We do not consider terms up to beta or eta equalities, and we have not thought about whether it is possible to deal with them as in section 7.3.
We thank Review C for raising the issue about eta-equality; we are not sure if this is a significant obstacle, since instantiation of metavariables in pattern unification does not involve full substitution, but only (injective) renaming.

If accepted, we will make this more explicit in a revised version.


ANSWERS TO REVIEW B
==================
  
> can it be explained what corresponds to Lawvere theories here?

The Lawvere theory of a GB-signature is the opposite category of the category of metacontexts and metasubstitutions. This makes the connection with the general observation that unification of terms corresponds to equalisers of parallel morphisms.

> 41: The rule for FO does not make much sense to me.  In first order terms, 
> metavariables do not take arguments fo m should alkways be zero.

What we mean here is that first-order unification is enough to solve unification problems with the FO rule for introducing metavariables. Let us take the example of pure lambda-calculus. We explain in the paragraph below how it can be specified as a multisorted first-order syntax, where the sorts are the natural numbers. This setting fits into first-order unification  with any further restriction on the sorts of metavariables. This is why the rule for FO does not restrict m to be 0. We agree that this might be confusing and propose to clarify this point in the revised version, if accepted.

As a multisorted first-order syntax, pure lambda-calculus is generated by the following operations, for each sort n:
- n constants of that sort (the variables);
- a binary operation n × n → n (application);
- a unary operation n + 1 → n (lambda-abstraction). 


> 560: It might be helpful to illistrate example 2.5 with Agda code showing how > the binding signature specification in figure 6 can be instantiated with 

Here are the main definitions of the Agda code for Example 2.5, which we propose to include in a revised version. 

data O n : Set where
   Var : Fin n → O n
   App : O n
   Lam : O n

α : {n : ℕ} → O n → List ℕ
α (Var x) = []
α {n} App = n ∷ n ∷ []
α {n} Lam = 1 + n ∷ []

_｛_｝ : ∀ {a b : ℕ} → O a → hom a b → O b
Var x ｛ s ｝ = Var (Vec.lookup s x)
App ｛ s ｝ = App
Lam ｛ s ｝ = Lam

_^_ : {a b : ℕ} (x : hom a b) (o : O a) →
      Pointwise hom (α o) (α (o ｛ x ｝))
x ^ Var y = []
x ^ App = x ∷ x ∷ []
x ^ Lam = (x ↑) ∷ []

> l744 Is $J$ in $\int J \to \mathcal{A}$ meant to be $\mathcal{O}$? 

Yes, thanks for pointing out the typo.

> am I right in believing that since the system F syntax is not up to any equational theory / normal form structure, the instantiation as a GB-signature is largely straightforward?

Yes. However, we do not see any obstacle in adapting our treatment of simply-typed lambda-calculus modulo beta/eta to the case of system F.

> In unifying $M(\vec{x}$ and $M(\vec{y})$ in a typed setting, do we need to check the matching xs and ys have the same types?

Our framework handles typed settings in such a way that knowing that $M(\vec{x}$ and $M(\vec{y})$ are well-formed in the same metacontext and scope is enough to conclude that the types of xs and ys are the same. This fact may be more or less implicit in the typed examples (e.g., simply-typed lambda-calculus, section 7.2); we propose to make it more explicit in the revised version.



