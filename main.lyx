#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{tikz-cd}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
theorems-ams-extended
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Second-order pattern unification
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Kl}[1]{Kl_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Eil}[1]{#1\text{-alg}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\directed}[3]{#1\supset_{#3}#2}
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
idee de generalisation, A telle que 
\begin_inset Formula $yA$
\end_inset

 preservant les coproduits , par exemple D-presentable, pour D les limites
 finies connexes.
 Appelons objet fini toute somme de D-presentable
\end_layout

\begin_layout Plain Layout
(note: ca correpsond forcement aux representables dans notre cas: hom(A,C+D),
 si A est non vide en p 
\begin_inset Formula $\neq$
\end_inset

 q, et C=yp et 
\begin_inset Formula $D=yq$
\end_inset

 on voit le pb, en gros).
 On peut eventuellement se restreindre a une sous cat de ces mecs.
\end_layout

\begin_layout Plain Layout
cat extensive (peut etre que coproduit disjoint suffit? Non).
 
\begin_inset Formula $\Sigma(X)=\coprod_{i}F_{i}(X)$
\end_inset

 ou chaque 
\begin_inset Formula $F_{i}$
\end_inset

 a un adjoint a gauche preservant les objets finis (pour gerer 
\begin_inset Formula $o(-)=o(-)$
\end_inset

) hmm ptet qu'il suffit que ca soit une colimite finie d'objets finis?.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\Kl{-\otimes I}$
\end_inset

 (restreints aux D-presentables, parce que ca correspond a 
\begin_inset Formula $\mathbb{F}^{op}$
\end_inset

 je crois) a les colimites connexes finies (pour faire 
\begin_inset Formula $M=N$
\end_inset

) et 
\begin_inset Formula $\Kl{-\otimes I}\rightarrow\Kl T$
\end_inset

 les preserve? AH, c'est donne une nouvelle consetruction pour le foncteur
 
\begin_inset Formula $\mathbb{F}^{op}\rightarrow\Kl T$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Et comment faire 
\begin_inset Formula $M$
\end_inset

 la phase de pruning.
\end_layout

\begin_layout Plain Layout
TODO: considere ajouter un element terminal a la categorie de Kleisli pour
 faire l'erreur et pour dire qu'on a une vraie colimite.
 Et du coup on peut dire que c'est finiment cocomplet.
 Et dire que le foncteur d'inclusion cree les colimites.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
We show correctness of an algorithm computing the most general unifier of
 a list of term pairs involving binding operations and 
\begin_inset Formula $n$
\end_inset

-ary metavariables applied to distinct variables.
 We reason in the framework of 
\begin_inset Formula $\Sigma$
\end_inset

-monoids 
\begin_inset CommandInset citation
LatexCommand cite
key "FioreSzamozvancev"
literal "false"

\end_inset

, but in the untyped case.
 In short, we show that a finite diagram in a second-order algebraic theory
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "secondorderlagth"
literal "false"

\end_inset

 generated by a binding signature has a limit as long as there exists a
 cone.
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:structural-recursive-algo"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we discuss an alternative algorithm whose termination is straightforward,
 but for which we do not prove correctness (yet?).
\begin_inset Note Note
status open

\begin_layout Plain Layout
, inspired from McBride's implementation in the first-order case 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/jfp/McBride03"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
First-order unification was categorically described in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Goguen89whatis"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

 introduces pattern unification, a particular case of higher-order unification
 for the simply-typed lambda-calculus, where metavariables are applied to
 distinct variables.
 Hence, it has strong similarities with the problem we are studying.
 In particular, one can see our setting as a restricted case of theirs,
 since, in particular, we focus on second-order syntax.
 However, we can translate pattern unification problems in our setting extended
 to the simply-typed case, see Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:higher-order-unification"
plural "false"
caps "false"
noprefix "false"

\end_inset

, following ideas from
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cheney2005relating"
literal "false"

\end_inset

.
 Moreover we prove a stronger property of the most general unifier, namely
 that it is also the most general one among substitutions that are not pattern
 like.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
except that no binding is involved.
 Let us already note that binding did not bring any particular difficulty
 in our work.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

 proposes a categorical understanding of pattern unification.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
I find Miller's article hard to read because it uses a pedestrian old-style
 theoretical account of syntax, and moreover the unification problem/algorithm
 is not clearly separated from the various other concerns.
 Thus I will rather discuss pattern unification as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

.
 In fact, there I found disturbing features, e.g., the typing rule 
\begin_inset Formula $\tau,\Delta\vdash0:\tau$
\end_inset

 does not enforce 
\begin_inset Formula $\tau$
\end_inset

 to be a base type while the inductive definition of the syntax seems to
 forbid an arrow type.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Notations
\end_layout

\begin_layout Standard
We denote by 
\begin_inset Formula $C^{o}$
\end_inset

 the opposite category of 
\begin_inset Formula $C$
\end_inset

.
 In a category with coproducts, we denote by 
\begin_inset Formula $in:A_{i}\hookrightarrow\coprod_{i}A_{i}$
\end_inset

 the coproduct injection.
 If 
\begin_inset Formula $F$
\end_inset

 is an endofunctor on a category 
\begin_inset Formula $C$
\end_inset

, we denote by 
\begin_inset Formula $\mu F$
\end_inset

 or 
\begin_inset Formula $\mu Z.F(Z)$
\end_inset

 the initial 
\begin_inset Formula $F$
\end_inset

-algebra.
\end_layout

\begin_layout Standard
We denote by 
\begin_inset Formula $\mathbb{F}$
\end_inset

 the full subcategory of sets consisting of finite cardinals: objects are
 natural numbers and a morphism between 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 is a function 
\begin_inset Formula $\{0,\dots,n-1\}\rightarrow\{0,\dots,m-1\}$
\end_inset

.
\end_layout

\begin_layout Standard
Given a monad 
\begin_inset Formula $T$
\end_inset

 on a category 
\begin_inset Formula $C$
\end_inset

, we denote the Kleisli category by 
\begin_inset Formula $\Kl T$
\end_inset

: objects are objects of 
\begin_inset Formula $C$
\end_inset

, and morphisms between 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $c'$
\end_inset

 are morphisms in 
\begin_inset Formula $C$
\end_inset

 between 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $Tc'$
\end_inset

.
 Note that there is a bijection between Kleisli morphisms 
\begin_inset Formula $c\rightarrow Tc'$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

-algebra morphisms 
\begin_inset Formula $Tc\rightarrow Tc'$
\end_inset

.
 We denote by 
\begin_inset Formula $f^{*}$
\end_inset

 the 
\begin_inset Formula $T$
\end_inset

-algebra morphism induced by a Kleisli morphism.
 Composition of 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $f$
\end_inset

 is given by 
\begin_inset Formula $g^{*}\circ f$
\end_inset

.
 We denote by 
\begin_inset Formula $I:\mathbb{N}\rightarrow Set$
\end_inset

 the family of sets mapping 
\begin_inset Formula $n$
\end_inset

 to the 
\begin_inset Formula $n^{th}$
\end_inset

 cardinal set 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
\end_layout

\begin_layout Standard
We denote metavariables by capital letters 
\begin_inset Formula $M,N$
\end_inset

,...
\end_layout

\begin_layout Section
Setting
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\Sigma$
\end_inset

 be a binding signature.
 Then, there is a free 
\begin_inset Formula $\Sigma$
\end_inset

-monoid monad 
\begin_inset Formula $T$
\end_inset

 on 
\begin_inset Formula $Set^{\mathbb{N}}$
\end_inset

 such that 
\begin_inset Formula $T(X)$
\end_inset

 is the syntax of 
\begin_inset Formula $\Sigma$
\end_inset

 extended with an 
\begin_inset Formula $n$
\end_inset

-ary operation for each 
\begin_inset Formula $x\in X_{n}$
\end_inset

.
 More precisely, 
\begin_inset Formula $T(X)_{n}$
\end_inset

 is the set of terms whose free variables are in 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
 
\end_layout

\begin_layout Example
Consider the case of 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 Then, 
\begin_inset Formula $T(\emptyset)_{n}$
\end_inset

 is the set of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\ensuremath{\lambda}$
\end_inset

-terms 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $t$
\end_inset

 taking free variables in 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
\end_layout

\begin_layout Example
Consider 
\begin_inset Formula $X\in Set^{\mathbb{N}}$
\end_inset

 such that 
\begin_inset Formula $X_{2}=\{M\}$
\end_inset

 and 
\begin_inset Formula $X_{n\neq2}=\emptyset$
\end_inset

.
 Then 
\begin_inset Formula $T(X)_{n}$
\end_inset

 is the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
set of 
\begin_inset Formula $\ensuremath{\lambda}$
\end_inset

-terms 
\begin_inset Formula $t$
\end_inset

 involving a metavariable 
\begin_inset Formula $\ensuremath{M}$
\end_inset

 of arity 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\ensuremath{2}$
\end_inset

 such that 
\begin_inset Formula $fv(t)\subset\{0,\dots,n-1\}$
\end_inset

.
\end_layout

\begin_layout Example
Consider 
\begin_inset Formula $Y\in Set^{\mathbb{N}}$
\end_inset

 such that 
\begin_inset Formula $Y_{2}=\{M,N\}$
\end_inset

, 
\begin_inset Formula $Y_{0}=\{C\}$
\end_inset

 and 
\begin_inset Formula $Y_{n}=\emptyset$
\end_inset

 otherwise.
 Then 
\begin_inset Formula $T(Y)_{n}$
\end_inset

 is the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\ensuremath{\lambda}$
\end_inset

-term t with metavariables 
\begin_inset Formula $\ensuremath{M}$
\end_inset

,
\begin_inset Formula $\ensuremath{N}$
\end_inset

 of arity 2 and a constant metavariable 
\begin_inset Formula $\ensuremath{C}$
\end_inset

 such that
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $fv(t)\subset\{0,\dots,n-1\}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Note that metavariables are allowed to be applied to arbitrary terms here,
 not only (distinct) variables.
 
\end_layout

\begin_layout Definition
A morphism 
\begin_inset Formula $X\rightarrow T(Y)$
\end_inset

 is said 
\emph on
safe
\emph default
 if it factors through 
\begin_inset Formula $T'(Y)\rightarrow T(Y)$
\end_inset

, where 
\begin_inset Formula $T'(Y)_{n}$
\end_inset

 is the subset of 
\begin_inset Formula $T(Y)_{n}$
\end_inset

 consisting of terms that where metavariables are applied to distinct variables
 only, rather than arbitrary terms.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Et mais, T' est une monade!
\end_layout

\end_inset


\end_layout

\begin_layout Remark
\begin_inset Formula $T'(Y)$
\end_inset

 is the initial algebra for 
\begin_inset Formula $Z\mapsto I+Z\boxtimes I+\Sigma(Z)$
\end_inset

, where 
\end_layout

\begin_deeper
\begin_layout Itemize
we denote by 
\begin_inset Formula $\Sigma$
\end_inset

 the endofunctor on 
\begin_inset Formula $Set^{\mathbb{N}}$
\end_inset

 corresponding to the binding signature 
\begin_inset Formula $\Sigma$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $(Z\boxtimes I)_{n}=\coprod_{p}Z_{p}\times Inj(p,I_{n})$
\end_inset

.
 Note that this definition is not functorial in the second argument (unless
 we restrict to monomorphisms).
\end_layout

\end_deeper
\begin_layout Notation
We denote by 
\begin_inset Formula $\Kl T$
\end_inset

 the Kleisli category of the monad 
\begin_inset Formula $T$
\end_inset

: objects are families in 
\begin_inset Formula $Set^{\mathbb{N}}$
\end_inset

 and a morphism 
\begin_inset Formula $X\rightarrow Y$
\end_inset

 is a family morphism 
\begin_inset Formula $X\rightarrow T(Y)$
\end_inset

.
\end_layout

\begin_layout Remark
A (metavariable) substitution is precisely a morphism in the Kleisli category.
 For example, a Kleisli morphism from 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $Y$
\end_inset

 is a morphism 
\begin_inset Formula $X\rightarrow T(Y)$
\end_inset

, i.e., for each 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, a map 
\begin_inset Formula $X_{n}\rightarrow T(Y)_{n}$
\end_inset

 which assigns a term taking free variables in 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

 for each 
\begin_inset Formula $n$
\end_inset

-ary metavariable.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Consider the 
\begin_inset Quotes eld
\end_inset

operadic
\begin_inset Quotes erd
\end_inset

 monoidal product 
\begin_inset Formula $A\boxtimes B_{n}=\coprod_{p}\coprod_{i_{1}+\dots+i_{p}=n}A_{p}\times B_{i_{1}}\times\dots\times B_{i_{p}}$
\end_inset

 and 
\begin_inset Formula $\Sigma$
\end_inset

-monoids for this tensor products, with associated monad 
\begin_inset Formula $T'$
\end_inset

.
 In this setting, we think of 
\begin_inset Formula $T'(X)_{n}$
\end_inset

 as the set of terms withneed to exactly 
\begin_inset Formula $n$
\end_inset

 free variables.
 Thus, Kleisli morphisms maps metavariables to terms using exactly once
 each argument.
\end_layout

\begin_layout Definition
A family 
\begin_inset Formula $X\in Set^{\mathbb{N}}$
\end_inset

 is said 
\emph on
finite
\emph default
 if 
\begin_inset Formula $\coprod_{n}X_{n}$
\end_inset

 is finite.
\end_layout

\begin_layout Remark
The full subcategory of 
\begin_inset Formula $\Kl T$
\end_inset

 consisting of finite families corresponds to the second-order algebraic
 theory associated with 
\begin_inset Formula $T$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "secondorderlagth"
literal "false"

\end_inset

.
 
\color red
TODO: think over this remark.
\end_layout

\begin_layout Standard
Our main result consists in the following.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:main-result"

\end_inset

Let 
\begin_inset Formula $V\rightrightarrows T(W)$
\end_inset

 be a pair of safe morphisms between finite families 
\begin_inset Formula $V$
\end_inset

 and 
\begin_inset Formula $W$
\end_inset

.
 If there is a coequalising Kleisli morphism, then there is coequaliser
 in 
\begin_inset Formula $Kl(T)$
\end_inset

.
\end_layout

\begin_layout Standard
We use an explicit construction, detailed in the next section.
 This theorem allows to compute the most general unifier of two terms.
\end_layout

\begin_layout Corollary
Let 
\begin_inset Formula $t,u\in T(V)_{n}$
\end_inset

 for some finite family 
\begin_inset Formula $V\in Set^{\mathbb{N}}$
\end_inset

 (thought as a specification of metavariables).
 If there exists a substitution unifying 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

, then there exists a most general unifier, i.e., a substitution 
\begin_inset Formula $V\rightarrow T(W)$
\end_inset

 such that any other unifying substitution uniquely factors through it.
\end_layout

\begin_layout Proof
Giving two terms 
\begin_inset Formula $t,u\in T(V)_{n}$
\end_inset

 amounts to giving two parallel morphisms 
\begin_inset Formula $yn\rightrightarrows T(V)$
\end_inset

, where 
\begin_inset Formula $yn$
\end_inset

 denotes the family defined by 
\begin_inset Formula $yn_{p}=\emptyset$
\end_inset

 if 
\begin_inset Formula $p\neq n$
\end_inset

 and 
\begin_inset Formula $yn_{n}$
\end_inset

 is a singleton set.
 The most general unifier, if it exists, is the coequaliser of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout Standard
More generally, we can compute any finite colimit under the same condition.
\end_layout

\begin_layout Corollary
Let 
\begin_inset Formula $J:D\rightarrow\Kl T$
\end_inset

 be a finite diagram selecting safe Kleisli morphisms and finite families.
 If there is a cocone, then 
\begin_inset Formula $J$
\end_inset

 has a colimit.
\end_layout

\begin_layout Proof
This follows from the computation of colimits as coequalisers and coproducts
 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem V.2.2"
key "MacLane:cwm"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Let us finish this section by introducing some useful definitions, notations,
 and lemmas.
\end_layout

\begin_layout Lemma
Free 
\begin_inset Formula $T$
\end_inset

-algebras extend to functors 
\begin_inset Formula $\mathbb{F}\rightarrow Set$
\end_inset

 preserving pullbacks, where 
\begin_inset Formula $\mathbb{F}$
\end_inset

 is the full subcategory of sets consisting in finite cardinals.
 Action on morphisms is given by renaming.
 Moreover, Kleisli morphisms are compatible with renaming.
\end_layout

\begin_layout Proof
See Appendix
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:free-talg-pullback"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Notation
If 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, we denote the 
\begin_inset Formula $n^{th}$
\end_inset

 cardinal set 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

 by 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Notation
If 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, we denote by 
\begin_inset Formula $yn$
\end_inset

 the yoneda embedding into 
\begin_inset Formula $Set^{\mathbb{N}}$
\end_inset

, i.e., 
\begin_inset Formula $yn(p)$
\end_inset

 is empty if 
\begin_inset Formula $n\neq p$
\end_inset

 and a singleton set otherwise.
 We call 
\emph on
representable
\emph default
 any family which is isomorphic to some 
\begin_inset Formula $yn$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that morphisms from 
\begin_inset Formula $yn$
\end_inset

 to 
\begin_inset Formula $X$
\end_inset

 are in one-to-one correspondence with elements of 
\begin_inset Formula $X_{n}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Notation
\begin_inset Formula $I\in Set^{\mathbb{N}}$
\end_inset

 denotes the family 
\begin_inset Formula $I_{n}=n$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:family-coprod-rep"

\end_inset

Any family 
\begin_inset Formula $X\in Set^{\mathbb{N}}$
\end_inset

 is isomorphic to a coproduct of representable families.
 A family 
\begin_inset Formula $X$
\end_inset

 is finite if and only if such a coproduct is finite.
\end_layout

\begin_layout Proof
Clearly, any family 
\begin_inset Formula $X$
\end_inset

 is isomorphic to 
\begin_inset Formula $\coprod_{n}X_{n}yn\simeq\coprod_{n}\coprod_{x\in X_{n}}yn$
\end_inset

.
\end_layout

\begin_layout Notation
We represent a finite family 
\begin_inset Formula $X\in Set^{\mathbb{N}}$
\end_inset

 as a finite (metavariable) context 
\begin_inset Formula $x_{1}:n_{1},\dots,x_{p}:n_{p}$
\end_inset

 where 
\begin_inset Formula $x_{i}\in X_{n_{i}}$
\end_inset

.
\end_layout

\begin_layout Section
Algorithm
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:algorithm"

\end_inset


\end_layout

\begin_layout Standard
The algorithm takes as input
\end_layout

\begin_layout Itemize
a (finite) metavariable context 
\begin_inset Formula $\Gamma\in Set^{\mathbb{N}}$
\end_inset

, that we denote by a list 
\begin_inset Formula $M_{1}:m_{1},\dots M_{n}:m_{n}$
\end_inset

 of metavariable symbols 
\begin_inset Formula $M_{i}$
\end_inset

 with their associated arities 
\begin_inset Formula $m_{i}$
\end_inset

;
\end_layout

\begin_layout Itemize
a list of term pairs 
\begin_inset Formula $t_{i}=_{n_{i}}u_{i}$
\end_inset

, where 
\begin_inset Formula $n_{i}$
\end_inset

 that 
\begin_inset Formula $t_{i}$
\end_inset

 and 
\begin_inset Formula $u_{i}$
\end_inset

 takes free variables in 
\begin_inset Formula $\{0,\dots,n_{i}-1\}$
\end_inset


\end_layout

\begin_layout Standard
It outputs:
\end_layout

\begin_layout Itemize
a metavariable context 
\begin_inset Formula $\Delta$
\end_inset


\end_layout

\begin_layout Itemize
a Kleisli map 
\begin_inset Formula $\sigma:\Gamma\rightarrow T(\Delta)$
\end_inset

, that is a substitution assigning to each metavariable 
\begin_inset Formula $M:m$
\end_inset

 declared in 
\begin_inset Formula $\Gamma$
\end_inset

 a term with 
\begin_inset Formula $m$
\end_inset

 free variables involving metavariables 
\begin_inset Formula $\Delta$
\end_inset

.
 
\end_layout

\begin_layout Standard
In this section we inductively specify the algorithm through the judgement
\begin_inset Formula 
\[
\Gamma\vdash t_{1}=_{n_{1}}u_{1},\dots t_{p}=_{n_{p}}u_{p}\Rightarrow\sigma\dashv\Delta
\]

\end_inset

 that we sometimes abbreviate as 
\begin_inset Formula 
\[
\Gamma\vdash\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\dashv\Delta
\]

\end_inset


\end_layout

\begin_layout Standard
The completeness statement (proven by induction) is the following.
\end_layout

\begin_layout Proposition
Given a list of safe term pairs 
\begin_inset Formula $\vec{t}=\vec{u}$
\end_inset

 taking metavariables in 
\begin_inset Formula $\Gamma$
\end_inset

, if there exists a (finite) derivation tree of 
\begin_inset Formula $\Gamma\vdash\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

, then 
\begin_inset Formula $\sigma$
\end_inset

 is the most general unifier.
 Moreover such a derivation tree exists as long as there exists at least
 one unifier.
\end_layout

\begin_layout Standard
We will justify this proposition by showing that each introduced rule is
 sound, in the sense that that it supports the induction step.
 We omit the proof that if the conclusion involves safe terms, the also
 do the premises.
\end_layout

\begin_layout Standard
At most one rule is applyable given an input 
\begin_inset Formula $\vec{t}=\vec{u}$
\end_inset

.
\end_layout

\begin_layout Proposition
There is at most one derivation tree of 
\begin_inset Formula $\Gamma\vdash\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

.
\end_layout

\begin_layout Standard
Let us list indeed the rules according to the input 
\begin_inset Formula $\vec{t}=\vec{u}$
\end_inset

 in the conclusion:
\end_layout

\begin_layout Itemize
Empty
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\end_layout

\end_inset

list 
\begin_inset Formula $\vec{t}=\vec{u}=()$
\end_inset

, in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:empty-list"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize
Non
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\end_layout

\end_inset

empty,
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\end_layout

\end_inset

non
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\end_layout

\end_inset

singleton
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\end_layout

\end_inset

lists, 
\begin_inset Formula $t_{0}=u_{0},\vec{t}=\vec{u}$
\end_inset

, in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:stepwise-algo"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $M(\vec{x})=N(\vec{y})$
\end_inset

, in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:case-metavars"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $o(\vec{t})=o(\vec{u})$
\end_inset

 and 
\begin_inset Formula $x=y$
\end_inset

 in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:case-op-op"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $M(\vec{x})=o(\vec{t})$
\end_inset

, in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:case-mvar-op"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $M(\vec{x})=x_{i}$
\end_inset

, in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:case-mvar-var"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Let us mention the missing cases, which can never be unified anyway.
\end_layout

\begin_layout Itemize
\begin_inset Formula $o(\vec{t})=o'(\vec{u})$
\end_inset

 when 
\begin_inset Formula $o\neq o'$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $M(\vec{x})=y$
\end_inset

 when 
\begin_inset Formula $y\notin\vec{x}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $o(\vec{t})=x$
\end_inset


\end_layout

\begin_layout Subsection
Empty list
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:empty-list"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{}{\Gamma\vdash()\Rightarrow id\dashv\Gamma}
\]

\end_inset


\end_layout

\begin_layout Standard
Soundness is straightforward.
\end_layout

\begin_layout Subsection
Stepwise construction
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:stepwise-algo"

\end_inset


\end_layout

\begin_layout Standard
We can restrict to the case of a single coequaliser.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash t_{0}=_{n_{0}}u_{0}\Rightarrow\sigma_{0}\dashv\Delta_{1}\qquad\Delta_{1}\vdash\vec{t}[\text{\ensuremath{\sigma_{0}]}}=_{\vec{n}}\vec{u}[\text{\ensuremath{\sigma_{0}]}}\Rightarrow\sigma\dashv\Delta_{2}\qquad\vec{t}\text{ is not empty}}{\Gamma\vdash t_{0}=_{n_{0}}u_{0},\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\circ\sigma_{0}\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
Soundness of this rule follows from the following general categorical lemma.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:coeq-stepwise"

\end_inset

Let 
\begin_inset Formula $f_{1},g_{1}:A_{1}\rightarrow B$
\end_inset

 and 
\begin_inset Formula $f_{2},g_{2}:A_{2}\rightarrow B$
\end_inset

 be morphisms in some category.
 Then the coequaliser of the induced parallel morphism 
\begin_inset Formula $A_{1}\coprod A_{2}\rightrightarrows B$
\end_inset

 is the morphism 
\begin_inset Formula $B\rightarrow C\rightarrow D$
\end_inset

 defined as follows (assuming the involved coequalisers exist):
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\rightarrow C$
\end_inset

 is the coequaliser of 
\begin_inset Formula $A_{1}\rightrightarrows B$
\end_inset

;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $C\rightarrow D$
\end_inset

 is the coequaliser of 
\begin_inset Formula $A_{2}\rightrightarrows B\rightarrow C$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Corollary
The above rule is sound.
\end_layout

\begin_layout Proof
Assume there is a common unifier for 
\begin_inset Formula $t_{0}=u_{0},\vec{t}=\vec{u}$
\end_inset

.
 By induction hypothesis, the premises are derivable and thus the rule can
 be applied.
 Moreover, again by induction hypothesis, the premises produce most general
 unifiers.
 The output substitution of the conclusion is also the most general unifier,
 thanks to the previous lemma by specialising it to the Kleisli category
 
\begin_inset Formula $\Kl T$
\end_inset

, taking 
\begin_inset Formula $A_{1}=yn_{0}$
\end_inset

 and 
\begin_inset Formula $A_{2}=\coprod_{i}yn_{i}$
\end_inset

.
\end_layout

\begin_layout Subsection
Case 
\begin_inset Formula $M(x_{1},\dots,x_{m})=_{q}N(y_{1},\dots,y_{n})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:case-metavars"

\end_inset

We need to make the distinction whether 
\begin_inset Formula $M=N$
\end_inset

 or not.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{(i_{1},\dots,i_{p})\text{\text{ is the family of common positions: \ensuremath{x_{\vec{i}}=y_{\vec{i}}}}}}{\Gamma\vdash M(\vec{x})=_{q}M(\vec{y})\Rightarrow M(1,\dots,m)\mapsto N(i_{1},\dots i_{p})\dashv\Gamma\backslash\{M\},N:p}
\]

\end_inset


\end_layout

\begin_layout Standard
The premise states that 
\begin_inset Formula $i:p\rightarrow m$
\end_inset

 is the equaliser of 
\begin_inset Formula $\vec{x},\vec{y}:m\rightarrow q$
\end_inset

 in 
\begin_inset Formula $\mathbb{F}$
\end_inset

.
\begin_inset Formula 
\[
\dfrac{M\neq N\qquad(i_{1},\dots,i_{p})\text{\text{ and \ensuremath{(j_{1},\dots,j_{p})} are maximal such that \ensuremath{x_{\vec{i}}=y_{\vec{j}}}}}}{\Gamma\vdash M(\vec{x})=_{q}N(\vec{y})\Rightarrow M(1,\dots,m)\mapsto O(i_{1},\dots i_{p}),N(1,\dots,n)\mapsto O(j_{1},\dots,j_{p})\dashv\Gamma\backslash\{M,N\},O:p}
\]

\end_inset


\end_layout

\begin_layout Standard
The premise states that 
\begin_inset Formula $m\xleftarrow{i}p\xrightarrow{j}n$
\end_inset

 is a pullback of 
\begin_inset Formula $m\xrightarrow{\vec{x}}q\xleftarrow{\vec{y}}n$
\end_inset

 in 
\begin_inset Formula $\mathbb{F}$
\end_inset

.
\end_layout

\begin_layout Proposition
The above rules are sound.
\end_layout

\begin_layout Proof
We prove that the output substitution is the most general unifier.
 
\end_layout

\begin_layout Proof
Let us consider the first rule.
 We decompose 
\begin_inset Formula $\Gamma$
\end_inset

 as 
\begin_inset Formula $M:m,\Gamma'$
\end_inset

 the coproduct of 
\begin_inset Formula $ym$
\end_inset

 and 
\begin_inset Formula $\Gamma'$
\end_inset

.
 The term 
\begin_inset Formula $M(\vec{x})$
\end_inset

 corresponds to the composition of 
\begin_inset Formula $yq\xrightarrow{M(\vec{x})}T(ym)\hookrightarrow$
\end_inset

 
\begin_inset Formula $T(\Gamma)$
\end_inset

.
 More abstractly, we want to compute the coequaliser, in 
\begin_inset Formula $\Kl T,$
\end_inset

 of
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: introduce 
\begin_inset Formula $\mathbf{y}$
\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\xymatrix{ & B\ar@{^{(}->}[dr]\\
A\ar[ru]^{M(\vec{x})}\ar[dr]_{M(\vec{y})} &  & B+C\\
 & B\ar@{^{(}->}[ru]
}
\]

\end_inset

for 
\begin_inset Formula $A=yq$
\end_inset

, 
\begin_inset Formula $B=ym$
\end_inset

, 
\begin_inset Formula $C=\Gamma'$
\end_inset

.
 It is enough to compute the coequaliser of 
\series bold

\begin_inset Formula $f:B\rightarrow D$
\end_inset

 
\series default
of 
\begin_inset Formula $A\rightrightarrows B$
\end_inset

, for the desired coequaliser is then 
\begin_inset Formula $B+C\xrightarrow{f+C}D+C$
\end_inset

.
 So we need to compute the coequaliser of 
\begin_inset Formula $yq\rightrightarrows T(ym)$
\end_inset

.
 As we explain in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:free-talg-pullback"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the functor 
\begin_inset Formula $\mathbb{N}\xrightarrow{y}Set^{\mathbb{N}}\rightarrow\Kl T$
\end_inset

 extends to a functor 
\begin_inset Formula $\mathbf{y}:\mathbb{F}\rightarrow\Kl T^{op}$
\end_inset

 such that the coequaliser is precisely that of 
\begin_inset Formula ${\bf y}\vec{x}$
\end_inset

 and 
\begin_inset Formula $\mathbf{y}\vec{y}$
\end_inset

.
 Since 
\begin_inset Formula $\mathbf{y}$
\end_inset

 preserves equalisers (Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:y-preserves-connected"
plural "false"
caps "false"
noprefix "false"

\end_inset

), the coequaliser is 
\begin_inset Formula $ym\xrightarrow{\mathbf{y}i}T(yp)$
\end_inset

, where 
\begin_inset Formula $i:p\rightarrow m$
\end_inset

 is the equaliser of 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

.
\end_layout

\begin_layout Proof
The second rule can be justified similarly.
\end_layout

\begin_layout Subsection
Case 
\begin_inset Formula $o(\vec{t})=o(\vec{u})$
\end_inset

 and 
\begin_inset Formula $x=y$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:case-op-op"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{o\text{ has binding arity \ensuremath{\vec{n}}}\qquad\Gamma\vdash\vec{t}=_{q+\vec{n}}\vec{u}\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash o(\vec{t})=_{q}o(\vec{u})\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\begin_layout Lemma
This rule is sound.
\end_layout

\begin_layout Proof
The result follows from the fact that a substitution unifies 
\begin_inset Formula $o(\vec{t})=o(\vec{u})$
\end_inset

 if and only if it unifies 
\begin_inset Formula $\vec{t}$
\end_inset

 with 
\begin_inset Formula $\vec{u}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{}{\Gamma\vdash x=_{q}x\Rightarrow id\dashv\Gamma}
\]

\end_inset


\end_layout

\begin_layout Subsection
Case 
\begin_inset Formula $M(\vec{x})=o(\vec{u})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:case-mvar-op"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
o\text{ has binding arity \ensuremath{(n_{1},\dots,n_{p})}\ensuremath{\qquad} \ensuremath{M}\text{ does not occur in \ensuremath{\vec{u}}}}\\
\Gamma\backslash\{M\},\vec{N}:m+\vec{n}\vdash N_{1}(0,\dots,n_{1}-1,x_{1}+n_{1},\dots,x_{m}+n_{1})=_{q+n_{1}}u_{1},\dots\Rightarrow\sigma\dashv\Delta
\end{array}}{\Gamma\vdash M(\vec{x})=_{q}o(\vec{u})\Rightarrow\sigma\circ M(1,\dots m)\mapsto o(\vec{N})\dashv\Delta}
\]

\end_inset


\end_layout

\begin_layout Lemma
The above rule are sound.
\end_layout

\begin_layout Proof
If there is a unifier, then 
\begin_inset Formula $M$
\end_inset

 can't appear in 
\begin_inset Formula $\vec{u}$
\end_inset

 for size reason.
 Let us write 
\begin_inset Formula $\Gamma$
\end_inset

 as 
\begin_inset Formula $M:m,\Gamma'$
\end_inset

, the coproduct of 
\begin_inset Formula $ym$
\end_inset

 and 
\begin_inset Formula $\Gamma'$
\end_inset

.
 The term 
\begin_inset Formula $M(\vec{x})$
\end_inset

 corresponds to the composition of 
\begin_inset Formula $yq\rightarrow T(ym)$
\end_inset

 selecting 
\begin_inset Formula $M(\vec{x})$
\end_inset

 with the coproduct injection 
\begin_inset Formula $T(ym)\hookrightarrow T(\Gamma)$
\end_inset

.
 As 
\begin_inset Formula $M$
\end_inset

 does not appear in 
\begin_inset Formula $o(\vec{u})$
\end_inset

, the corresponding morphism 
\begin_inset Formula $yq\rightarrow T(\Gamma)$
\end_inset

 factors through the coproduct injection 
\begin_inset Formula $T(\Gamma')\hookrightarrow T(\Gamma)$
\end_inset

.
 In other words, we want to compute the coequaliser (in 
\begin_inset Formula $\Kl T$
\end_inset

) of
\begin_inset Formula 
\[
\xymatrix{ & B\ar@{^{(}->}[dr]\\
A\ar[ru]\ar[dr] &  & B+C\\
 & C\ar@{^{(}->}[ru]
}
\]

\end_inset

with 
\begin_inset Formula $A=yq$
\end_inset

, 
\begin_inset Formula $B=ym$
\end_inset

 and 
\begin_inset Formula $C=\Gamma'$
\end_inset

.
 This is equivalent to the pushout of 
\begin_inset Formula $B\leftarrow A\rightarrow C$
\end_inset

.
 The morphism 
\begin_inset Formula $A\rightarrow C$
\end_inset

 corresponding to 
\begin_inset Formula $o(\vec{u})$
\end_inset

 factors as 
\begin_inset Formula $yq\xrightarrow{u}T(\Gamma')^{(\vec{n})}\xrightarrow{o}T(\Gamma')$
\end_inset

.
 
\end_layout

\begin_layout Proof
Now, let us study the category of unifiers.
 A unifier 
\begin_inset Formula $ym\rightarrow T(\Delta)\leftarrow\Gamma'$
\end_inset

 must maps 
\begin_inset Formula $M$
\end_inset

 to some 
\begin_inset Formula $o(\dots)$
\end_inset

, so that 
\begin_inset Formula $ym\rightarrow T(\Delta)$
\end_inset

 factors as 
\begin_inset Formula $ym\rightarrow T(\Delta)^{(\vec{n})}\xrightarrow{o}T(\Delta)$
\end_inset

.
 In other words, a unifier is a family 
\begin_inset Formula $\Delta$
\end_inset

 with morphisms 
\begin_inset Formula $f:\Gamma'\rightarrow T(\Delta)$
\end_inset

 and 
\begin_inset Formula $g:ym\rightarrow T(\Delta)^{(\vec{n})}$
\end_inset

 such that the following diagram commutes:
\begin_inset Formula 
\[
\xymatrix{yq\ar[r]^{M(\vec{x})}\ar[d]_{u} & T(ym)\ar@{->}[r]^{g^{*}} & T(\Delta)^{(\vec{n})}\ar[dd]^{o}\\
T(\Gamma')^{\vec{(n)}}\ar[d]_{o}\\
T(\Gamma')\ar[rr]_{f^{*}} &  & T(\Delta)
}
\]

\end_inset

Now, since 
\begin_inset Formula $f^{*}$
\end_inset

 is a 
\begin_inset Formula $T$
\end_inset

-algebra morphism, commutation of the previous diagram is equivalent to
 commutation of the following one:
\begin_inset Formula 
\[
\xymatrix{yq\ar[r]^{M(\vec{x})}\ar[d]_{u} & T(ym)\ar@{->}[r]^{g^{*}} & T(\Delta)^{(\vec{n})}\ar[dd]^{o}\\
T(\Gamma')^{\vec{(n)}}\ar[d]_{f^{*^{(\vec{n})}}}\\
T(\Delta)^{(\vec{n})}\ar[rr]_{o} &  & T(\Delta)
}
\]

\end_inset


\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $o$
\end_inset

 is injective, this is equivalent to commutation of the following diagram.
\begin_inset Formula 
\[
\xymatrix{yq\ar[r]^{M(\vec{x})}\ar[d]_{u} & T(ym)\ar@{->}[d]^{g^{*}}\\
T(\Gamma')^{(\vec{n})}\ar[r]_{f^{*^{(\vec{n})}}} & T(\Delta)^{(\vec{n})}
}
\]

\end_inset


\end_layout

\begin_layout Proof
Now, a morphism 
\begin_inset Formula $u:yk\rightarrow Y^{(\vec{n})}$
\end_inset

 is equivalently given by a morphism 
\begin_inset Formula $u':y(k+\vec{n})\rightarrow Y$
\end_inset

, where 
\begin_inset Formula $y(k+\vec{n})$
\end_inset

 denotes the coproduct 
\begin_inset Formula $\coprod_{i}y(k+n_{i})$
\end_inset

.
 Then 
\begin_inset Formula $u$
\end_inset

 can be retrieved from 
\begin_inset Formula $u'$
\end_inset

 as the composition 
\begin_inset Formula $yk\xrightarrow{d}y(k+\vec{n})^{\vec{(n)}}\xrightarrow{u'^{(\vec{n})}}Y^{(\vec{n})}$
\end_inset

.
 Thus, a unifier is given by a family 
\begin_inset Formula $\Delta$
\end_inset

 together with Kleisli morphisms 
\begin_inset Formula $g':y(m+\vec{n})\rightarrow T(\Delta)$
\end_inset

 and 
\begin_inset Formula $h:\Gamma'\rightarrow T(\Delta)$
\end_inset

 such that the following diagram commutes.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
the previous diagram commutes if and only if the following one does.
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
\xymatrix{y(q+\vec{n})\ar[r]^{M(\vec{x})'}\ar[d]_{u'} & T(y(m+\vec{n}))\ar[d]^{g'^{*}}\\
T(\Gamma')\ar[r]_{f^{*}} & T(\Delta)
}
\label{eq:unifier-v1}
\end{equation}

\end_inset

Thus, a unifier is a cocone over the pushout diagram
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
\xymatrix{y(q+\vec{n})\ar[r]^{M(\vec{x})'}\ar[d]_{u'} & T(y(m+\vec{n}))\\
T(\Gamma')
}
\]

\end_inset

The premise is precisely computing this colimit, producing 
\begin_inset Formula $\sigma:\Gamma'+y(m+\vec{n})\rightarrow T(\Delta)$
\end_inset

:
\begin_inset Formula 
\[
\Gamma\backslash\{M\},\vec{N}:m+\vec{n}\vdash N_{1}(0,\dots,n_{1}-1,x_{1}+n_{1},\dots,x_{m}+n_{1})=_{q+n_{1}}u_{1},\dots\Rightarrow\sigma\dashv\Delta
\]

\end_inset

The desired unifier is then the composition of 
\begin_inset Formula $\sigma$
\end_inset

 with the coproduct morphism (in 
\begin_inset Formula $\Kl T$
\end_inset

) 
\begin_inset Formula $\Gamma'+ym\xrightarrow{id_{\Gamma'}+v}T(\Gamma'+y(m+\vec{n}))$
\end_inset

, where 
\begin_inset Formula $v$
\end_inset

 is the composite 
\begin_inset Formula $ym\xrightarrow{}T(y(m+\vec{n}))^{(\vec{n})}\xrightarrow{o}T(y(m+\vec{n}))$
\end_inset

.
\end_layout

\begin_layout Subsection
Case 
\begin_inset Formula $M(\vec{x})=x_{i}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:case-mvar-var"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{}{\Gamma\vdash M(\vec{x})=_{q}x_{i}:M(1,\dots,m)\mapsto i\dashv\Gamma\backslash\{M\}}
\]

\end_inset


\end_layout

\begin_layout Standard
A symmetric rule must be introduced as well.
\end_layout

\begin_layout Subsection
Termination
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsect:termination"

\end_inset


\end_layout

\begin_layout Standard
This section is devoted to the proof of the following proposition.
\end_layout

\begin_layout Proposition
There is no infinite derivation tree of 
\begin_inset Formula $\Gamma\vdash\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Termination follows fro(WIP) m the fact that the premises of each rule either
 live in a smaller context, either live in a context with the same size
 and consider a subterm as input.
 In fact, this is not strictly true of the case 
\begin_inset Formula $M(\vec{x})=o(\vec{u})$
\end_inset

 (Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:case-mvar-op"
plural "false"
caps "false"
noprefix "false"

\end_inset

), since we replace 
\begin_inset Formula $M$
\end_inset

 with a list of new metavariables 
\begin_inset Formula $N_{i}$
\end_inset

, one for each argument of 
\begin_inset Formula $o$
\end_inset

.
 However, we can easily show that derivations trees of a unification problem
 are in one-to-one correspondance with deriviation trees of the same unification
 problem but in a weakened metavariable context.
 Then, the premise 
\begin_inset Formula $\begin{array}{c}
\Gamma\backslash\{M\},\vec{N}:m+\vec{n}\vdash N_{1}(0,\dots,n_{1}-1,x_{1}+n_{1},\dots,x_{m}+n_{1})=_{q+n_{1}}u_{1},\dots\Rightarrow\sigma\dashv\Delta\end{array}$
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
McBride's argument (recursion on the number of metavariables) does not apply
 here because he does not recursively unify in the flexRigid case, while
 we introduce new metavariables there.
 Otherwise, Cf Dale Miller's Theorem 7.1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The main difficulty to show termination is that the case 
\begin_inset Formula $M(\vec{x})=o(\vec{u})$
\end_inset

 involves a recursive call with an extended context, while all the other
 rules are reducing or keeping the same context size.
\begin_inset Note Note
status open

\begin_layout Plain Layout
One way to solve this issue consists in avoiding creating new metavariables.
 Instead, we could first (potentially) reduce the arities of metavariables
 appearing in 
\begin_inset Formula $o(\vec{u})$
\end_inset

 so that they don't refer to free variables outside 
\begin_inset Formula $\vec{x}$
\end_inset

 and then directly instantiate 
\begin_inset Formula $M$
\end_inset

 with the resulting term.
 This seems to be a bit tedious to describe precisely (not to mention to
 prove correctness).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It turns out that after encountering the case 
\begin_inset Formula $M(\vec{x})=o(\vec{u})$
\end_inset

, the algorithm virtually enters a 
\begin_inset Quotes eld
\end_inset

pruning
\begin_inset Quotes erd
\end_inset

 phase where the left handsides will always be distinct metavariables that
 don't appear in the right handsides.
 We say that the unification problem is 
\emph on
directed
\emph default
 if it is of this shape.
\end_layout

\begin_layout Lemma
If there is a finite derivation of 
\begin_inset Formula $\Gamma\vdash\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

 where 
\begin_inset Formula $\vec{t}=\vec{u}$
\end_inset

 is directed, then all the involved nodes are directed..
\end_layout

\begin_layout Standard
The difficult case is the stepwise rule.
 It relies on the following lemma.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:dir-unified-subst"

\end_inset

Let 
\begin_inset Formula $\Gamma\vdash t_{0},\vec{t}=u_{0},\vec{u}$
\end_inset

 be a directed unification problem, and assume given a finite derivation
 tree 
\begin_inset Formula $\Gamma\vdash t_{0}=u_{0}\Rightarrow\sigma\dashv\Delta$
\end_inset

.
 Then, 
\begin_inset Formula $\vec{t}[\sigma]=\vec{u}[\sigma]$
\end_inset

 is directed.
\end_layout

\begin_layout Standard
This in turn requires the following lemma proved by induction.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:output-preserves-unused"

\end_inset

Assume there is a finite derivation of 
\begin_inset Formula $\Gamma,\Gamma'\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

, such that metavariables in 
\begin_inset Formula $\vec{t}$
\end_inset

,
\begin_inset Formula $\vec{u}$
\end_inset

 are in 
\begin_inset Formula $\Gamma$
\end_inset

.
 Then, there exists 
\begin_inset Formula $\Delta'$
\end_inset

 such that 
\begin_inset Formula $\Delta\simeq\Delta',\Gamma'$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 through this isomorphism, is of the shape 
\begin_inset Formula $\sigma'+id_{\Gamma'}$
\end_inset

.
 In other words, the output substitution preserves any unused metavariable
 and never use them for instantiation otherwise.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
At least if I don't manage to find a proper proof for the previous lemma
 (it would be nice, though), the following one can be proved easily, I think.
\end_layout

\begin_layout Lemma
Assume there is a finite derivation of 
\begin_inset Formula $\Gamma,\Gamma'\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

, such that metavariables in 
\begin_inset Formula $\vec{t}$
\end_inset

,
\begin_inset Formula $\vec{u}$
\end_inset

 are in 
\begin_inset Formula $\Gamma$
\end_inset

.
 Then, there is a finite derivation of 
\begin_inset Formula $\Gamma'\vdash\vec{t}=\vec{u}\Rightarrow\sigma'\dashv\Delta'$
\end_inset

 such that 
\begin_inset Formula $\Delta\simeq\Delta',\Gamma'$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 is 
\begin_inset Formula $\sigma'+id_{\Gamma'}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout

[Proof of Lemma~
\backslash
ref{lem:dir-unified-subst}]
\end_layout

\end_inset

Note that a directed unification problem 
\begin_inset Formula $\vec{t}=\vec{u}$
\end_inset

 corresponds to a diagram in 
\begin_inset Formula $\Kl T$
\end_inset

 of the shape
\begin_inset Formula 
\[
\xymatrix{ & \coprod_{i}B_{i}\ar@{^{(}->}[dr]\\
\coprod_{i}A_{i}\ar[ru]^{\vec{t}}\ar[dr]_{\vec{u}} &  & C+\coprod_{i}B_{i}\\
 & C\ar@{^{(}->}[ru]
}
\]

\end_inset

In particular, a directed unification problem 
\begin_inset Formula $t_{0},\vec{t}=u_{0},\vec{u}$
\end_inset

 has this shape:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
\xymatrix{ & B+\coprod_{i}B_{i}\ar@{^{(}->}[dr]\\
A+\coprod_{i}A_{i}\ar[ru]^{t_{0}+\vec{t}}\ar[dr]_{[u_{0},\vec{u}]} &  & C+B+\coprod_{i}B_{i}\\
 & C\ar@{^{(}->}[ru]
}
\]

\end_inset


\end_layout

\begin_layout Proof
The most general unifier of 
\begin_inset Formula $t_{o}$
\end_inset

 and 
\begin_inset Formula $u_{0}$
\end_inset

 corresponds to the coequaliser of
\begin_inset Formula 
\[
\xymatrix{ & B\ar@{^{(}->}[rdr]\\
A\ar[ru]^{t_{0}}\ar[dr]_{u_{0}} &  &  & C+B+\coprod_{i}B_{i}\\
 & C\ar@{^{(}->}[rru]
}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
which can be computed as first taking the coequaliser
\end_layout

\end_inset


\end_layout

\begin_layout Proof
By Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:output-preserves-unused"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the coequaliser computed by the derivation of 
\begin_inset Formula $\Gamma\vdash t_{0}=u_{0}\Rightarrow\sigma\dashv\Delta$
\end_inset

 has the shape 
\begin_inset Formula 
\[
\xymatrix{ & B\ar@{^{(}->}[rdr]\\
A\ar[ru]^{t_{0}}\ar[dr]_{u_{0}} &  &  & C+B+\coprod_{i}B_{i}\ar[rr]^{\sigma'+\coprod_{i}B_{i}} &  & \Delta'+\coprod_{i}B_{i}\\
 & C\ar@{^{(}->}[rru]
}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(oui mais qu'est ce qu'il me prouve que ce coegalisateur est fabrique ainsi?)
 lemme: si 
\begin_inset Formula $\sigma$
\end_inset

 est l'unifier general de 
\begin_inset Formula $\vec{t}$
\end_inset

 et 
\begin_inset Formula $\vec{u}$
\end_inset

 dans un contexte etendu, l'unifier general dans le contexte normal existe.
 Lemme: le unifier est epi pw sauf en la composante 0.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{ & B\ar@{^{(}->}[rd]\\
A\ar[ru]^{t_{0}}\ar[dr]_{u_{0}} &  & C+B\ar[r] & D\\
 & C\ar@{^{(}->}[ru]
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
and then taking the coproduct 
\begin_inset Formula $C+B+\coprod_{i}B_{i}\rightarrow D+\coprod_{i}B_{i}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
Now, 
\begin_inset Formula $\vec{t}[\sigma]=\vec{u}[\sigma]$
\end_inset

 corresponds to the diagram
\begin_inset Formula 
\[
\xymatrix{ & \coprod_{i}B_{i}\ar@{^{(}->}[rrd]\\
\coprod_{i}A_{i}\ar[ru]^{\vec{t}}\ar[dr]_{\vec{u}} &  &  & \Delta'+\coprod_{i}B_{i}\\
 & C\ar@{->}[r] & \Delta'\ar@{^{(}->}[ru]
}
\]

\end_inset

which is indeed directed.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Now we can prove easily
\end_layout

\begin_layout Lemma
If there is a finite derivation tree of 
\begin_inset Formula $\Gamma\vdash\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

, then
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $|\Gamma|\geq|\Delta|$
\end_inset


\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $|\Gamma|=|\Delta|$
\end_inset

, then 
\begin_inset Formula $\sigma$
\end_inset

 is a renaming, in the sense that it instantiates metavariables with metavariabl
es.
\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $\vec{t}=\vec{u}$
\end_inset

 is directed, then 
\begin_inset Formula $|\Gamma|=|\Delta|+|\vec{t}|$
\end_inset

, where 
\begin_inset Formula $|\vec{t}|$
\end_inset

 is the length of 
\begin_inset Formula $\vec{t}$
\end_inset

, as a list.
\end_layout

\end_deeper
\begin_layout Standard
Finally, to prove termination, we consider the lexicographic order induced
 by the context size and the size of the involved terms to each judgement
 
\begin_inset Formula $\Gamma\vdash\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

.
 More precisely, 
\end_layout

\begin_layout Itemize
the context size is defined as the length of 
\begin_inset Formula $\Gamma$
\end_inset

 if it is not directed, or as the total number of metavariables involved
 in the right handsides otherwise.
 
\end_layout

\begin_layout Itemize
the size of a non empty term list 
\begin_inset Formula $||\vec{t}||$
\end_inset

 is defined as 
\begin_inset Formula $|\vec{t}|-1+\Sigma_{i}||t_{i}||$
\end_inset


\end_layout

\begin_layout Itemize
the size of a term 
\begin_inset Formula $||o(\vec{t})||$
\end_inset

 is defined as 
\begin_inset Formula $1+||\vec{t}||$
\end_inset

, and 
\begin_inset Formula $||M||=||x||=0$
\end_inset

.
\end_layout

\begin_layout Standard
It is easy to show that each recursive call is decreasing with respect to
 this order.
 The crucial point, in the stepwise rule, is the following lemma.
\end_layout

\begin_layout Lemma
If 
\begin_inset Formula $\sigma$
\end_inset

 is a renaming, then 
\begin_inset Formula $||t[\sigma]||=||t||$
\end_inset

.
\end_layout

\begin_layout Section
Higher-order pattern unification
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:higher-order-unification"

\end_inset


\end_layout

\begin_layout Standard
In this section, we recall higher-order pattern unification introduced in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

 and discuss the differences with our setting.
 We also sketch how to encode pattern unification problems in our setting
 extended to the simply-typed case.

\color red
 It would be nice to compare our categorical proof with
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Higher-order pattern unification focuses on unifying a pair of closed simply-typ
ed lambda-terms with metavariables applied to distinct variables.
 Lambda-terms are considered in 
\begin_inset Formula $\beta$
\end_inset

-short 
\begin_inset Formula $\eta$
\end_inset

-long normal forms, except for metavariables arguments which are not 
\begin_inset Formula $\eta$
\end_inset

-expanded (they are metavariables).
 Roughly, the syntax of terms goes as follows.
\begin_inset Formula 
\[
t::=\lambda(x:\tau).t|x\vec{t}|M\vec{x}
\]

\end_inset

with a standard typing judgement, with types generated from a set of base
 types 
\begin_inset Formula $B$
\end_inset

 typically denoted by 
\begin_inset Formula $b$
\end_inset

 (we mix metavariables and free variables in the same context 
\begin_inset Formula $\Gamma$
\end_inset

 for concision):
\begin_inset Formula 
\begin{align*}
\dfrac{x:\vec{\tau}\Rightarrow b\in\Gamma\quad\Gamma\vdash\vec{t}:\vec{\tau}}{\Gamma\vdash x\vec{t}}\qquad\dfrac{M:\vec{\tau}\Rightarrow b\in\Gamma\quad\vec{x}:\vec{\tau}\in\Gamma}{\Gamma\vdash M\vec{t}}\qquad\dfrac{\Gamma,x:\tau\vdash t:\tau'}{\Gamma\vdash\lambda(x:\tau).t:\tau\Rightarrow\tau'}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
On the surface, our setting looks quite different in may respects:
\end_layout

\begin_layout Itemize
we do not focus on simply-typed lambda calculus quotiented by 
\begin_inset Formula $\beta\eta$
\end_inset

-equivalence, but on any second-order syntax specified by a binding signature
 
\begin_inset Formula $\Sigma$
\end_inset

, without any equation;
\end_layout

\begin_layout Itemize
we work in the untyped case.
\end_layout

\begin_layout Itemize
our unification problem can involve open terms.
\end_layout

\begin_layout Standard
If we forget about the types, we can translate unification problems back
 and forth, as we show in the following sections.
\end_layout

\begin_layout Standard
Let us first note that the syntax of normal terms clearly embeds into untyped
 lambda-calculus without 
\begin_inset Formula $\beta\eta$
\end_inset

-equivalence, as specified by a binding signature, and so our unification
 algorithm applies.
 What we should additionnally show is that the output substitution preserves
 typing and do not creates any redex.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Let us first note that if we remove the toplevel abstractions, then normal
 terms embeds in the following syntax.
\begin_inset Formula 
\[
t::=x\overrightarrow{(\lambda\vec{x}.t)}|M\vec{x}
\]

\end_inset

Clearly, this inductive definition can be specified by a binding signature,
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Encoding our unification problems
\end_layout

\begin_layout Standard
We do the case of a single term pair 
\begin_inset Formula $\Gamma\vdash t=_{q}u$
\end_inset

.
 By 
\begin_inset Formula $\lambda$
\end_inset

-abstracting over the metavariable context and the 
\begin_inset Formula $q$
\end_inset

 free variables, we get a higher-order pattern unification problem 
\begin_inset Formula $\lambda\Gamma\lambda0..\lambda(q-1).t=\lambda\Gamma\lambda0..\lambda(q-1).u$
\end_inset

.
\end_layout

\begin_layout Subsection
Encoding pattern unification problems
\end_layout

\begin_layout Standard
Clearly the previous encoding only generate pattern unification problem
 involving at most second-order types (for metavariables).
\end_layout

\begin_layout Standard
However, it turns out that the syntax of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus in 
\begin_inset Formula $\beta$
\end_inset

-short 
\begin_inset Formula $\eta$
\end_inset

-long form can be described by a simply-typed binding signature.
 The idea is that for each simple type 
\begin_inset Formula $\vec{\tau}\Rightarrow b$
\end_inset

, we have an application operation 
\begin_inset Formula $-@-:(\vec{\tau}\Rightarrow b)\times[\vec{\tau}]\rightarrow b$
\end_inset

, where 
\begin_inset Formula $[\vec{\tau}]:=[\tau_{1}]\times\dots[\tau_{n}]$
\end_inset

 and 
\begin_inset Formula $[\vec{\tau}\Rightarrow b]:=b^{\vec{\tau}}$
\end_inset

.
 Let 
\begin_inset Formula $T$
\end_inset

 be the (finitary) monad on 
\begin_inset Formula $Set^{S}$
\end_inset

 generated by this signature, where 
\begin_inset Formula $S$
\end_inset

 is the set of simple types.
 Then, the set of closed 
\begin_inset Formula $\lambda$
\end_inset

-terms of type 
\begin_inset Formula $\vec{\tau}\Rightarrow b$
\end_inset

 is isomorphic to 
\begin_inset Formula $T(\vec{\tau})_{b}$
\end_inset

, where 
\begin_inset Formula $\vec{\tau}$
\end_inset

 is thought of as a family 
\begin_inset Formula $S\rightarrow Set$
\end_inset

.
 TODO find references.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\Lambda_{\vec{\tau}\Rightarrow b}\simeq T_{b}^{(\vec{\tau})}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Comparison with 
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Notes: in the simply typed setting with set of types 
\begin_inset Formula $S$
\end_inset

, the free 
\begin_inset Formula $\Sigma$
\end_inset

-monoid monad acts on 
\begin_inset Formula $[I/S\times S,Set]$
\end_inset

, where 
\begin_inset Formula $I:\mathbb{\mathbb{N}}\rightarrow Set$
\end_inset

 is the canonical inclusion.
 Or 
\begin_inset Formula $[\mathbb{N}_{f}^{S}\times S,Set]$
\end_inset

 where the subscript 
\begin_inset Formula $f$
\end_inset

 means we restrict to finite families.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\Lambda$
\end_inset

 be the monad on 
\begin_inset Formula $[\mathbb{N}_{f}^{S}\times S,Set]$
\end_inset

 generating 
\begin_inset Formula $\lambda$
\end_inset

-terms modulo 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

 with metavariables.
\end_layout

\begin_layout Standard
Pat is 
\begin_inset Formula $\mathbb{F}_{inj,f}^{S}$
\end_inset

.
 The category of substitutions Sub is again the second-order algebraic theory
 of 
\begin_inset Formula $\Lambda$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $Tm(\Gamma,\Delta,\tau)$
\end_inset

 is 
\begin_inset Formula $\Lambda(\Gamma)_{\Delta,\tau}$
\end_inset

.
 A term is a 
\begin_inset Formula $y(\Gamma,\Delta,\tau)\rightarrow Tm(\Gamma,\Delta,\tau)$
\end_inset

.
 Ou alors, 
\begin_inset Formula $y(\Delta,\tau)\rightarrow Tm(\Gamma,-,-)$
\end_inset

 et la on se rapproche de mon idee.
 TODO: prouver que les conversions preservent la condition.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "bib"
options "plain"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Free 
\begin_inset Formula $T$
\end_inset

-algebras preserve pullbacks
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:free-talg-pullback"

\end_inset


\end_layout

\begin_layout Standard
In this section we show that renaming turn free 
\begin_inset Formula $T$
\end_inset

-algebras into functors 
\begin_inset Formula $\mathbb{F}\rightarrow Set$
\end_inset

 preserving pullbacks.
 In fact, we are going to show it for the initial 
\begin_inset Formula $T$
\end_inset

-algebra, since a free 
\begin_inset Formula $T$
\end_inset

-algebra on 
\begin_inset Formula $X\in Set^{\mathbb{N}}$
\end_inset

 is equivalently the initial 
\begin_inset Formula $\Sigma'$
\end_inset

-monoid, for 
\begin_inset Formula $\Sigma'$
\end_inset

 the binding signature extending 
\begin_inset Formula $\Sigma$
\end_inset

 with first order operations as specified by 
\begin_inset Formula $X$
\end_inset

.
\end_layout

\begin_layout Standard
Let us first explain where renaming comes from.
 Every binding signature 
\begin_inset Formula $\Sigma$
\end_inset

 induces an endofunctor on 
\begin_inset Formula $Set^{\mathbb{N}}$
\end_inset

 that we still denote by 
\begin_inset Formula $\Sigma$
\end_inset

.
 For example, in the case of 
\begin_inset Formula $\lambda$
\end_inset

-calculus, 
\begin_inset Formula $\Sigma(X)_{n}=X_{n}\times X_{n}+X_{n+1}$
\end_inset

.
 
\end_layout

\begin_layout Lemma
Denoting 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 the free monad 
\begin_inset Formula $\Sigma^{*}X=\mu Z.X+\Sigma(Z)$
\end_inset

 induced by a binding signature 
\begin_inset Formula $\Sigma$
\end_inset

, the initial 
\begin_inset Formula $\Sigma$
\end_inset

-monoid is 
\begin_inset Formula $\Sigma^{*}I$
\end_inset

.
\end_layout

\begin_layout Proof
See 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 2.15"
key "BHL"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
Given a binding signature 
\begin_inset Formula $\Sigma$
\end_inset

, the free monad 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 lifts to the category 
\begin_inset Formula $Set^{\mathbb{F}}$
\end_inset

.
 Denoting 
\begin_inset Formula $\underline{I}$
\end_inset

 the canonical embedding 
\begin_inset Formula $\mathbb{F}\rightarrow Set$
\end_inset

, renaming on 
\begin_inset Formula $\Sigma^{*}I$
\end_inset

 is given by the renaming structure on 
\begin_inset Formula $\Sigma^{*}\underline{I}$
\end_inset

.
\end_layout

\begin_layout Proof
Renaming on 
\begin_inset Formula $\Sigma^{*}I$
\end_inset

 is induced by substitution.
 Substitution on 
\begin_inset Formula $\Sigma^{*}I$
\end_inset

 induced by a monoid structure on them (for a monoidal structure on 
\begin_inset Formula $Set^{\mathbb{F}}$
\end_inset

 or 
\begin_inset Formula $Set^{\mathbb{N}}$
\end_inset

, as in 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/corr/AltenkirchCU14"
literal "false"

\end_inset

) induced by a strength 
\begin_inset Formula $\Sigma(A)\otimes B\rightarrow\Sigma(A\otimes B)$
\end_inset

.
\end_layout

\begin_layout Proof
TODO
\end_layout

\begin_layout Lemma
The previous lemma induces a functor 
\begin_inset Formula $\mathcal{U}:\Kl T\rightarrow Set^{\mathbb{F}}$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Proof
One crucial feature of 
\begin_inset Formula $\Sigma$
\end_inset

 to define substitution (and in particular renaming) is that it comes equipped
 with a strength 
\begin_inset Formula $\Sigma(A)\otimes B\rightarrow\Sigma(A\otimes B)$
\end_inset

, where the monoidal product is given by 
\begin_inset Formula $Lan_{I}A\circ B$
\end_inset

, ,.
 Let us denote by 
\begin_inset Formula $\mathbf{p}$
\end_inset

 the monad 
\begin_inset Formula $-\otimes I$
\end_inset

, which is the free renaming monad: 
\begin_inset Formula $\mathbf{p}(X)_{n}=\sum_{p}X_{n}\times p^{n}$
\end_inset

, so that the category of functors 
\begin_inset Formula $\mathbb{F}\rightarrow Set$
\end_inset

 is equivalent to the category of 
\begin_inset Formula $\boldsymbol{p}$
\end_inset

-algebras.
\end_layout

\begin_layout Proof
But thanks to the strength, 
\begin_inset Formula $\Sigma$
\end_inset

 lifts to the category of 
\begin_inset Formula $\boldsymbol{p}$
\end_inset

-algebras, through the natural transformation 
\begin_inset Formula $\boldsymbol{p}\Sigma\rightarrow\Sigma\boldsymbol{p}$
\end_inset

.
 Moreover, 
\begin_inset Formula $\boldsymbol{p}$
\end_inset

 has a right adjoint 
\begin_inset Formula $\boldsymbol{q}=(Ran_{I}-)\circ I$
\end_inset

.
 Then, the lifting induces a monadic distributive law 
\begin_inset Formula $\boldsymbol{p}\Sigma^{*}\rightarrow\Sigma^{*}\boldsymbol{p}$
\end_inset

, as the transpose along the adjunction 
\begin_inset Formula $\mathbf{p}\dashv\boldsymbol{q}$
\end_inset

 of the universal monad morphism induced by 
\begin_inset Formula $\Sigma\rightarrow\mathbf{q}\Sigma\boldsymbol{p}\rightarrow\mathbf{q}\Sigma^{*}\boldsymbol{p}$
\end_inset

.
 As a consequence, 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 lifts on the category of 
\begin_inset Formula $\mathbf{p}$
\end_inset

-algebras.
 Now, note that 
\begin_inset Formula $I$
\end_inset

 has a canonical renaming structure, so is equipped with a 
\begin_inset Formula $\mathbf{p}$
\end_inset

-algebra structure.
 As a consequence, 
\begin_inset Formula $\Sigma^{*}I$
\end_inset

 inherits a 
\begin_inset Formula $\mathbf{p}$
\end_inset

-algebra structure.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
One crucial feature of 
\begin_inset Formula $\Sigma$
\end_inset

 to define substitution (and in particular renaming) is that it comes equipped
 with a strength 
\begin_inset Formula $\Sigma(A)\otimes B\rightarrow\Sigma(A\otimes B)$
\end_inset

, where the monoidal product is given by 
\begin_inset Formula $Lan_{I}A\circ B$
\end_inset

, ,.
 Let us denote by 
\begin_inset Formula $\mathbf{p}$
\end_inset

 the monad 
\begin_inset Formula $-\otimes I$
\end_inset

, which is the monad that freely adds renamings (
\begin_inset Formula $\mathbf{p}(X)_{n}=\sum_{p}X_{n}\times p^{n}$
\end_inset

, so that the category of functors 
\begin_inset Formula $\mathbb{F}\rightarrow Set$
\end_inset

 is equivalent to the category of 
\begin_inset Formula $\boldsymbol{p}$
\end_inset

-algebras.
\end_layout

\begin_layout Plain Layout
But thanks to the strength, 
\begin_inset Formula $\Sigma$
\end_inset

 lifts to the category of 
\begin_inset Formula $\boldsymbol{p}$
\end_inset

-algebras, through the natural transformation 
\begin_inset Formula $\boldsymbol{p}\Sigma\rightarrow\Sigma\boldsymbol{p}$
\end_inset

.
 Moreover, 
\begin_inset Formula $\boldsymbol{p}$
\end_inset

 has a right adjoint 
\begin_inset Formula $\boldsymbol{q}=(Ran_{I}-)\circ I$
\end_inset

.
 Then, the lifting induces a monadic distributive law 
\begin_inset Formula $\boldsymbol{p}\Sigma^{*}\rightarrow\Sigma^{*}\boldsymbol{p}$
\end_inset

, as the transpose along the adjunction 
\begin_inset Formula $\mathbf{p}\dashv\boldsymbol{q}$
\end_inset

 of the universal monad morphism induced by 
\begin_inset Formula $\Sigma\rightarrow\mathbf{q}\Sigma\boldsymbol{p}\rightarrow\mathbf{q}\Sigma^{*}\boldsymbol{p}$
\end_inset

.
 As a consequence, 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 lifts on the category of 
\begin_inset Formula $\mathbf{p}$
\end_inset

-algebras.
 Now, note that 
\begin_inset Formula $I$
\end_inset

 has a canonical renaming structure, so is equipped with a 
\begin_inset Formula $\mathbf{p}$
\end_inset

-algebra structure.
 As a consequence, 
\begin_inset Formula $\Sigma^{*}I$
\end_inset

 inherits a 
\begin_inset Formula $\mathbf{p}$
\end_inset

-algebra structure.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What remains to show is that this renaming preserves pullbacks.
 Let us reason on the category 
\begin_inset Formula $Set^{\mathbb{F}}$
\end_inset

 on which 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 lifts, as we just argued.
 Now, 
\begin_inset Formula $\Sigma^{*}I$
\end_inset

 is computed as the initial algebra of 
\begin_inset Formula $H:Set^{\mathbb{F}}\rightarrow Set^{\mathbb{F}}$
\end_inset

 mapping 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $I+\Sigma(X)$
\end_inset

.
 This means that 
\begin_inset Formula $\Sigma^{*}I$
\end_inset

 is the colimit over the initial 
\begin_inset Formula $\omega$
\end_inset

-chain
\begin_inset Formula 
\[
\emptyset\rightarrow H(\emptyset)\rightarrow\dots\rightarrow H..H(..(\emptyset..))\rightarrow\dots
\]

\end_inset

Since pullback preserving functors are preserved by filtered colimits (as
 filtered colimits commute with finite limits), it is enough to show that
 each functor 
\begin_inset Formula $H^{\circ n}(\emptyset)$
\end_inset

 preseves pullbacks, which again amounts to showing that 
\begin_inset Formula $H$
\end_inset

 preserves functors preservings pullbacks.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Before that, we introduce a useful characterising lemma for endofunctors
 induced by a binding signature.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For 
\begin_inset Formula $\lambda$
\end_inset

-calculus, 
\begin_inset Formula $K(F)=F_{0}\times F_{0}\coprod F_{1}$
\end_inset

.
 Since coproducts commute with connected limits, 
\begin_inset Formula $K$
\end_inset

 indeed preserves conneced limits.
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
The endofunctor 
\begin_inset Formula $H:Set^{\mathbb{F}}\rightarrow Set^{\mathbb{F}}$
\end_inset

 maps functors preserving pullbacks to functors preserving pullbacks.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $F$
\end_inset

 be a functor 
\begin_inset Formula $\mathbb{F}\rightarrow Set$
\end_inset

 preserving pullbacks.
 Let
\begin_inset Formula 
\[
\xymatrix{A\ar[r]\ar[d] & B\ar[d]\\
C\ar[r] & D
}
\]

\end_inset

be a pullback in 
\begin_inset Formula $\mathbb{F}$
\end_inset

.
 Let us show that the following square is a pullback.
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
\xymatrix{H(F)_{A}\ar[r]\ar[d] & H(F)_{B}\ar[d]\\
H(F)_{C}\ar[r] & H(F)_{D}
}
\]

\end_inset

Since pullbacks commute with coproducts in 
\begin_inset Formula $Set$
\end_inset

, this is enough to show that the following square is a pullback
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
\xymatrix{\Sigma(F)_{A}\ar[r]\ar[d] & \Sigma(F)_{B}\ar[d]\\
\Sigma(F)_{C}\ar[r] & \Sigma(F)_{D}
}
\]

\end_inset

This follows from the fact that 
\begin_inset Formula $\Sigma(F)$
\end_inset

 is isomorphic to some 
\begin_inset Formula $\coprod_{i}F^{(\vec{n_{i}})}$
\end_inset

, and coproducts commute with connected limits.
\end_layout

\begin_layout Notation
Let 
\begin_inset Formula $Set_{p}^{\mathbb{F}}$
\end_inset

 be the full subcategory of functors preserving pullbacks.
\end_layout

\begin_layout Lemma
The functor 
\begin_inset Formula $\mathbb{N}\xrightarrow{y}Set^{\mathbb{N}}\rightarrow\Kl T$
\end_inset

 extends to a functor 
\begin_inset Formula $\mathbf{y}:\mathbb{F}^{o}\rightarrow\Kl T$
\end_inset

 such that 
\begin_inset Formula $Kl_{T}({\bf y}m,X)\simeq Set_{p}^{\mathbb{F}}(Jm,TX)$
\end_inset

 is natural in 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Proof
The isomorphism 
\begin_inset Formula $Kl_{T}(ym,X)\simeq TX_{m}\simeq Set^{\mathbb{F}}(Jm,TX)$
\end_inset

 means that the following diagram commutes up to isomorphism
\begin_inset Formula 
\[
\xymatrix{\mathbb{N}\ar[d]\ar[r]^{y} & (Set^{\mathbb{N}})^{o}\ar[rr] &  & \Kl T^{o}\ar[d]^{y}\\
\mathbb{F}\ar[r]_{y} & (Set^{\mathbb{F}})^{o}\ar[r]_{y} & Set^{Set^{\mathbb{F}}}\ar[r]_{Set^{\mathcal{U}}} & Set^{\Kl T}
}
\]

\end_inset

where 
\begin_inset Formula $y$
\end_inset

 denotes the yoneda embedding.
 Since the left vertical morphism is bijective on objects and the right
 vertical morphism is full and faithful, there is a filling of this square
 
\begin_inset Formula $\mathbf{y}:\mathbb{F}^{o}\rightarrow\Kl T$
\end_inset

 making triangles both commute up to isomorphism (TODO: find references)
\end_layout

\begin_layout Remark
Another way to define 
\begin_inset Formula $\mathbf{y}$
\end_inset

 goes as follows.
 There is a 
\begin_inset Formula $\Sigma$
\end_inset

-monoid monad 
\begin_inset Formula $T'$
\end_inset

 on 
\begin_inset Formula $Set^{\mathbb{F}}$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

 is actually isomorphic to 
\begin_inset Formula $RT'L$
\end_inset

, where 
\begin_inset Formula $L$
\end_inset

 is the left Kan extension and 
\begin_inset Formula $R$
\end_inset

 its right adjoint (precomposition by 
\begin_inset Formula $\mathbb{N}\rightarrow\mathbb{F}$
\end_inset

).
 As a consequence, there is a fully faithful Kleisli extension 
\begin_inset Formula 
\[
\xymatrix{Set^{\mathbb{N}}\ar[d]\ar[r]^{L} & Set^{\mathbb{F}}\ar[d]\\
\Kl T\ar[r] & \Kl{T'}
}
\]

\end_inset


\end_layout

\begin_layout Remark
Then, we can define 
\begin_inset Formula $\mathbf{y}$
\end_inset

 as filling the square
\begin_inset Formula 
\[
\xymatrix{\mathbb{N}\ar[d]\ar[r] & \Kl T^{o}\ar[d]\\
\mathbb{F}\ar[r] & \Kl{T'}^{o}
}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
Given a morphism 
\begin_inset Formula $f:m\rightarrow n$
\end_inset

 in 
\begin_inset Formula $\mathbb{F}$
\end_inset

, the induced morphism 
\begin_inset Formula $\mathbf{y}f:yn\rightarrow T(ym)$
\end_inset

 selects the term 
\begin_inset Formula $t\in T(ym)_{n}$
\end_inset

 defined as renaming the canonical term 
\begin_inset Formula $M(0,\dots,m-1)\in T(ym)_{m}$
\end_inset

, corresponding to the unit 
\begin_inset Formula $ym\rightarrow T(ym)$
\end_inset

, along 
\begin_inset Formula $f$
\end_inset

.
 In other words, 
\begin_inset Formula $\mathbf{y}f$
\end_inset

 selects the term 
\begin_inset Formula $M(f_{0},\dots f_{m-1})$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:y-preserves-connected"

\end_inset


\begin_inset Formula ${\bf y}^{o}:\mathbb{F}\rightarrow\Kl T^{o}$
\end_inset

 preserves pullbacks, hence finite connected limits.
\end_layout

\begin_layout Proof
We have a natural isomorphism 
\begin_inset Formula $Kl_{T}({\bf y}m,X)\simeq Set_{p}^{\mathbb{F}}(Jm,TX)$
\end_inset

, where 
\begin_inset Formula $J$
\end_inset

 is the yoneda embedding in 
\begin_inset Formula $\mathbb{F}^{o}\rightarrow Set^{\mathbb{F}}$
\end_inset

: 
\begin_inset Formula $Jn_{m}=m^{n}$
\end_inset

.
 It follows that 
\begin_inset Formula $\mathbf{y}$
\end_inset

 preserves any colimit that 
\begin_inset Formula $J$
\end_inset

 preserves.
 Now, since 
\begin_inset Formula $J$
\end_inset

 is the yoneda embedding, 
\begin_inset Formula $J$
\end_inset

 preserves pullbacks, as we restrict to the category of presheaves preserving
 pullbacks.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "lem:mono-epi"

\end_inset

Let 
\begin_inset Formula $f:p\rightarrow q$
\end_inset

 be an injective map.
 Then, the induced map 
\begin_inset Formula $\mathbf{y}f:yq\rightarrow T(yp)$
\end_inset

 is epimorphic.
\end_layout

\begin_layout Proof
The proof follows from Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:y-preserves-connected"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by noting that 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 is monomorphic if and only if the following square is a pullback.
\begin_inset Formula 
\[
\xymatrix{A\ar[r]^{id}\ar[d]_{id} & A\ar[d]^{f}\\
A\ar[r]_{f} & B
}
\]

\end_inset


\end_layout

\begin_layout Remark
Such an epimorphism may not be induce a surjection 
\begin_inset Formula $\mathbf{y}f^{*}:T(yq)\rightarrow T(yp)$
\end_inset

, even when.
 For example, consider the initial map 
\begin_inset Formula $0\rightarrow1$
\end_inset

, inducing 
\begin_inset Formula $T(y1)\rightarrow T(y0)$
\end_inset

, morally mapping the unary metavariable 
\begin_inset Formula $M(x)$
\end_inset

 to the constant metavariable 
\begin_inset Formula $N$
\end_inset

.
 If there is closed term, then 
\begin_inset Formula $N\in T(y0)_{0}$
\end_inset

 has no preimage.
 
\end_layout

\begin_layout Section
Separating the pruning phase
\end_layout

\begin_layout Standard
(WIP) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In the algorithm we have presented, we endeavoured to minimise the number
 of inference rules.
 
\end_layout

\end_inset

Here we present another algorithm which does justice to the so-called pruning
 phase mentioned in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsect:termination"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The benefit is that termination is easier to prove, at the cost of three
 more rules to prove correctness of.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: try Ilya's weaker directed condition (when one of the handside is
 a metavariable)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We introduce a new
\emph on
 pruning 
\emph default
judgement (as usual, the arrows mean lists)
\begin_inset Formula 
\[
\Gamma\vdash\directed{\vec{x_{1}}}{t_{1}}{q_{1}},\dots,\directed{\vec{x_{n}}}{t_{n}}{q_{n}}\Rightarrow\sigma\dashv\Delta
\]

\end_inset

 abbreviated as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Gamma\vdash\overrightarrow{\directed{\vec{x}}tq}\Rightarrow\sigma\dashv\Delta
\]

\end_inset

where 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\vec{x}$
\end_inset

 is a list of distinct variables in 
\begin_inset Formula $q$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $t$
\end_inset

 is a term in 
\begin_inset Formula $T\Gamma_{q}$
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $u_{i}\in T\Delta_{|\vec{x}|}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma:\Gamma\rightarrow T\Delta$
\end_inset

 is a renaming (it replaces metavariables with metavariables).
\end_layout

\begin_layout Standard
The idea is that 
\begin_inset Formula $\sigma$
\end_inset

 reduce the arguments of the metavariables in 
\begin_inset Formula $t$
\end_inset

 so that they don't mention any variable outside 
\begin_inset Formula $\vec{x}$
\end_inset

.
\end_layout

\begin_layout Standard
Let us give the correctness statement before giving the rules
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:correctness-directed"

\end_inset

Given 
\begin_inset Formula $\Gamma\vdash\overrightarrow{\directed{\vec{x}}tq}$
\end_inset

, there exists exactly one 
\begin_inset Formula $\sigma$
\end_inset

 and one 
\begin_inset Formula $\Delta$
\end_inset

 such that there exists a finite derivation tree of 
\begin_inset Formula $\Gamma\vdash\overrightarrow{\directed{\vec{x}}tq}\Rightarrow\sigma\dashv\Delta$
\end_inset

.
 Moreover, there exists 
\begin_inset Formula $u:y\vec{m}\rightarrow T(\Delta)$
\end_inset

 such that 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 is colimiting for the pushout diagram 
\begin_inset Formula 
\[
\xymatrix{ & T(y\vec{m})\\
y\vec{q}\ar[ru]^{\vec{\vec{x}}}\ar[dr]_{\vec{t}}\\
 & T(\Gamma)
}
\]

\end_inset

Note that such a 
\begin_inset Formula $u$
\end_inset

 is unique, by Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:mono-epi"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (indeed, it corresponds to 
\begin_inset Formula $\vec{t}$
\end_inset

 restricted to smaller free variable contexts).
\end_layout

\begin_layout Standard
The main point is that we can replace a few rules (three of them, in fact:
 
\begin_inset Formula $M=o(\vec{u})/x_{i}/N$
\end_inset

) with the following one:
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\ensuremath{M}\text{ does not occur in \ensuremath{t}}\\
\Gamma\backslash\{M\}\vdash\vec{x}=_{q}t\Rightarrow\sigma\dashv\Delta
\end{array}}{\Gamma\vdash M(\vec{x})=_{q}t\Rightarrow\sigma,M(1,\dots m)\mapsto t[\sigma]\dashv\Delta}
\]

\end_inset


\end_layout

\begin_layout Standard
Note that we know a posteriori that 
\begin_inset Formula $t[\sigma]$
\end_inset

 takes free variables in 
\begin_inset Formula $1,\dots m$
\end_inset

 by Proposition
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "prop:correctness-directed"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 To be more rigorous, we could make the algorithm outputs the 
\begin_inset Formula $u$
\end_inset

 mentionned in Proposition
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "prop:correctness-directed"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as well.
\end_layout

\begin_layout Standard
From the original algorithm, we need to keep the stepwise/empty rule, the
 cases 
\begin_inset Formula $M(\vec{x})=M(\vec{y})$
\end_inset

 and 
\begin_inset Formula $o(\vec{t})=o(\vec{u})$
\end_inset

.
\end_layout

\begin_layout Standard
We have the empty rule and the following stepwise rule
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash\vec{x_{0}}=_{n_{0}}t_{0}\Rightarrow\sigma_{0}\dashv\Delta_{1}\qquad\Delta_{1}\vdash\overrightarrow{\vec{x}=_{q}t[\sigma_{0}]}\Rightarrow\sigma\dashv\Delta_{2}\qquad\vec{t}\text{ is not empty}}{\Gamma\vdash t_{0}=_{n_{0}}u_{0},\vec{t}=_{\vec{n}}\vec{u}\Rightarrow\sigma\circ\sigma_{0}\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
Then, we have the cases 
\begin_inset Formula $M=o(\vec{u})/x_{i}/N$
\end_inset

, that we detail below.
 So, this version adds three more rules compared to the original algorithm.
\begin_inset Formula 
\begin{align*}
\dfrac{}{\Gamma\vdash\vec{x}=_{q}x_{i}:id\dashv\Gamma}\\
\\
\dfrac{\begin{array}{c}
o\text{ has binding arity \ensuremath{(n_{1},\dots,n_{p})}}\\
\Gamma\vdash0,\dots,n_{1}-1,\vec{x}+n_{1}=_{q+n_{1}}t_{1},\dots\Rightarrow\sigma\dashv\Delta
\end{array}}{\Gamma\vdash\vec{x}=_{q}o(\vec{t})\Rightarrow\sigma\dashv\Delta}\\
\\
\dfrac{(i_{1},\dots,i_{p})\text{\text{ and \ensuremath{(j_{1},\dots,j_{p})} are maximal such that \ensuremath{x_{\vec{i}}=y_{\vec{j}}}}}}{\Gamma\vdash\vec{x}=_{q}N(\vec{y})\Rightarrow N(1,\dots,n)\mapsto O(j_{1},\dots,j_{p})\dashv\Gamma\backslash\{N\},O:p}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Since the pruning judgement is standalone (it never switches to the non-directed
 judgement), we can prove its termination first.
 This is relatively easy, because the size of terms in the premises of each
 rule decrease (observing, in the stepwise rule, that renaming preserves
 the size).
 Then, to prove termination of the non-directed judgement, we note that
 the directed judgement preserves the size of the context.
 Then, the non-directed judgement either preserves the size of the context
 and ouputs a renaming, either strictly reduces its size.
\end_layout

\begin_layout Section
A structurally tail-recursive algorithm
\end_layout

\begin_layout Standard
WIP
\end_layout

\begin_layout Standard
The stepwise rules make the algorithm not tail-recursive.
 However, by taking an additional substitution as input as in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/jfp/McBride03"
literal "false"

\end_inset

, we can turn it into a tail-recursive algorithm.
 Moreover, in our case, this moreover enables structural recursion, by delaying
 the effects of renaming to the leaves.
\end_layout

\end_body
\end_document
