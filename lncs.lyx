#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass llncs
\begin_preamble
\usepackage{tikz-cd}
\usepackage{adjustbox}
\usepackage{quiver}
\newcommand{\Ker}{\mathrm{Ker}}
\usepackage{fullshort}

% to comment for the short version
\setboolean{fullpaper}{false}

\newcommand{\pullbackcorner}[1][dl]{\save*!/#1-1pc/#1:(-1,1)@^{|-}\restore}
\newcommand{\commentaire}[1]{}
\usepackage{cmll}

\makeatother
\newcommand{\coeqr}[2]{\ar@<+.5ex>[r]^-{#1}\ar@<-.5ex>[r]_-{#2}}
\makeatletter
\newcommand{\hautr}[1]{\ar[r]^-{#1}}
\newcommand{\hautl}[1]{\ar[l]_-{#1}}

% To be removed when submitting?
% it is to add bookmarks
% https://tex.stackexchange.com/questions/47383/no-pdf-bookmarks-when-using-llncs-class
\usepackage{etoolbox}
\makeatletter
\let\llncs@addcontentsline\addcontentsline
\patchcmd{\maketitle}{\addcontentsline}{\llncs@addcontentsline}{}{}
\patchcmd{\maketitle}{\addcontentsline}{\llncs@addcontentsline}{}{}
\patchcmd{\maketitle}{\addcontentsline}{\llncs@addcontentsline}{}{}
\setcounter{tocdepth}{2}
\makeatother
\usepackage{hyperref}
\usepackage{bookmark}

\newcommand{\vecif}[2]{\ifthenelse{\equal{#1}{}}{#2}{\vec{#2}}}

\newref{rem}{refcmd={Remark~\ref{#1}}}
\newrefformat{rem}{Remark~\ref{#1}}
\newref{def}{refcmd={Definition~\ref{#1}}}
\newrefformat{def}{Definition~\ref{#1}}
\newref{assu}{refcmd={Property~\ref{#1}}}
\newrefformat{assu}{Property~\ref{#1}}
\newref{cor}{refcmd={Corollary~\ref{#1}}}
\newref{lem}{refcmd={Lemma~\ref{#1}}}
\newref{prop}{refcmd={Proposition~\ref{#1}}}
\newref{nota}{refcmd={Notation~\ref{#1}}}
\newref{tab}{refcmd={Table~\ref{#1}}}
\newref{subsec}{refcmd={Section~\S\ref{#1}}}

%%%
%% from the paper quantum lambda
\usepackage{proof}

\newcommand{\ass}{:=}
\newcommand{\abs}[1]{|#1|}              
\newcommand{\homof}[2]{#1(#2)}          
\newcommand{\seq}{\subseteq}    
\newcommand{\such}{\,\,|\,\,}           
\newcommand{\pc}{\mathbin{;}}           
\newcommand{\id}{{\textrm{\rm id}}}     
\newcommand{\N}{\mathbb{N}}                     
\newcommand{\categ}[1]{\textrm{\bf #1}} 
\newcommand{\FV}{{\rm FV}}                      
\newcommand{\bang}{{!}}
\newcommand{\tensor}{\otimes}
\newcommand{\bor}{\ \ \rule[-.75ex]{.01in}{2.75ex}\ \ }  
%\newcommand{\C}{\mathbb{C}}                     
\newcommand{\Rp}{{\mathbb{R}^+}}                     
\newcommand{\sqleq}{\sqsubseteq}
\newcommand{\sqgeq}{\sqsupseteq}
\newcommand{\bit}{{\bf bit}}
\newcommand{\qubit}{{\bf qubit}}
\newcommand{\xmatrix}[4]{{\renewcommand{\arraystretch}{#1}%
\arraycolsep=#2ex\left(\begin{array}{#3}#4\end{array}\right)}}
\newcommand{\zmatrix}{\xmatrix{0.8}{0.8}}
\newcommand{\zzmatrix}[2]{{\textrm{\scriptsize$\zmatrix{#1}{#2}$}}}
\newcommand{\CPM}{\textrm{\bf CPM}}
\newcommand{\CPMs}{\textrm{\bf CPM}_s}
\newcommand{\inv}{^{-1}}
\newcommand{\freecat}[1][C]{\ensuremath{\categ{#1}^{\oplus}}}  
\newcommand{\cpms}{\categ{CPMs}} 
\newcommand{\ccpms}{\ensuremath{\overline{\categ{CPMs}}}} 
\newcommand{\M}{{\cal M}}
\newcommand{\supp}[1]{\vert #1\vert}   
\newcommand{\eq}[2][]{\mathop{eq^{#2}_{#1}}\nolimits} 
\newcommand*{\mystackrel}[2]{%
\stackrel{\raise-2pt\hbox{$\scriptstyle\!#1$}}{#2}}
\newcommand*{\redto}[1][]{\mystackrel{#1}{\rightarrow}}
\newcommand*{\xredto}[1][]{%
\xrightarrow{\raisebox{-2pt}{$\scriptstyle\!{#1}$}}}
\newcommand{\qfin}[1]{\mathfrak{#1}} 
\newcommand{\web}[1]{\vert{#1}\vert} 
\newcommand{\swap}[1][]{\sigma_{#1}} 
\newcommand{\proj}[1]{\pi^{#1}} 
\newcommand{\inj}[1]{\iota^{#1}} 
\newcommand{\unit}{\mathbf{1}} 
\newcommand{\Cl}{\mathrm{Cl}} 
\newcommand{\Val}{\mathrm{Val}} 
\newcommand{\apprv}{\mathrel{\triangleleft}} 
\newcommand{\contr}{\mathtt{c}} 
\newcommand{\der}{\mathtt{d}} 
\newcommand{\weak}{\mathtt{w}} 
\newcommand{\dig}{\mathtt{dig}} 
\newcommand{\bierman}{\mathtt{m}} 
\newcommand{\cmatrix}[1]{\Lambda(#1)} 
\newcommand{\injl}[2][]{{\mathtt{in}_\ell^{#1}}~{#2}} 
\newcommand{\injr}[2][]{{\mathtt{in}}_r^{#1}~{#2}} 
\newcommand{\fprod}[2]{\langle #1\rangle_{#2}}
\newcommand{\fcoprod}[2]{[#1]_{#2}}
\newcommand{\pdistr}{{\mathtt{distr}}} 
\newcommand{\symgroup}{S}	
\newcommand{\Lowner}{L\"owner}
\newcommand{\tr}{\mathop{\mathrm{\rm tr}}\nolimits}
\newcommand{\cs}{c}
\newcommand{\down}{{\downarrow}}
\newcommand{\define}[1]{{\em #1}}
\newcommand{\punit}{\mathtt{skip}}
\newcommand{\tensterm}[2]{{{#1}\tensor{#2}}}
\newcommand{\lettensterm}[4]{{\mathtt{let}~{#1}%
\tensor{#2}~=~{#3}~\mathtt{in}~{#4}}}
\newcommand{\letunitterm}[2]{{#1}\mathtt{;}{#2}}
\newcommand{\ttrue}{\mathtt{tt}}
\newcommand{\ffalse}{\mathtt{ff}}
\newcommand{\iftermx}[3]{{{\mathtt{if}}~{#1}~\mathtt{then}~{#2}~%
\mathtt{else}~{#3}}}
\newcommand{\match}[5]{{{\mathtt{match}}~{#1}~{\mathtt{with}}%
~({#2:#3}\mid{#4:#5})}}
\newcommand{\letrec}[4]{{{\mathtt{letrec}}~{#1}\,{#2}={#3}~{\mathtt{in}}~{#4}}}
\newcommand{\letrecn}[5]{{{\mathtt{letrec}}^{#1}~{#2}%
\,{#3}={#4}~{\mathtt{in}}~{#5}}}
\newcommand{\nil}{{\mathtt{nil}}}
\newcommand{\cons}[3][]{{{#2}\,{\mathtt :}{\mathtt :}^{#1}\,{#3}}}
\newcommand{\splitlist}[1][]{{\mathtt{split}^{#1}}}
\newcommand{\meas}{{\mathtt{meas}}}
\newcommand{\new}{{\mathtt{new}}}
\newcommand{\loli}{\multimap}
\newcommand{\tlist}[1]{{{#1}^\ell}}
\newcommand{\sumtype}{\oplus}
\newcommand{\tunit}{{1}}
\newcommand{\arity}[1]{d^{#1}} 
\newcommand{\symm}[1]{G^{#1}} 
\newcommand{\entail}{\vdash}
\newcommand{\am}[1]{{[}{#1}{]}}
\newcommand{\qarray}{q} 
\newcommand{\qlist}{\ell} 
\newcommand{\ket}[1]{{|{#1}\rangle}}
\newcommand{\dual}[1]{{#1}^{\perp}} 
\newcommand{\denot}[1]{{\llbracket #1 \rrbracket}}
\end_preamble
\use_default_options true
\begin_modules
enumitem
\end_modules
\maintain_unincluded_children false
\begin_local_layout
#\DeclareLyXModule{Other}
#DescriptionBegin
#Defines Notation
#DescriptionEnd
#Category: theorems

Format 66

Requires    amsmath

# The environments defined (regular and starred) are :
# - Property

Style Notation
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             notation
    LabelString           "Notation \thethm."
    Preamble
      \spnewtheorem{notation}{Notation}{\bfseries}{\itshape}
    EndPreamble
End


Style "Personal Question"
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             personalquestion
    LabelString           "Personal Question \thethm."
    Preamble
      %\newenvironment{personalquestion}{\shortfull{\comment}{\begin{question}\color{red}(personal)}}{\shortfull{\endcomment}{\end{question}}}
      \newenvironment{personalquestion}{\comment}{\endcomment}
    EndPreamble
End


Style "Long Proof"
    CopyStyle             Proof
    DependsOn               Proof
    LatexName             longproof
    LabelString           "Long proof."
    Preamble
      \newenvironment{longproof}{\shortfull{\comment}{\begin{proof}}}{\shortfull{\endcomment}{\end{proof}}}
    EndPreamble
End
\end_local_layout
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style splncs04
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Generic pattern unification: a categorical approach
\end_layout

\begin_layout Author
Ambroise Lafont
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
orcidID{0000-0002-9299-641X}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 Neel Krishnaswami
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
orcidID{0000-0003-2838-5865}
\end_layout

\end_inset


\end_layout

\begin_layout Institute
University of Cambridge
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\veciflyx}[2]{\vecif{#1}{#2}}
{\vec{#2}_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\refrule}[1]{\hyperlink{#1}{\textsc{#1}}}
{\underline{\textsc{#1}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\maybold}[1]{#1}
\end_inset


\begin_inset FormulaMacro
\newcommand{\labelrule}[2]{\hypertarget{#2}{#1}}
{#1\underline{\textsc{#2}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\labellabelrule}[2]{\labelrule{#1\textsc{#2}}{#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kl}[1]{Kl_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\arg}[1]{#1}
{#1}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Eil}[1]{#1\text{-alg}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\something}[1]{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\acton}[2]{#1\cdot#2}
\end_inset


\begin_inset FormulaMacro
\newcommand{\prunecat}[5]{\vdash_{#5}#1:>#2\Rightarrow#4;#3}
\end_inset


\begin_inset FormulaMacro
\newcommand{\prune}[4]{\prunecat{#1}{#2}{#3}{#4}{}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\B}{\mathscr{B}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\D}{\mathscr{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\C}{\mathscr{C}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\colim}{\mathrm{colim}\ }
\end_inset


\begin_inset FormulaMacro
\newcommand{\Set}{\mathrm{Set}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\FinSet}{\mathrm{FinSet}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Nom}{\mathrm{Nom}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KlD}{\Kl{\D^{+}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\op}[1]{#1^{op}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bang}{\oc}
{!}
\end_inset


\begin_inset FormulaMacro
\newcommand{\none}{\bang}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationtopconcl}{\bot\vdash\vec{t}=\vec{u}\Rightarrow\bang\dashv\bot}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationtop}{\dfrac{}{\unificationtopconcl}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationemptyconcl}{\Gamma\vdash()=()\Rightarrow1_{\Gamma}\dashv\Gamma}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationempty}{\dfrac{}{\unificationemptyconcl}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationstepwise}[1]{\dfrac{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{u_{1}}\Rightarrow\sigma_{1}\dashv\Delta_{1}\qquad\Delta_{1}\vdash\veciflyx{#1}{t_{2}}[\text{\ensuremath{\sigma_{1}]}}=\veciflyx{#1}{u_{2}}[\text{\ensuremath{\sigma_{1}]}}\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash\veciflyx{}{t_{1}},\veciflyx{#1}{t_{2}}=\veciflyx{}{u_{1}},\veciflyx{#1}{u_{2}}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}\textsc{U-Split}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationrigrig}{\dfrac{\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash o(\vec{t})=o(\vec{u})\Rightarrow\sigma\dashv\Delta}\textsc{U-RigRig}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationrigrigneqo}{\dfrac{o\neq o'}{\Gamma\vdash o(\vec{t})=o'(\vec{u})\Rightarrow\bang\dashv\bot}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationfailingoccurcheck}{\dfrac{T\Gamma\xrightarrow{Tin_{\Gamma}}T(\Gamma,M:b)\text{ does not factor }\vec{g}:a^{o}\rightarrow T(\Gamma,M:b)}{\Gamma,M:b\vdash M(\arg x)=o(\vec{g})\Rightarrow\bang\dashv\bot}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationfailingoccurcheckeffective}{\dfrac{u=o(\vec{t})\qquad u_{|\Gamma}\neq\something{\dots}}{\Gamma,M:b\vdash M(\arg x)=u\Rightarrow\bang\dashv\bot}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationflexflex}{\dfrac{b\vdash\arg x=_{\D}\arg y\Rightarrow\arg z\dashv c}{\Gamma,M:b\vdash M(\arg x)=M(\arg y)\Rightarrow M\mapsto M'(\arg z)\dashv\Gamma,M':c}\textsc{U-FlexFlex}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationoccurcheck}{\dfrac{\Gamma\prune{u'}{M(\arg x)}{\sigma}v\dashv\Delta\qquad u=u'[in_{\Gamma}]}{\Gamma,M:b\vdash M(\arg x)=u\Rightarrow\sigma,M\mapsto v\dashv\Delta}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationoccurcheckeffective}{\dfrac{u_{|\Gamma}=\something{u'}\qquad\Gamma\prune{u'}{M(\arg x)}{\sigma}v\dashv\Delta}{\Gamma,M:b\vdash M(\arg x)=u\Rightarrow\sigma,M\mapsto v\dashv\Delta}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\pruningemptyconcl}{\Gamma\prune{()}{()}{1_{\Gamma}}{()}\dashv\Gamma}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pruningempty}{\dfrac{}{\pruningemptyconcl}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pruningtopconcl}{\bot\prune{\vec{t}}{\vec{f}}{\bang}{\bang}\dashv\bot}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pruningtop}{\dfrac{}{\pruningtopconcl}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pruningflex}[1]{\dfrac{c\prunecat{\veciflyx{#1}y}{\veciflyx{#1}x}{\veciflyx{#1}x'\dashv d}{\veciflyx{#1}{y'}}{\D}}{\Gamma,M:c\prune{M(\veciflyx{#1}y)}{N(\veciflyx{#1}x)}{M\mapsto M'(\veciflyx{#1}{x'})}{M'(\veciflyx{#1}{y'})}\dashv\Gamma,M':d}\textsc{P-Flex}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pruningrigfail}{\dfrac{o\neq\acton{\arg x}{\dots}}{\Gamma\prune{o(\vec{t})}{N(\arg x)}{\bang}{\bang}\dashv\bot}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pruningrig}{\dfrac{\Gamma\prune{\vec{t}}{{\cal L}^{+}\arg x^{o}}{\sigma}{\vec{u}}\dashv\Delta\qquad o=\acton{\arg x}{o'}}{\Gamma\prune{o(\vec{t})}{N(\arg x)}{\sigma}{o'(\vec{u})}\dashv\Delta}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\pruningstepwise}[1]{\dfrac{\Gamma\prune{\veciflyx{}{t_{1}}}{\veciflyx{}{f_{1}}}{\sigma_{1}}{\veciflyx{}{u_{1}}}\dashv\Delta_{1}\qquad\Delta_{1}\prune{\veciflyx{#1}{t_{2}}[\sigma_{1}]}{\veciflyx{#1}{f_{2}}}{\sigma_{2}\dashv\Delta_{2}}{\veciflyx{#1}{u_{2}}}}{\Gamma\prune{\veciflyx{}{t_{1}},\veciflyx{#1}{t_{2}}}{\veciflyx{}{f_{1}}+\veciflyx{#1}{f_{2}}}{\sigma_{1}[\sigma_{2}]}{\veciflyx{}{u_{1}}[\sigma_{2}],\veciflyx{#1}{u_{2}}}\dashv\Delta_{2}}\textsc{P-Split}}
\end_inset


\end_layout

\begin_layout Abstract
We provide a generic categorical setting for Miller's pattern unification.
 The syntax with metavariables is generated by a free monad applied to finite
 coproducts of representable functors; the most general unifier is computed
 as a coequaliser in the Kleisli category restricted to such coproducts.
 Our setting handles simply-typed second-order syntax, linear syntax, or
 (intrinsic) polymorphic syntax such as system F.
 
\end_layout

\begin_layout Abstract
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
keywords{Unification  
\backslash
and Category theory.}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Unification consists in finding a 
\emph on
unifier 
\emph default
of two terms 
\begin_inset Formula $t,u$
\end_inset

, that is a (metavariable) substitution 
\begin_inset Formula $\sigma$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

.
 Unification algorithms try to compute a most general unifier 
\begin_inset Formula $\sigma$
\end_inset

, in the sense that given any other unifier 
\begin_inset Formula $\delta$
\end_inset

, there exists a unique 
\begin_inset Formula $\delta'$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma[\delta']$
\end_inset

.
 
\end_layout

\begin_layout Standard
First-order unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "robinsonunif"
literal "false"

\end_inset

 is used in ML-style type inference systems and logic programming languages
 such as Prolog.
 For more advanced type systems, where variable binding is crucially involved,
 one needs second-order unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "huetunif"
literal "false"

\end_inset

, which is undecidable
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "unifundecidable"
literal "false"

\end_inset

.
 However, Miller
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

 identified a decidable fragment: in so-called 
\emph on
pattern unification
\emph default
,
\emph on
 
\emph default
metavariables are allowed to take distinct variables as arguments.
 In this situation, we can write an algorithm that either fails in case
 there is no unifier, either computes the most general unifier.
\end_layout

\begin_layout Standard
First-order unification has been explained from a lattice-theoretic point
 of view by Plotkin
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "plotkinunification"
literal "false"

\end_inset

, and later categorically analysed in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/daglib/0068768,Goguen89whatis"
literal "false"

\end_inset

.
 However, there is little work on understanding pattern unification algebraicall
y, with the notable exception of 
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

, working with normalised terms of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 The present paper
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ifshort{
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
An expanded version of this work can be found in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "longgenericunif"
literal "false"

\end_inset

.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 can be thought of as a generalisation of their work.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection*
Related work
\end_layout

\begin_layout Plain Layout
First-order unification, where all metavariables are constant, was categorically
 rephrased in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

.
 Pattern unification was introduced in 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

, as a particular case of higher-order unification for the simply-typed
 lambda-calculus, where metavariables are applied to distinct variables.
 It was categorically rephrased in 
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
, with concluding hints about how to generalise their work.
\end_layout

\end_inset

The present paper can be thought of as a generalisation of their work.
\end_layout

\begin_layout Personal Question
\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

 propose une generalisation interessante, avec le lemme sur les epis.
 (Theorem 10).
 Est-ce qu'on pourrait encore generaliser encore notre business?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As an introduction, we start by presenting pattern unification in the case
 of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generalise"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we then present the generic algorithm summarised in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

, instantiated for a syntax specified by a 
\emph on
binding signature
\emph default
.
 Finally, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we motivate our general setting and provide categorical semantics of the
 algorithm, by revisiting pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\begin_layout Subsection
An example: pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:example-lambda"

\end_inset

Consider the syntax of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with metavariables satisfying the pattern restriction,
 encoded with De Bruijn levels, rather than De Bruijn indices 
\begin_inset CommandInset citation
LatexCommand cite
key "DB"
literal "false"

\end_inset

.
 More formally, the syntax is inductively generated by the following inductive
 rules, where 
\begin_inset Formula $C$
\end_inset

 is a variable context 
\begin_inset Formula $(0:\tau,1:\tau,\dots,n:\tau)$
\end_inset

, often abbreviated as 
\begin_inset Formula $n$
\end_inset

, and 
\begin_inset Formula $\tau$
\end_inset

 denotes the sort of terms, which we often omit, while 
\begin_inset Formula $\Gamma$
\end_inset

 is a metavariable context 
\begin_inset Formula $M_{1}:n_{1},\dots,M_{m}:n_{m}$
\end_inset

 specifying a metavariable symbol 
\begin_inset Formula $M_{i}$
\end_inset

 together with its number of arguments 
\begin_inset Formula $n_{i}$
\end_inset

.
\begin_inset Formula 
\[
\dfrac{x\in C}{\Gamma;C\vdash x}\qquad\dfrac{\Gamma;C\vdash t\quad\Gamma;C\vdash u}{\Gamma;C\vdash t\ u}\qquad\dfrac{\Gamma;C,|C|:\tau\vdash t}{\Gamma;C\vdash\lambda t}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{M:n\in\Gamma\quad x_{1},\dots,x_{n}\in C\quad x_{1},\dots x_{n}\text{ distinct}}{\Gamma;C\vdash M(x_{1},\dots,x_{n})}
\]

\end_inset

Note that the De Bruijn level convention means that the variable bound in
 
\begin_inset Formula $\Gamma;C\vdash\lambda t$
\end_inset

 is 
\begin_inset Formula $|C|$
\end_inset

, the length of the variable context 
\begin_inset Formula $C$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
The benefit is that there is no need to shift free variables under a 
\begin_inset Formula $\lambda$
\end_inset

, making substitution simpler.
 Whether a variable is bound or not depends on the variable context.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
metavariable substitution
\emph default
 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Gamma'$
\end_inset

 assigns to each declaration 
\begin_inset Formula $M:n$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

 a term 
\begin_inset Formula $\Gamma';n\vdash\sigma_{M}$
\end_inset

.
 This assignation extends (through a recursive definition) to any term 
\begin_inset Formula $\Gamma;C\vdash t$
\end_inset

, yielding a term 
\begin_inset Formula $\Gamma';C\vdash t[\sigma]$
\end_inset

.
 The base case is 
\begin_inset Formula $M(x_{1},\dots,x_{n})[\sigma]=\sigma_{M}[i\mapsto x_{i+1}]$
\end_inset

, where 
\begin_inset Formula $-[i\mapsto x_{i+1}]$
\end_inset

 is variable renaming.
 Composition of substitutions 
\begin_inset Formula $\sigma:\Gamma_{1}\rightarrow\Gamma_{2}$
\end_inset

 and 
\begin_inset Formula $\sigma':\Gamma_{2}\rightarrow\Gamma_{3}$
\end_inset

 is then defined as 
\begin_inset Formula $(\sigma[\sigma'])_{M}=\sigma_{M}[\sigma']$
\end_inset

.
 
\end_layout

\begin_layout Standard
A 
\emph on
unifier
\emph default
 of two terms 
\begin_inset Formula $\Gamma;C\vdash t,u$
\end_inset

 is a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Gamma'$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

.
 A 
\emph on
most general unifier
\emph default
 of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 is a unifier 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Gamma'$
\end_inset

 that uniquely factors any other unifier 
\begin_inset Formula $\delta:\Gamma\rightarrow\Delta$
\end_inset

, in the sense that there exists a unique 
\begin_inset Formula $\delta':\Gamma'\rightarrow\Delta$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma[\delta']$
\end_inset

.
 We denote this situation by 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Gamma'$
\end_inset

, leaving the variable context 
\begin_inset Formula $C$
\end_inset

 implicit.
 Intuitively, the symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 separates the input and the output of the unification algorithm, which
 either returns a most general unifier, either fails when there is no unifier
 at all (for example, when unifying 
\begin_inset Formula $t_{1}\ t_{2}$
\end_inset

 with 
\begin_inset Formula $\lambda u$
\end_inset

).
 To handle the latter case
\begin_inset Note Note
status open

\begin_layout Plain Layout
(when no unifier exists, for example, when unifying a 
\begin_inset Formula $\lambda$
\end_inset

-abstraction with an application)
\end_layout

\end_inset

, we add
\begin_inset Foot
status open

\begin_layout Plain Layout
This trick will be justified from a categorical point of view in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Main-result"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 a formal error metavariable context 
\begin_inset Formula $\bot$
\end_inset

 in which the only term (in any variable context) is a formal error term
 
\begin_inset Formula $!$
\end_inset

, inducing a unique substitution 
\begin_inset Formula $!:\Gamma\rightarrow\bot$
\end_inset

, satisfying 
\begin_inset Formula $t[!]=\bang$
\end_inset

 for any term 
\begin_inset Formula $t$
\end_inset

.
 For example, we have 
\begin_inset Formula $\Gamma\vdash t_{1}\ t_{2}=\lambda u\Rightarrow\bang\dashv\bot$
\end_inset

.
\end_layout

\begin_layout Standard
We generalise the notation (and thus the input of the unification algorithm)
 to lists of terms 
\begin_inset Formula $\vec{t}=(t_{1},\dots,t_{n})$
\end_inset

 and 
\begin_inset Formula $\vec{u}=(u_{1},\dots,u_{n})$
\end_inset

 such that 
\begin_inset Formula $\Gamma;C_{i}\vdash t_{i},u_{i}$
\end_inset

.
 Then, 
\begin_inset Formula $\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Gamma'$
\end_inset

 means that 
\begin_inset Formula $\sigma$
\end_inset

 unifies each pair 
\begin_inset Formula $(t_{i},u_{i})$
\end_inset

 and is the most general one, in the sense that it uniquely factors any
 other substitution that unifies each pair 
\begin_inset Formula $(t_{i},u_{i})$
\end_inset

.
 As a consequence, we get the following 
\emph on
congruence
\emph default
 rule for application.
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash t_{1},u_{1}=t_{2},u_{2}\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash t_{1}\ t_{2}=u_{1}\ u_{2}\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\begin_layout Standard
Unifying a list of term pairs 
\begin_inset Formula $\veciflyx{}{t_{1}},\veciflyx 1{t_{2}}=\veciflyx{}{u_{1}},\veciflyx 1{u_{2}}$
\end_inset

 can be performed sequentially by first computing the most general unifier
 
\begin_inset Formula $\sigma_{1}$
\end_inset

 of 
\begin_inset Formula $(t_{1},u_{1})$
\end_inset

, then applying the substitution to 
\begin_inset Formula $(\vec{t_{2}},\vec{u_{2}})$
\end_inset

, and finally computing the most general unifier of the resulting list of
 term pairs: this is precisely the rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
that we repeat here.
 
\begin_inset Formula 
\[
\unificationstepwise 1
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
This rule can of course be restricted to the case where 
\begin_inset Formula $\vec{t_{1}}$
\end_inset

 and 
\begin_inset Formula $\vec{u_{1}}$
\end_inset

 are singleton lists
\begin_inset Foot
status open

\begin_layout Plain Layout
We will actually do so when proving completeness in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:completeness"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

.
\end_layout

\end_inset

 Thanks to this rule, we can focus on unification of a single term pair.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For the sake of brevity, we skip the error cases and the variable cases.
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The congruence case for 
\begin_inset Formula $\lambda$
\end_inset

-abstraction is straightforward.
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash\lambda x.t=\lambda x.u\Rightarrow\sigma\dashv\Delta}
\]

\end_inset

For the congruence case for application 
\begin_inset Formula $t_{1}\ t_{2}=u_{1}\ u_{2}$
\end_inset

, we need to unify both 
\begin_inset Formula $(t_{1},u_{1})$
\end_inset

 and 
\begin_inset Formula $(t_{2},u_{2})$
\end_inset

.
 Let us introduce the notation 
\begin_inset Formula $\Gamma\vdash t_{1},u_{1}=t_{2},u_{2}\Rightarrow\sigma\dashv\Delta$
\end_inset

, meaning that 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 unifies both 
\begin_inset Formula $(t_{1},u_{1})$
\end_inset

 and 
\begin_inset Formula $(t_{2},u_{2})$
\end_inset

, and is the most general unifier, in the sense that it uniquely factors
 any other unifier of both term pairs.
 Computing the most general unifier of a list of term pairs can be done
 sequentially.
 In the example above, we first compute the most general unifier 
\begin_inset Formula $\sigma_{1}$
\end_inset

 of 
\begin_inset Formula $(t_{1},u_{1})$
\end_inset

, apply the substitution to 
\begin_inset Formula $(t_{2},u_{2})$
\end_inset

 and compute the most general unifier of the resulting term pair.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\dfrac{\Gamma\vdash t_{1}=u_{1}\Rightarrow\sigma_{1}\dashv\Delta_{1}\qquad\Delta_{1}\vdash t_{2}[\sigma_{1}]=u_{2}[\sigma_{1}]\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash t_{1}\ t_{2}=u_{1}\ u_{2}\Rightarrow\sigma\dashv\Delta}\label{eq:app-lc-oneshot-unif}
\end{equation}

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash t_{1},u_{1}=t_{2},u_{2}\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash t_{1}\ t_{2}=u_{1}\ u_{2}\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Computing the most general unifier of a list of term pairs can be done sequentia
lly.
 In the example above, we first compute the most general unifier 
\begin_inset Formula $\sigma_{1}$
\end_inset

 of 
\begin_inset Formula $(t_{1},u_{1})$
\end_inset

, apply the substitution to 
\begin_inset Formula $(t_{2},u_{2})$
\end_inset

 and compute the most general unifier of the resulting term pair:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash t_{1}=u_{1}\Rightarrow\sigma_{1}\dashv\Delta_{1}\qquad\Delta_{1}\vdash t_{2}[\sigma_{1}]=u_{2}[\sigma_{1}]\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash t_{1},u_{1}=t_{2},u_{2}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset

 The idea here is to recursively inspect the structure of the given terms,
 until reaching a metavariable application 
\begin_inset Formula $M(x_{1},\dots,x_{n})$
\end_inset

 at top level on either hand side of 
\begin_inset Formula $\Gamma,M:n\vdash t=u$
\end_inset

.
 Assume by symmetry 
\begin_inset Formula $t=M(x_{1},\dots,x_{n})$
\end_inset

, then three mutually exclusive situations must be considered:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $M$
\end_inset

 appears deeply in 
\begin_inset Formula $u$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $M$
\end_inset

 appears in 
\begin_inset Formula $u$
\end_inset

 at top level, i.e., 
\begin_inset Formula $u=M(y_{1},\dots,y_{n})$
\end_inset

;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $M$
\end_inset

 does not appear in 
\begin_inset Formula $u$
\end_inset

;
\end_layout

\begin_layout Standard
In the first case, there is no unifier because the size of both hand sides
 can never match after substitution.
 This justifies the rule
\begin_inset Formula 
\[
\dfrac{u\neq M(\dots)\qquad u_{|\Gamma}\neq\something{\dots}}{\Gamma,M:n\vdash M(\vec{x})=u\Rightarrow\bang\dashv\bot}
\]

\end_inset

where 
\begin_inset Formula $u_{|\Gamma}\neq\something{\dots}$
\end_inset

 means that 
\begin_inset Formula $u$
\end_inset

 does not restrict to the smaller metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

, and thus that 
\begin_inset Formula $M$
\end_inset

 does appear in 
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout Standard
In the second case, we are unifying 
\begin_inset Formula $M(\vec{x})$
\end_inset

 with 
\begin_inset Formula $M(\vec{y})$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
we only keep the argument positions that are the same in 
\begin_inset Formula $x_{1},\dots,x_{n}$
\end_inset

 and 
\begin_inset Formula $y_{1},\dots,y_{n}$
\end_inset

.
 In other words,
\end_layout

\end_inset

 The most general unifier substitutes 
\begin_inset Formula $M$
\end_inset

 with 
\begin_inset Formula $M'(z_{1},\dots,z_{p})$
\end_inset

, where 
\begin_inset Formula $z_{1}$
\end_inset

, 
\begin_inset Formula $\dots$
\end_inset

, 
\begin_inset Formula $z_{p}$
\end_inset

 is the family of common positions 
\begin_inset Formula $i$
\end_inset

 such that 
\begin_inset Formula $x_{i}=y_{i}$
\end_inset

.
 We denote
\begin_inset Foot
status open

\begin_layout Plain Layout
The similarity with the above introduced notation is no coincidence: as
 we will see, both are (co)equalisers.
\end_layout

\end_inset

 such a situation by 
\begin_inset Formula $n\vdash\vec{x}=\vec{y}\Rightarrow\vec{z}\dashv p$
\end_inset

.
 We therefore get the rule
\begin_inset Formula 
\begin{equation}
\dfrac{n\vdash\vec{x}=\vec{y}\Rightarrow\vec{z}\dashv p}{\Gamma,M:n\vdash M(\vec{x})=M(\vec{y})\Rightarrow M\mapsto M'(\vec{z})\dashv\Gamma,M':p}\label{eq:coeq-mvar-lc}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The last case is unification of 
\begin_inset Formula $M(\vec{x})$
\end_inset

 with some 
\begin_inset Formula $u$
\end_inset

 such that 
\begin_inset Formula $M$
\end_inset

 does not appear in 
\begin_inset Formula $u$
\end_inset

, i.e., 
\begin_inset Formula $u$
\end_inset

 restricts to the smaller metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

.
 We denote such a situation by 
\begin_inset Formula $u_{|\Gamma}=\something{u'}$
\end_inset

, where 
\begin_inset Formula $u'$
\end_inset

 is essentially 
\begin_inset Formula $u$
\end_inset

 but considered in the smaller metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

.
 In this case, the algorithm enters a 
\emph on
pruning phase
\emph default
.
 To give an example, when unifying an application 
\begin_inset Formula $t\ u$
\end_inset

 with a metavariable 
\begin_inset Formula $M(x_{1},\dots,x_{n})$
\end_inset

 which does not occur in 
\begin_inset Formula $t$
\end_inset

,
\begin_inset Formula $u$
\end_inset

, two fresh metavariables 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 are created.
 Then, 
\begin_inset Formula $t$
\end_inset

 is unified with 
\begin_inset Formula $M_{1}(x_{1},\dots,x_{n})$
\end_inset

, outputing a unifier 
\begin_inset Formula $\sigma_{1}$
\end_inset

, and 
\begin_inset Formula $u[\sigma_{1}]$
\end_inset

 is unified with 
\begin_inset Formula $M_{2}(x_{1},\dots,x_{n})$
\end_inset

, outputing a unifier 
\begin_inset Formula $\sigma_{2}$
\end_inset

.
 Eventually, 
\begin_inset Formula $M$
\end_inset

 is replaced with 
\begin_inset Formula $(M_{1}(\vec{x})\ M_{2}(\vec{x}))[\sigma_{2}]$
\end_inset

, where 
\begin_inset Formula $\sigma_{2}$
\end_inset

 is the output unifier.
 We call it 
\emph on
pruning 
\emph default
because unifying 
\begin_inset Formula $u'$
\end_inset

 and 
\begin_inset Formula $M(\vec{x})$
\end_inset

 when 
\begin_inset Formula $M$
\end_inset

 does not occur in 
\begin_inset Formula $u'$
\end_inset

 consists in removing all 
\emph on
outbound 
\emph default
variables in 
\begin_inset Formula $u'$
\end_inset

, i.e., those that are not among the arguments 
\begin_inset Formula $x_{1},\dots,x_{n}$
\end_inset

 of the metavariable, by producing a substitution that restricts the arities
 of the metavariables occurring in 
\begin_inset Formula $u'$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The pruning phase is nothing but unification restricted to this particular
 situation.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us introduce a specific notation for this phase: 
\begin_inset Formula $\Gamma\prune{u'}{\maybold M(\vec{x})}{\sigma\dashv\Delta}v$
\end_inset

 means that 
\begin_inset Formula $\sigma$
\end_inset

 is the output pruning substitution, and 
\begin_inset Formula $v$
\end_inset

 is essentially 
\begin_inset Formula $u'[\sigma][x_{i+1}\mapsto i]$
\end_inset

, the term that the metavariable 
\begin_inset Formula $M$
\end_inset

 ought to be substituted with.
 Note that the metavariable symbol 
\begin_inset Formula $M$
\end_inset

 is fresh in this notation: it appears neither in 
\begin_inset Formula $\Gamma$
\end_inset

 nor 
\begin_inset Formula $u'$
\end_inset

, and is not in the domain of 
\begin_inset Formula $\sigma$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
and can be thought of as a formal syntactic symbol
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
A precise categorical meaning will be given to this notation.
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The output 
\begin_inset Formula $\sigma,v$
\end_inset

 defines a substitution 
\begin_inset Formula $(\Gamma,\maybold M:n)\rightarrow\Delta$
\end_inset

 which can be characterised as the most general unifier of 
\begin_inset Formula $u'$
\end_inset

 and 
\begin_inset Formula $\maybold M(\vec{x})$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Moreover the variable context 
\begin_inset Formula $C$
\end_inset

 for 
\begin_inset Formula $u'$
\end_inset

 is left implicit.
\end_layout

\end_inset

 We thus have the rule
\begin_inset Formula 
\begin{equation}
\dfrac{u_{|\Gamma}=\something{u'}\qquad\Gamma\prune{u'}{\maybold M(\vec{x})}{\sigma}v\dashv\Delta}{\Gamma,M:n\vdash M(\vec{x})=u\Rightarrow\sigma,M\mapsto v\dashv\Delta}\label{eq:u-nocycle}
\end{equation}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
This rules shows that the output 
\begin_inset Formula $v$
\end_inset

 in the pruning notation is intuitively what 
\begin_inset Formula $M$
\end_inset

 is going to be substituted with.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $M$
\end_inset

 is indeed substituted by 
\begin_inset Formula $v$
\end_inset

, as hinted above.
 As before, we generalise the pruning phase to handle lists 
\begin_inset Formula $\vec{u}=(u_{1},\dots,u_{n})$
\end_inset

 of terms such that 
\begin_inset Formula $\Gamma;C_{i}\vdash u_{i}$
\end_inset

, and lists of pruning patterns 
\begin_inset Formula $(\vec{x}_{1},\dots,\vec{x}_{n})$
\end_inset

 where each 
\begin_inset Formula $\vec{x_{i}}$
\end_inset

 is a choice of distinct variables in 
\begin_inset Formula $C_{i}$
\end_inset

.
 Then, 
\begin_inset Formula $\Gamma\prune{\vec{u}}{\maybold M_{1}(\vec{x}_{1}),\dots,\maybold M_{n}(\vec{x}_{n})}{\sigma}{\vec{v}}\dashv\Delta$
\end_inset

 means
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
The usage of 
\begin_inset Formula $+$
\end_inset

 as a list separator 
\begin_inset Note Note
status open

\begin_layout Plain Layout
instead of a comma
\end_layout

\end_inset

 will be justified later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:pruning-list-notation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

 that 
\begin_inset Formula $\sigma$
\end_inset

 is the common pruning substitution, and 
\begin_inset Formula $v_{i}$
\end_inset

 is essentially 
\begin_inset Formula $u_{i}[\sigma][x_{i,j+1}\mapsto j]$
\end_inset

, which 
\begin_inset Formula $M_{i}$
\end_inset

 ought to be substituted with.
 Again, 
\begin_inset Formula $(\sigma,\vec{v})$
\end_inset

 define a substitution from 
\begin_inset Formula $\Gamma,\maybold M_{1}:|\vec{x}_{1}|,\dots,\maybold M_{n}:|\vec{x}_{n}|$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

 which can be characterised as the most general unifier of 
\begin_inset Formula $\vec{u}$
\end_inset

 and 
\begin_inset Formula $\maybold M_{1}(\vec{x}_{1}),\dots\maybold M_{n}(\vec{x}_{n})$
\end_inset

.
\end_layout

\begin_layout Standard
We can then handle application as follows.
\begin_inset Formula 
\begin{equation}
\dfrac{\Gamma\prune{t,u}{\maybold M_{1}(\vec{x}),\maybold M_{2}(\vec{x})}{\sigma}{v_{1},v_{2}}\dashv\Delta}{\Gamma\prune{t\ u}{\maybold M(\vec{x})}{\sigma}{v_{1}\ v_{2}}\dashv\Delta}\label{eq:pruning-app-lc}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
As for unification (rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

), pruning can be done sequentially, as in the rule 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The usage of 
\begin_inset Formula $+$
\end_inset

 as a separator will be formally justified later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:pruning-list-notation"
plural "false"
caps "true"
noprefix "false"

\end_inset

: it intuitively enforces that the metavariables used in 
\begin_inset Formula $\vec{f}_{2}$
\end_inset

 are distinct from the metavariable used in 
\begin_inset Formula $f_{1}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\pruningstepwise o
\]

\end_inset


\end_layout

\end_inset

Thanks to this sequential rule, we can focus on pruning a single term.
 The variable case is straightforward.
\begin_inset Formula 
\begin{equation}
\dfrac{y=x_{i+1}}{\Gamma\prune y{\maybold M(\vec{x})}{1_{\Gamma}}i\dashv\Gamma}\qquad\dfrac{y\notin\vec{x}}{\Gamma\prune y{\maybold M(\vec{x})}{\bang}{\bang}\dashv\bot}\label{eq:pruning-var-lc}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, the bound variable 
\begin_inset Formula $|C|$
\end_inset

 need not be pruned: we extend the list of allowed variables accordingly.
\begin_inset Formula 
\begin{equation}
\dfrac{\Gamma\prune t{\maybold M_{1}(\vec{x},|C|)}{\sigma}v\dashv\Delta}{\Gamma\prune{\lambda t}{\maybold M(\vec{x})}{\sigma}{\lambda v}\dashv\Delta}\label{eq:pruning-lambda-lc}
\end{equation}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Application requires to prune two terms, this is done sequentially by first
 pruning the first term, applying the pruning substitution to the second
 term, and finally pruning the resulting term.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\lambda t:yC\rightarrow T\Gamma$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $M(\vec{x}):yC\rightarrow yn$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $t:y(C+1)\rightarrow T\Gamma$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $M(\vec{x},|C|):y(C+1)\rightarrow y(n+1)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
justifying the premise with the intuitive notation in the following rule.
\end_layout

\begin_layout Plain Layout
This is done sequentially by first pruning the first term, applying the
 pruning substitution to the second term, and finally pruning the resulting
 term.
 
\begin_inset Formula 
\[
\dfrac{\Gamma\prune{u_{1}}{\boldsymbol{M_{1}}(\vec{x})}{\sigma_{1}}{v_{1}}\dashv\Delta_{1}\qquad\Delta_{1}\prune{u_{2}[\sigma_{1}]}{\boldsymbol{M_{2}}(\vec{x})}{\sigma_{2}\dashv\Delta_{2}}{v_{2}}}{\Gamma\prune{u_{1},u_{2}}{\boldsymbol{M_{1}}(\vec{x})+\boldsymbol{M_{2}}(\vec{x})}{\sigma_{1}[\sigma_{2}]}{v_{1}[\sigma_{2}],v_{2}}\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset

The remaining case consists in unifying 
\begin_inset Formula $N(\vec{x})$
\end_inset

 and 
\begin_inset Formula $M(\vec{y})$
\end_inset

, or equivalently, pruning a metavariable 
\begin_inset Formula $N(x_{1},\dots,x_{m})$
\end_inset

, whose arity must then be restricted to those positions in 
\begin_inset Formula $y_{1},\dots,y_{n}$
\end_inset

.
 To be more precise, consider the family 
\begin_inset Formula $z_{1},\dots,z_{p}$
\end_inset

 of common values in 
\begin_inset Formula $x_{1},\dots,x_{m}$
\end_inset

 and 
\begin_inset Formula $y_{1},\dots,y_{n}$
\end_inset

, so that 
\begin_inset Formula $z_{i}=x_{l_{i}}=y_{r_{i}}$
\end_inset

 for some lists 
\begin_inset Formula $(l_{1},\dots,l_{p})$
\end_inset

 and 
\begin_inset Formula $(r_{1},\dots,r_{p})$
\end_inset

 of distinct elements of 
\begin_inset Formula $\{0,\dots,m-1\}$
\end_inset

 and 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

 respectively.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
injections 
\begin_inset Formula $l:\underline{p}\rightarrow\underline{n}$
\end_inset

 and 
\begin_inset Formula $r:\underline{p}\rightarrow\underline{m}$
\end_inset

, where 
\begin_inset Formula $\underline{q}$
\end_inset

 denotes the set 
\begin_inset Formula $\{0,\dots,q-1\}$
\end_inset

.
\end_layout

\end_inset

 We denote
\begin_inset Foot
status open

\begin_layout Plain Layout
Again, the similarity with the pruning notation is no coincidence
\begin_inset Note Note
status open

\begin_layout Plain Layout
in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset

: as we will see, both are (co)pushouts.
\end_layout

\end_inset

 such a situation by 
\begin_inset Formula $m\prunecat{\vec{x}}{\vec{y}}{\vec{r}\dashv p}{\vec{l}}{}$
\end_inset

.
 Then, the metavariable 
\begin_inset Formula $N$
\end_inset

 is substituted with 
\begin_inset Formula $N'(\vec{r})$
\end_inset

 for some new metavariable 
\begin_inset Formula $N'$
\end_inset

 of arity 
\begin_inset Formula $p$
\end_inset

, while the metavariable 
\begin_inset Formula $M$
\end_inset

 is replaced with 
\begin_inset Formula $N'(\vec{l})$
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
in the variable context 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\dfrac{m\prunecat{\vec{x}}{\vec{y}}{\vec{r}\dashv p}{\vec{l}}{}}{\Gamma,N:m\prune{N(\vec{x})}{\maybold M(\vec{y})}{N\mapsto N'(\vec{r})}{N'(\vec{l})}\dashv\Gamma,N':p}\label{eq:pruning-mvar-lc}
\end{equation}

\end_inset

This ends our description of the unification algorithm, in the specific
 case of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 The goal of this paper is to generalise it, by parameterising the algorithm
 by a signature specifying a syntax.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Assume 
\begin_inset Formula $M$
\end_inset

 indeed appears at the top level in 
\begin_inset Formula $u$
\end_inset

, then the most general unifier replaces 
\begin_inset Formula $M$
\end_inset

 with a new metavariable whose arity is the number of common variables positions
 in both hand sides.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
First generalisation: parameterisation by a binding signature
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:intro-generalise"

\end_inset

As a first step, let us parameterise the unification algorithm by a binding
 signature 
\begin_inset CommandInset citation
LatexCommand cite
key "BindingSignatures"
literal "false"

\end_inset

.
 A syntax is then specified by a set of symbols 
\begin_inset Formula $O$
\end_inset

 together with a list of natural numbers 
\begin_inset Formula $\vec{\alpha}_{o}$
\end_inset

 for each 
\begin_inset Formula $o\in O$
\end_inset

 specifying the number of arguments (the size of the list) and the number
 of bound variables in each argument.
 For example, pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus is specified by 
\begin_inset Formula $O=\{app,lam\}$
\end_inset

 with 
\begin_inset Formula $\vec{\alpha}_{app}=(0,0)$
\end_inset

 and 
\begin_inset Formula $\vec{\alpha}_{lam}=(1)$
\end_inset

.
 The unification algorithm described in the previous section straightforwardly
 generalises to any syntax specified by a binding signature.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises the generic algorithm that we will later interpret in a more
 general setting, where metavariable arguments are morphisms in a category.
 Since nothing enforces them to be lists
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Section 8.2"
key "longgenericunif"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ex-arg-sets"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 for an example where arguments are sets.
\end_layout

\end_inset

, the vector notation is dropped for these arguments in the figure, but
 we still use it in the following specialisation to syntax specified by
 a binding signature.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises the generic algorithm that we will later interpret in a more
 broader setting.
 In this general setting, metavariable arguments are morphisms in a category:
 nothing enforces them to be lists.
\end_layout

\begin_layout Plain Layout
In the figure, the vector notation for the arguments of metavariables is
 dropped because in the general setting we consider in this paper, nothing
 enforces them to be lists .
 We still use the vector notation in the following specialisation to a syntax
 specified by a binding signature.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the rule 
\begin_inset Formula $\refrule{U-RigRig}$
\end_inset

, the expression 
\begin_inset Formula $o(\vec{t})$
\end_inset

 can be an operation or a variable, in which case 
\begin_inset Formula $\vec{t}$
\end_inset

 is the empty list.
 If 
\begin_inset Formula $o$
\end_inset

 is an operation, the exact nature of 
\begin_inset Formula $\vec{t}$
\end_inset

 depends on the arity 
\begin_inset Formula $\alpha_{o}=(n_{1},\dots,n_{p})$
\end_inset

 of 
\begin_inset Formula $o$
\end_inset

: then 
\begin_inset Formula $\vec{t}$
\end_inset

 is a list of terms of size 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $\Gamma;|C|+n_{i}\vdash t_{i}$
\end_inset

 for each 
\begin_inset Formula $i\in\{1,\dots,p\}$
\end_inset

, where 
\begin_inset Formula $C$
\end_inset

 is the variable context of 
\begin_inset Formula $o(\vec{t})$
\end_inset

.
 The rigid case in the pruning phase consists in two rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

.
 Both are concerned with pruning a non metavariable term 
\begin_inset Formula $\Gamma;C\vdash o(\vec{t})$
\end_inset

.
 In the variable case, these two rules instantiate to
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-var-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 More precisely, if 
\begin_inset Formula $o$
\end_inset

 is a variable in 
\begin_inset Formula $C$
\end_inset

, the side condition 
\begin_inset Formula $\acton{o=\vec{x}}{o'}$
\end_inset

 means that 
\begin_inset Formula $o=x_{o'+1}$
\end_inset

.
 On the other hand, if 
\begin_inset Formula $o$
\end_inset

 is an operation, then 
\begin_inset Formula $\acton{\vec{x}}o$
\end_inset

 is defined as 
\begin_inset Formula $o$
\end_inset

 and thus the rule 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 always applies with 
\begin_inset Formula $o'=o$
\end_inset

.
 If 
\begin_inset Formula $\alpha_{o}=(n_{1},\dots,n_{p})$
\end_inset

, then the notation 
\begin_inset Formula ${\cal L}^{+}\vec{x}^{o}$
\end_inset

 essentially unfolds to a list of the same size as 
\begin_inset Formula $\alpha_{o}$
\end_inset

 and whose 
\begin_inset Formula $i^{th}$
\end_inset

 element is 
\begin_inset Formula $M_{i}(\vec{x},|C|,\dots,|C|+n_{i}-1)$
\end_inset

.
 For example, for pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, 
\begin_inset Formula ${\cal L}^{+}\vec{x}^{o}=\maybold M_{1}(\vec{x}),\maybold M_{2}(\vec{x})$
\end_inset

 in the application case, and 
\begin_inset Formula ${\cal L}^{+}\vec{x}^{o}=\maybold M_{1}(\vec{x},|C|)$
\end_inset

 in the abstraction case, thus recovering the rules 
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-app-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-lambda-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The notation 
\begin_inset Formula ${\cal L}^{+}\vec{x}^{o}$
\end_inset

 indeed essentially unfolds to 
\begin_inset Formula $\maybold M_{1}(\vec{x})+\maybold M_{2}(\vec{x})$
\end_inset

 in the application case, and to 
\begin_inset Formula $\maybold M'(\vec{x},|C|)$
\end_inset

 in the abstraction case.
 The rule 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 applies when there is no such 
\begin_inset Formula $o'$
\end_inset

, a situation which we denote by 
\begin_inset Formula $o\neq\vec{x}\cdot\dots$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the premises of the rules 
\begin_inset Formula $\refrule{U-FlexFlex}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 are not explicitly defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "false"
noprefix "false"

\end_inset

, although for a syntax specified by a binding signature, they have the
 same meaning as in the previous section.
 This is because the generic algorithm works in a more general setting,
 as we are going to explain in the next section, so that they need to be
 customised for each specific situation.
\end_layout

\begin_layout Subsection
Categorification
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:categorification"

\end_inset


\end_layout

\begin_layout Standard
In this section, we define the syntax of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus from a categorical point of view in order to motivate our general
 categorical setting.
 We then explain the semantics of the generic unification algorithm summarised
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Consider the category of functors 
\begin_inset Formula $[\mathbb{\mathbb{F}}_{m},\Set]$
\end_inset

 from 
\begin_inset Formula $\mathbb{\mathbb{F}}_{m}$
\end_inset

, the category of finite cardinals and injections between them, to the category
 of sets.
 A functor 
\begin_inset Formula $X:\mathbb{F}_{m}\rightarrow\Set$
\end_inset

 can be thought of as assigning to each natural number 
\begin_inset Formula $n$
\end_inset

 a set 
\begin_inset Formula $X_{n}$
\end_inset

 of expressions with free variables taken in the set 
\begin_inset Formula $\underline{n}=\{0,\dots,n-1\}$
\end_inset

.
 The action on morphisms of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 means that these expressions support injective renamings.
 Pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus defines such a functor 
\begin_inset Formula $\Lambda$
\end_inset

 by 
\begin_inset Formula $\Lambda_{n}=\{t\ |\ \cdot;n\vdash t\}$
\end_inset

.
 It satisfies the recursive equation 
\begin_inset Formula $\Lambda_{n}\cong\underline{n}+\Lambda_{n}\times\Lambda_{n}+\Lambda_{n+1}$
\end_inset

, where 
\begin_inset Formula $-+-$
\end_inset

 is disjoint union.
 
\end_layout

\begin_layout Standard
In pattern unification, we consider extensions of this syntax with metavariables
 taking a list of distinct variables as arguments.
 As an example, let us add a metavariable of arity 
\begin_inset Formula $p$
\end_inset

.
 The extended syntax 
\begin_inset Formula $\Lambda'$
\end_inset

 defined by 
\begin_inset Formula $\Lambda'_{n}=\{t\ |\ M:p;n\vdash t\}$
\end_inset

 now satisfies the recursive equation 
\begin_inset Formula $\Lambda'_{n}=\underline{n}+\Lambda'_{n}\times\Lambda'_{n}+\Lambda_{n+1}'+Inj(p,n)$
\end_inset

, where 
\begin_inset Formula $Inj(p,n)$
\end_inset

 is the set of injections between the cardinal sets 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

, corresponding to a choice of arguments for the metavariable.
 In fact, 
\begin_inset Formula $Inj(p,n)$
\end_inset

 is nothing but the set of morphisms between 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 in the category 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

, which we denote by 
\begin_inset Formula $\mathbb{F}_{m}(p,n)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Obviously, the functors 
\begin_inset Formula $\Lambda$
\end_inset

 and 
\begin_inset Formula $\Lambda'$
\end_inset

 satisfy similar recursive equations.
 Denoting 
\begin_inset Formula $F$
\end_inset

 the endofunctor on 
\begin_inset Formula $[\mathbb{\mathbb{F}}_{m},\Set]$
\end_inset

 mapping 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $I+X\times X+X_{-+1}$
\end_inset

, where 
\begin_inset Formula $I$
\end_inset

 is the functor mapping 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $\underline{n}$
\end_inset

, the functor 
\begin_inset Formula $\Lambda$
\end_inset

 can be characterised as the initial algebra for 
\begin_inset Formula $F$
\end_inset

, thus satisfying the recursive equation 
\begin_inset Formula $\Lambda\cong F(\Lambda)$
\end_inset

.
 In other words, 
\begin_inset Formula $\Lambda$
\end_inset

 is the free 
\begin_inset Formula $F$
\end_inset

-algebra on the initial functor 
\begin_inset Formula $0$
\end_inset

.
 On the other hand, 
\begin_inset Formula $\Lambda'$
\end_inset

 is characterised as the initial algebra for 
\begin_inset Formula $F(-)+yp$
\end_inset

, where 
\begin_inset Formula $yp$
\end_inset

 is the (representable) functor 
\begin_inset Formula $\mathbb{F}_{m}(p,-):\mathbb{F}_{m}\rightarrow\Set$
\end_inset

, thus satisfying the recursive equation 
\begin_inset Formula $\Lambda'\cong F(\Lambda')+yp$
\end_inset

.
 In other words, 
\begin_inset Formula $\Lambda'$
\end_inset

 is the free 
\begin_inset Formula $F$
\end_inset

-algebra on 
\begin_inset Formula $yp$
\end_inset

.
 Denoting 
\begin_inset Formula $T$
\end_inset

 the free 
\begin_inset Formula $F$
\end_inset

-algebra monad, 
\begin_inset Formula $\Lambda$
\end_inset

 is 
\begin_inset Formula $T(0)$
\end_inset

 and 
\begin_inset Formula $\Lambda'$
\end_inset

 is 
\begin_inset Formula $T(yp)$
\end_inset

.
 Similarly, the functor would be 
\begin_inset Formula $T(yp+yq)$
\end_inset

 corresponds to extending the syntax with another metavariable of arity
 
\begin_inset Formula $q$
\end_inset

.
\end_layout

\begin_layout Standard
In the view to abstracting pattern unification, these observations motivate
 considering functors categories 
\begin_inset Formula $[\mathcal{A},\Set]$
\end_inset

, where 
\begin_inset Formula $\mathcal{A}$
\end_inset

 is a small category where all morphisms are monomorphic (to account for
 the pattern condition enforcing that metavariable arguments are distinct
 variables), together with an endofunctor
\begin_inset Foot
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:endo-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we make explicit assumptions about this endofunctor for the unification
 algorithm to properly generalise.
\end_layout

\end_inset

 
\begin_inset Formula $F$
\end_inset

 on it.
 Then, the abstract definition of a syntax extended with metavariables is
 the free 
\begin_inset Formula $F$
\end_inset

-algebra monad 
\begin_inset Formula $T$
\end_inset

 applied to a finite coproduct of representable functors.
 
\end_layout

\begin_layout Standard
To understand how a unification problem is stated in this general setting
\begin_inset Foot
status open

\begin_layout Plain Layout
What follows is a generalisation of the first-order case explained in 
\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 8"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

, in the sense that we consider a free monad on a presheaf category, rather
 than on sets.
\end_layout

\end_inset

, let us first provide the familiar metavariable context notation with a
 formal meaning.
\end_layout

\begin_layout Notation
\begin_inset CommandInset label
LatexCommand label
name "nota:context"

\end_inset

We denote a finite coproduct 
\begin_inset Formula $\coprod_{i\in\{M,N,\dots\}}yn_{i}$
\end_inset

 of representable functors by a 
\emph on
(metavariable) context
\emph default
 
\begin_inset Formula $M:n_{M},N:n_{N},\dots$
\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

 and 
\begin_inset Formula $\Delta$
\end_inset

 are metavariable contexts, a Kleisli morphism 
\begin_inset Formula $\sigma:\Gamma\rightarrow T\Delta$
\end_inset

 is equivalently given (by the Yoneda Lemma and the universal property of
 coproducts) by a 
\begin_inset Formula $\lambda$
\end_inset

-term 
\begin_inset Formula $\Delta;m_{i}\vdash\sigma_{i}$
\end_inset

 for each 
\begin_inset Formula $i\in\{1,\dots,p\}$
\end_inset

: this is precisely the data for a metavariable substitution 
\begin_inset Formula $\Delta\rightarrow\Gamma$
\end_inset

.
 Thus, Kleisli morphisms are nothing but metavariable substitution.
 Moreover, Kleisli composition correspond to composition of substitutions.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Considering a pair of composable Kleisli morphisms 
\begin_inset Formula $yp\rightarrow T\Gamma$
\end_inset

 and 
\begin_inset Formula $\Gamma\rightarrow T\Delta$
\end_inset

, if we interpret the first one as a term 
\begin_inset Formula $t\in T\Gamma_{p}$
\end_inset

 and the second one as a metavariable substitution 
\begin_inset Formula $\sigma$
\end_inset

, then the composition corresponds to the substituted term 
\begin_inset Formula $t[\sigma]$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A unification problem can be stated as a pair of parallel Kleisli morphisms
 
\begin_inset Formula $\xymatrix{yp\coeqr{t}{u} & T\Gamma}
$
\end_inset

 where 
\begin_inset Formula $\Gamma$
\end_inset

 is a metavariable context, corresponding to selecting a pair of terms 
\begin_inset Formula $\Gamma;p\vdash t,u$
\end_inset

.
 A unifier is nothing but a Kleisli morphism coequalising this pair.
 The property required by the most general unifier means that it is the
 coequaliser, in the full subcategory spanned by coproducts of representable
 functors.
 The main purpose of the pattern unification algorithm consists in constructing
 this coequaliser, if it exists, which is the case as long as there exists
 a unifier, as stated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Main-result"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
Judgments 
\series default
(colimits in 
\begin_inset Formula $\KlD^{*}$
\end_inset

)
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta\quad\Longleftrightarrow\quad\xymatrix{\coprod_{i}Ka_{i}\ar@<+.5ex>[r]^{t}\ar@<-.5ex>[r]_{u} & \Gamma\ar@{-->}[r]^{\sigma} & \Delta}
\text{ is a coequaliser}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\Gamma\prune gf{\sigma}u\dashv\Delta\quad\Longleftrightarrow\begin{array}{c}
\xymatrix{\coprod_{i}Ka_{i}\ar[r]^{{\cal L}^{+}f}\ar[d]_{g} & \coprod_{i}Kb_{i}\ar@{-->}[d]^{u}\\
\Gamma\ar@{-->}[r]_{\sigma} & \Delta
}
\end{array}\text{ is a pushout}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Unification Phase 
\series default
(
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:coequalising-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Note Note
status open

\begin_layout Plain Layout
(
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:coequalising-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\begin_inset Formula 
\[
\unificationempty\quad\unificationtop
\]

\end_inset


\begin_inset Formula 
\[
\labelrule{\unificationstepwise v}{U-Split}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid-rigid (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:rig-rig"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset Formula 
\[
\labelrule{\unificationrigrig}{U-RigRig}\qquad\unificationrigrigneqo
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-*, no cycle (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-star-nocycle"
plural "false"
caps "true"
noprefix "false"

\end_inset

) 
\begin_inset Formula 
\[
\labellabelrule{\unificationoccurcheckeffective}{U-NoCycle}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Flex, same (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-flex-same-metavar"
plural "false"
caps "true"
noprefix "false"

\end_inset

) 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labelrule{\unificationflexflex}{U-FlexFlex}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Rigid, cyclic (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-rig-cyclic"
plural "false"
caps "true"
noprefix "false"

\end_inset

) 
\begin_inset Formula 
\[
\labellabelrule{\unificationfailingoccurcheckeffective}{U-Cyclic}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Pruning phase 
\series default
(
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Note Note
status open

\begin_layout Plain Layout
(
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\begin_inset Formula 
\[
\pruningempty\quad\pruningtop
\]

\end_inset


\begin_inset Formula 
\[
\labelrule{\pruningstepwise 1}{P-Split}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:case-KA-RiTC"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\pruningrig}{P-Rig}\quad\labellabelrule{\pruningrigfail}{P-Fail}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:pruning-metavar"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset Formula 
\[
\labelrule{\pruningflex{}}{P-Flex}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Summary of the rules
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:algo-summary"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We now give the semantics of the generic unification algorithm as summarised
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

, specialised to pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 Let us first rephrase the unification notation in a general category.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this in mind, we can give categorical semantics to the unification
 notation in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 as follows.
\end_layout

\begin_layout Notation
\begin_inset CommandInset label
LatexCommand label
name "nota:coeq"

\end_inset

We denote a coequaliser 
\begin_inset Formula $\xymatrix{A\coeqr{t}{u} & \Gamma\ar@{-->}[r]^{\sigma} & \Delta}
$
\end_inset

 in a category 
\begin_inset Formula $\B$
\end_inset

 by 
\begin_inset Formula $\Gamma\vdash t=_{\B}u\Rightarrow\sigma\dashv\Delta$
\end_inset

, sometimes even omitting 
\begin_inset Formula $\B$
\end_inset

.
\end_layout

\begin_layout Standard
This notation is used in the unification phase, taking 
\begin_inset Formula $\B$
\end_inset

 to be the Kleisli category of 
\begin_inset Formula $T$
\end_inset

 restricted to coproducts of representable functors, and extended with an
 error object 
\begin_inset Formula $\bot$
\end_inset

 (as formally justified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Main-result"
plural "false"
caps "true"
noprefix "false"

\end_inset

), with the exception of the premise of the rule 
\begin_inset Formula $\refrule{U-FlexFlex}$
\end_inset

, where 
\begin_inset Formula $\B=\D$
\end_inset

 is the opposite category of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
 The latter corresponds to the above rule
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:coeq-mvar-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

, whose premise precisely means that 
\begin_inset Formula $\xymatrix{p\ar[r]^{\vec{z}} & n\coeqr{\vec{x}}{\vec{y}} & C}
$
\end_inset

 is indeed an equaliser in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:coprod-list"

\end_inset

In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:coeq"
plural "false"
caps "true"
noprefix "false"

\end_inset

, when 
\begin_inset Formula $A$
\end_inset

 is a coproduct 
\begin_inset Formula $yn_{1}+\dots+yn_{p}$
\end_inset

, then 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 can be thought of as lists of terms 
\begin_inset Formula $\Gamma;n_{i}\vdash t_{i},u_{i}$
\end_inset

, hence the vector notation used in various rules (e.g., 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

).
 Moreover, the usage of comma as a list separator in the conclusion is formally
 justified by the notation 
\begin_inset Formula $a+c\xrightarrow{f,g}b$
\end_inset

 given morphisms 
\begin_inset Formula $a\xrightarrow{f}b\xleftarrow{g}c$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The first structural rule of the unification phase deals with empty lists:
 there is nothing to unify.
 The second rule merely propagates the error.
 We have already explained the 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 rule; it
\end_layout

\end_inset

 Note that the rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 is in fact valid in any category (see
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

).
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this case, 
\begin_inset Formula $a=yn$
\end_inset

, 
\begin_inset Formula $b=T\Gamma$
\end_inset

, and 
\begin_inset Formula $c$
\end_inset

 is a coproduct of representable presheaves and thus 
\begin_inset Formula $g$
\end_inset

 can be thought as a list of terms (
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:coprod-list"
plural "false"
caps "true"
noprefix "false"

\end_inset

), as hinted by the vector notation
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
.
 Moreover, we implicitly assume that 
\begin_inset Formula $c$
\end_inset

 is not the empty coproduct (i.e., 
\begin_inset Formula $\vec{t_{2}}$
\end_inset

 and 
\begin_inset Formula $\vec{u_{2}}_{}$
\end_inset

 are not empty lists).
\end_layout

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The other rules deal with singleton lists.
\end_layout

\end_inset

 The rigid-rigid rules handle all the cases where no metavariable is involved
 at top level.
 In the case of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, the term 
\begin_inset Formula $\Gamma;C\vdash o(\vec{t})$
\end_inset

 denotes a variable, an application, or a 
\begin_inset Formula $\lambda$
\end_inset

-abstraction depending on the label 
\begin_inset Formula $o$
\end_inset

 in 
\begin_inset Formula $O_{C}=\{v_{0},\dots,v_{|C|-1},a,l\}$
\end_inset

.
 Indeed, 
\begin_inset Formula $\vec{t}$
\end_inset

 is a list of terms whose nature depends on 
\begin_inset Formula $o$
\end_inset

.
 We summarise the different situations in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
the table below
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:op-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, where 
\begin_inset Formula $1$
\end_inset

 denotes either a singleton set, either the constant functor 
\begin_inset Formula $\mathbb{F}_{m}\rightarrow\Set$
\end_inset

 mapping anything to a singleton set.
 Note that 
\begin_inset Formula $s$
\end_inset

 is only relevant for the variable case, where it is indeed a choice of
 variable in the ground context 
\begin_inset Formula $C$
\end_inset

.
 For simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus, however, 
\begin_inset Formula $S_{o}$
\end_inset

 would be used to specify the output type of a 
\begin_inset Formula $\lambda$
\end_inset

-abstraction (see 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
fullshort{
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Section 8.1"
key "longgenericunif"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

).
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\color red
I don't understand why there is some much vertical space around this table
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o=\ ?\in O_{C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vec{t}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Empty list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Application
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma;C\vdash t_{1},t_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Abstraction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $l$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma;C,|C|:\tau\vdash t$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
O_{C}=\{v_{0},\dots,v_{|C|-1},a,l\}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Decomposing 
\begin_inset Formula $\Gamma;C\vdash o(\vec{t})$
\end_inset

 for pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:op-lc"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The other rules of the unification phase follow the scheme described in
 the previous section.
\end_layout

\end_inset

 To formally understand the rule 
\begin_inset Formula $\refrule{U-NoCycle}$
\end_inset

 which we have already introduced in the case of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, see
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:u-nocycle"
plural "false"
caps "false"
noprefix "false"

\end_inset

, let us provide the pruning notation with categorical semantics.
\end_layout

\begin_layout Notation
\begin_inset CommandInset label
LatexCommand label
name "nota:pushouts"

\end_inset

We denote a pushout diagram in a category 
\begin_inset Formula $\B$
\end_inset

 as below left by the notation as below right, sometimes even omitting 
\begin_inset Formula $\B$
\end_inset

.
\begin_inset Formula 
\[
\begin{array}{c}
\xymatrix{A\ar[r]^{f}\ar[d]_{t} & \Gamma'\ar@{-->}[d]^{u}\\
\Gamma\ar@{-->}[r]_{\sigma} & \ulcorner\Delta
}
\end{array}\quad\Leftrightarrow\quad\Gamma\prunecat tf{\sigma}u{\B}\dashv\Delta
\]

\end_inset


\end_layout

\begin_layout Standard
Similarly to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:coeq"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this is used in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

, taking 
\begin_inset Formula $\B$
\end_inset

 to be the Kleisli category of 
\begin_inset Formula $T$
\end_inset

 restricted to coproducts of representable functors, and extended with an
 error object 
\begin_inset Formula $\bot$
\end_inset

, with the exception of the premise of the rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

, where 
\begin_inset Formula $\B=\D$
\end_inset

 is the opposite category of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
 The latter corresponds to the above rule
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-mvar-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 whose premise precisely means that the following square is a pullback in
 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
\begin_inset Formula 
\[
\xymatrix{p\ar[r]^{l}\ar[d]_{r} & n\ar[d]^{x}\\
m\ar[r]_{y} & C
}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Again, the rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 is valid in any category (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:p-split"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:pruning-list-notation"

\end_inset

Let us add a few more comments about 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:pushouts"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 First, note that if 
\begin_inset Formula $A$
\end_inset

 is a coproduct 
\begin_inset Formula $yn_{1}+\dots+yn_{p}$
\end_inset

, then 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 can be thought of as lists of terms 
\begin_inset Formula $\Gamma;n_{i}\vdash t_{i}$
\end_inset

 and 
\begin_inset Formula $\Gamma';n_{i}\vdash u_{i}$
\end_inset

.
 In fact, in the situations we will consider, 
\begin_inset Formula $f$
\end_inset

 will be of the shape 
\begin_inset Formula $yn_{1}+\dots+yn_{p}\xrightarrow{f_{1}+\dots+f_{p}}ym_{1}+\dots+ym_{p}$
\end_inset

.
 This explains our usage of 
\begin_inset Formula $+$
\end_inset

 as a list separator 
\begin_inset Note Note
status open

\begin_layout Plain Layout
in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-app-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and
\end_layout

\end_inset

 in the rule 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Next, the formal symbol 
\begin_inset Formula $\maybold M$
\end_inset

 in the premise of
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:u-nocycle"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can now be justified as follows.
 Assume 
\begin_inset Formula $A=yp$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:pushouts"
plural "false"
caps "true"
noprefix "false"

\end_inset

, and take 
\begin_inset Formula $\Gamma'$
\end_inset

 to be the singleton metavariable context 
\begin_inset Formula $(\maybold M:n)$
\end_inset

.
 Then 
\begin_inset Formula $\maybold M(\vec{x})$
\end_inset

 is a term in 
\begin_inset Formula $T\Gamma'_{p}$
\end_inset

, or equivalently, by the Yoneda Lemma, a morphism 
\begin_inset Formula $A\rightarrow T\Gamma'$
\end_inset

, as required of 
\begin_inset Formula $f$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:pushouts"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We now describe the pruning phase as summarised in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
The structural rules of the pruning phase are similar to those of the unificatio
n phase.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
The metavariable pruning case 
\shape smallcaps
P-Flex
\shape default
 is textually similar to the rule
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-mvar-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 As we will see in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
the categorical meaning of the premise is a pushout in 
\begin_inset Formula $\D=\op{\mathbb{F}_{m}}$
\end_inset

, that is, a pullback in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
 And indeed,
\end_layout

\end_inset

 rule
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-mvar-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 precisely means that the following square is a pullback in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
\begin_inset Formula 
\[
\xymatrix{p\ar[r]^{l}\ar[d]_{r} & n\ar[d]^{x}\\
m\ar[r]_{y} & C
}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
The two rigid rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 are concerned with pruning a non metavariable term 
\begin_inset Formula $\Gamma;C\vdash o(\vec{t})$
\end_inset

, where 
\begin_inset Formula $o\in O_{C}$
\end_inset

, as explained above.
 In the case of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, 
\begin_inset Formula $\vec{x}=(x_{1},\dots,x_{n})$
\end_inset

 is a list of distinct variables chosen in a variable context 
\begin_inset Formula $C$
\end_inset

.
 Only one of these two rules applies, depending on whether there exists
 
\begin_inset Formula $o'\in O_{n}$
\end_inset

 such that 
\begin_inset Formula $o=\acton{\vec{x}}{o'}$
\end_inset

, where 
\begin_inset Formula $\acton{\vec{x}}{o'}$
\end_inset

 is 
\begin_inset Formula $v_{x_{i}}$
\end_inset

 if 
\begin_inset Formula $o'=v_{i}$
\end_inset

 or 
\begin_inset Formula $o'$
\end_inset

 otherwise.
 The rule 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 assumes that there is such a 
\begin_inset Formula $o'$
\end_inset

.
 This is trivially the case for application and abstraction.
 Therefore, the rule accounts for
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-app-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-lambda-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The notation 
\begin_inset Formula ${\cal L}^{+}\vec{x}^{o}$
\end_inset

 indeed essentially unfolds to 
\begin_inset Formula $\maybold M_{1}(\vec{x})+\maybold M_{2}(\vec{x})$
\end_inset

 in the application case, and to 
\begin_inset Formula $\maybold M'(C,\vec{x})$
\end_inset

 in the abstraction case.
 The rule 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 applies when there is no such 
\begin_inset Formula $o'$
\end_inset

, a situation which we denote by 
\begin_inset Formula $o\neq\vec{x}\cdot\dots$
\end_inset

.
 In the variable case, these two rules instantiate to
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-var-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
In the case of an application or an abstraction, the second rule never applies,
 and the first rule accounts for the rules
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-lambda-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-app-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Indeed, the notation 
\begin_inset Formula ${\cal L}^{+}f^{o}$
\end_inset

 essentially unfolds to 
\begin_inset Formula $\maybold M_{1}(\vec{x})+\maybold M_{2}(\vec{x})$
\end_inset

 in the application case, and to 
\begin_inset Formula $\maybold M(C,\vec{x})$
\end_inset

 in the abstraction case.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In fact, we need to restrict to functors preserving finite connected limits
 to rule out exotic unifiers.
 For instance, when unifying 
\begin_inset Formula $M(x,y)=M(y,x)$
\end_inset

, the coequaliser in the full Kleisli category is not the substitution of
 
\begin_inset Formula $M$
\end_inset

 with an 
\begin_inset Formula $0$
\end_inset

-ary metavariable, but the substitution that replaces 
\begin_inset Formula $M$
\end_inset

 with a binary commutative metavariable.
 
\end_layout

\end_inset


\color red

\begin_inset Note Note
status open

\begin_layout Plain Layout

\color red
This restriction also helps understanding how useful it is that the pullback
 preservation of the variable functor is crucial.
 Indeed, consider instead the functor ensures that morphisms between representab
le presheaves are epimorphic, which should be useful when unifying a metavariabl
e application to a variable.
 (TODO: understand better).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
where 
\begin_inset Formula $Q$
\end_inset

 is the squash functor, that coincides with 
\begin_inset Formula $y0$
\end_inset

 except on 
\begin_inset Formula $0$
\end_inset

 where it is the empty set.
 Similarly, the coequaliser of 
\begin_inset Formula $M(x,y)=M(y,x)$
\end_inset


\end_layout

\begin_layout Plain Layout
, where a unifier exists, but the coequaliser does not.
 For a simple example, consider the unification problem 
\begin_inset Formula $y2\rightrightarrows Ty1$
\end_inset

 of the same metavariable but applied to a different variable on both hand
 sides.
 Consider indeed the squash functor 
\begin_inset Formula $S$
\end_inset

 that maps 
\begin_inset Formula $0$
\end_inset

 to the empty set and every other finite cardinal to a singleton set.
 Clearly, the morphism 
\begin_inset Formula $y1\rightarrow S\rightarrow T(S)$
\end_inset

 is a unifier.
 Because 
\begin_inset Formula $S_{0}$
\end_inset

 is empty, if 
\begin_inset Formula $y1\rightarrow T\Gamma$
\end_inset

 is the coequaliser, then 
\begin_inset Formula $C_{0}$
\end_inset

 must be empty as well.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Some benefits: we unify the operation and the variable case.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Plan of the paper
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:cat-settings"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we present our categorical setting.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Main-result"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we state the existence of the most general unifier as a categorical property.
 Then we describe the construction of the most general unifier, as summarised
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

, starting with the unification phase (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:coequalising-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the pruning phase (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the occur-check (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:occur-check"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We finally justify completeness in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:completeness"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset

Applications are presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:applications"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
General notations
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, we denote the set 
\begin_inset Formula $\{0,\dots n-1\}$
\end_inset

 by 
\begin_inset Formula $\underline{n}$
\end_inset

.
 
\begin_inset Formula $\op{\B}$
\end_inset

 denotes the opposite category of 
\begin_inset Formula $\B$
\end_inset

.
 If 
\begin_inset Formula $\B$
\end_inset

 is a category and 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are two objects, we denote the set of morphisms between 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 by 
\begin_inset Formula $\hom_{\B}(a,b)$
\end_inset

 or 
\begin_inset Formula $\B(a,b)$
\end_inset

.
 We denote the identity morphism at an object 
\begin_inset Formula $x$
\end_inset

 by 
\begin_inset Formula $1_{x}$
\end_inset

.
 We denote by 
\begin_inset Formula $()$
\end_inset

 any initial morphism and by 
\begin_inset Formula $!$
\end_inset

 any terminal morphism.
 We denote the coproduct of two objects 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 by 
\begin_inset Formula $A+B$
\end_inset

 and the coproduct of a family of objects 
\begin_inset Formula $(A_{i})_{i\in I}$
\end_inset

 by 
\begin_inset Formula $\coprod_{i\in I}A_{i}$
\end_inset

, and similarly for morphisms.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
If 
\begin_inset Formula $(g_{i}:A_{i}\rightarrow B)_{i\in I}$
\end_inset

 is a family of arrows, we denote by 
\begin_inset Formula $[g_{i}]:\coprod_{i\in I}A_{i}\rightarrow B$
\end_inset

 the induced coproduct pairing.
\end_layout

\end_inset

 If 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $g:A'\rightarrow B$
\end_inset

, we  denote the induced morphism 
\begin_inset Formula $A+A'\rightarrow B$
\end_inset

 by 
\begin_inset Formula $f,g$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Conversely, if 
\begin_inset Formula $g:\coprod_{i\in I}A_{i}\rightarrow B$
\end_inset

, we denote by 
\begin_inset Formula $g_{i}$
\end_inset

 the morphism 
\begin_inset Formula $A_{i}\rightarrow\coprod_{i}A_{i}\rightarrow B$
\end_inset

.
\end_layout

\end_inset

 Coproduct injections 
\begin_inset Formula $A_{i}\rightarrow\coprod_{i\in I}A_{i}$
\end_inset

 are typically denoted by 
\begin_inset Formula $in_{i}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Given an adjunction 
\begin_inset Formula $L\dashv R$
\end_inset

 and a morphism 
\begin_inset Formula $f:A\rightarrow RB$
\end_inset

, we denote by 
\begin_inset Formula $f^{*}:LA\rightarrow B$
\end_inset

 its transpose, and similarly, if 
\begin_inset Formula $g:LA\rightarrow B$
\end_inset

, then 
\begin_inset Formula $g^{*}:A\rightarrow RB$
\end_inset

.
\end_layout

\end_inset

 Let 
\begin_inset Formula $T$
\end_inset

 be a monad on a category 
\begin_inset Formula $\B$
\end_inset

.
 We denote its unit by 
\begin_inset Formula $\eta$
\end_inset

, and its Kleisli category by 
\begin_inset Formula $\Kl T$
\end_inset

: the objects are the same as those of 
\begin_inset Formula $\B$
\end_inset

, and a Kleisli morphism from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

 is a morphism 
\begin_inset Formula $A\rightarrow TB$
\end_inset

 in 
\begin_inset Formula $\B$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Any Kleisli morphism 
\begin_inset Formula $f:A\rightarrow TB$
\end_inset

 induces a morphism 
\begin_inset Formula $f^{*}:TA\rightarrow TB$
\end_inset

.
 
\end_layout

\end_inset

 We denote the Kleisli composition of 
\begin_inset Formula $f:A\rightarrow TB$
\end_inset

 and 
\begin_inset Formula $g:TB\rightarrow TC$
\end_inset

 by 
\begin_inset Formula $f[g]:A\rightarrow TC$
\end_inset

.
 
\end_layout

\begin_layout Section
General setting
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:cat-settings"

\end_inset


\end_layout

\begin_layout Standard
In our setting, syntax is specified as an endofunctor 
\begin_inset Formula $F$
\end_inset

 on a category 
\begin_inset Formula $\C$
\end_inset

.
 We introduce conditions for the latter in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:base-cat"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and for the former in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:endo-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Finally, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:examples-settings"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we sketch some examples.
 
\end_layout

\begin_layout Subsection
Base category
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:base-cat"

\end_inset


\end_layout

\begin_layout Standard
We work in a full subcategory 
\begin_inset Formula $\C$
\end_inset

 of functors 
\begin_inset Formula $\mathcal{A}\rightarrow\Set$
\end_inset

, namely, those preserving finite connected limits, where 
\begin_inset Formula $\mathcal{A}$
\end_inset

 is a small category in which all morphisms are 
\begin_inset Note Note
status open

\begin_layout Plain Layout
regular
\end_layout

\end_inset

 monomorphisms and has finite connected limits.
 
\end_layout

\begin_layout Example
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generalise"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we considered 
\begin_inset Formula $\mathcal{A}=\mathbb{F}_{m}$
\end_inset

 the category of finite cardinals and injections.
 Note that 
\begin_inset Formula $\C$
\end_inset

 is equivalent to the category of nominal sets
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "PittsAM:newaas"
literal "false"

\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:res-monad"

\end_inset

 The main property that justifies unification of two metavariables as an
 equaliser or a pullback in 
\begin_inset Formula ${\cal A}$
\end_inset

 is that given any metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

, the functor 
\begin_inset Formula $T\Gamma:{\cal A}\rightarrow\Set$
\end_inset

 preserves them, i.e., 
\begin_inset Formula $T\Gamma\in\C$
\end_inset

.
 In fact, the argument works not only in the category of metavariable contexts
 and substitutions, but also in the (larger) category of objects of 
\begin_inset Formula $\C$
\end_inset

 and Kleisli morphisms between them.
 However, counter-examples can be found in the total Kleisli category.
 Consider indeed the unification problem 
\begin_inset Formula $M(x,y)=M(y,x)$
\end_inset

, in the example of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 We can define
\begin_inset Foot
status open

\begin_layout Plain Layout
Define 
\begin_inset Formula $P_{n}$
\end_inset

 as the set of two-elements sets of 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
\end_layout

\end_inset

 a functor 
\begin_inset Formula $P$
\end_inset

 that does not preserve finite connected colimits such that 
\begin_inset Formula $T(P)$
\end_inset

 is the syntax extended with a binary commutative metavariable 
\begin_inset Formula $M'(-,-)$
\end_inset

.
 Then, the most general unifier, computed in the total Kleisli category,
 replaces 
\begin_inset Formula $M$
\end_inset


\color red
 
\color inherit
with 
\begin_inset Formula $P$
\end_inset

.
 But in the Kleisli category restricted to coproducts of representable functors,
 or more generally, to objects of 
\begin_inset Formula $\C$
\end_inset

, the coequaliser replaces 
\begin_inset Formula $M$
\end_inset

 with a constant metavariable, as expected.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:ar-A"

\end_inset

The category 
\begin_inset Formula ${\cal A}$
\end_inset

 is intuitively the category of metavariable arities.
 A morphism in this category can be thought of as data to substitute a metavaria
ble 
\begin_inset Formula $M:a$
\end_inset

 with another.
 For example, in the case of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, replacing a metavariable 
\begin_inset Formula $M:m$
\end_inset

 with a metavariable 
\begin_inset Formula $N:n$
\end_inset

 amounts to a choice of distinct variables 
\begin_inset Formula $x_{1},\dots,x_{n}\in\{0,\dots,m-1\}$
\end_inset

, i.e., a morphism 
\begin_inset Formula $\hom_{\mathbb{F}_{m}}(n,m)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is to ensure correctness of the unification of two metavariables.
 For instance, the most general unifier of 
\begin_inset Formula $M(x)$
\end_inset

 and 
\begin_inset Formula $M(y)$
\end_inset

 is computed as the metavariable 
\begin_inset Formula $M$
\end_inset

 with a 
\begin_inset Formula $0$
\end_inset

-ary metavariable 
\begin_inset Formula $N$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "rem:regular-mono"

\end_inset

Regularity of monomorphisms (i.e., the fact that monomorphisms are equalisers)
 implies their effectivity (i.e., they are the equalisers of their cokernel
 pairs) because the category has pullbacks.
 In fact, this condition is not strictly needed, but it will allow us (by
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:effective-epi"
plural "false"
caps "true"
noprefix "false"

\end_inset

 below) to convert a factorisation problem (does 
\begin_inset Formula $g:A\rightarrow X$
\end_inset

 factors through 
\begin_inset Formula $e:A\twoheadrightarrow B$
\end_inset

?) into an equality check (does 
\begin_inset Formula $e$
\end_inset

 coequalises the kernel pair of 
\begin_inset Formula $g$
\end_inset

?), during the pruning phase (see Equation
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pruning-facto-wo-regular"
plural "false"
caps "true"
noprefix "false"

\end_inset

) making our description more effective.
 This happens, for instance, when checking that a variable occurs or not
 in some metavariable application.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
A useful lemma that we will exploit is the following:
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:lims-coprod-pw"

\end_inset


\begin_inset Formula $\C$
\end_inset

 is closed under limits, coproducts, and filtered colimits.
 Moreover, it is cocomplete.
\end_layout

\begin_layout Long Proof
Cocompleteness follows from 
\begin_inset CommandInset citation
LatexCommand cite
after "Remark 1.56"
key "Adamek"
literal "false"

\end_inset

, since 
\begin_inset Formula $\C$
\end_inset

 is the category of models of a limit sketch, and is thus locally presentable,
 by
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Proposition 1.51"
key "Adamek"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Long Proof
For the claimed closure property, all we have to check is that limits, coproduct
s, and filtered colimits of functors preserving finite connected limits
 still preserve finite connected limits.
 The case of limits is clear, since limits commute with limits.
 The same argument applies for coproducts and filtered colimits: they commute
 with finite connected limits 
\begin_inset CommandInset citation
LatexCommand cite
after "Example 1.3.(vi)"
key "classificationaccessible"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We will never unfold the definition of 
\begin_inset Formula $\C$
\end_inset

 afterwards.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Property
The following hold.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
roman{enumi}), ref=
\backslash
thetheorem.(
\backslash
roman{enumi})
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 is fully faithful.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "assu:presentable"

\end_inset


\begin_inset Formula $\C$
\end_inset

 is cocomplete.
\end_layout

\end_deeper
\begin_layout Long Proof
We prove the second item.
 
\begin_inset Formula $\C$
\end_inset

 is the category of models of a limit sketch, and thus is locally presentable,
 by
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Proposition 1.51"
key "Adamek"
literal "false"

\end_inset

.
 As a result, it is bicomplete 
\begin_inset CommandInset citation
LatexCommand cite
after "Remark 1.56"
key "Adamek"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Presentability ensures (in particular) that 
\begin_inset Formula $\C$
\end_inset

 is bicomplete.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We need those cocompleteness properties so that we can compute free monads
 of a finitary endofunctor as the colimit of an initial chain.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Completeness ensures that this free monad is algebraically free (not sure
 if it is helpful).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By right continuity of the homset bifunctor, any representable functor is
 in 
\begin_inset Formula $\C$
\end_inset

 and thus the embedding 
\begin_inset Formula $\C\rightarrow[\mathcal{A},\Set]$
\end_inset

 factors the Yoneda embedding 
\begin_inset Formula $\op{\mathcal{A}}\rightarrow[\mathcal{A},\Set]$
\end_inset

.
 
\end_layout

\begin_layout Notation
We set 
\begin_inset Formula $\D=\op{{\cal A}}$
\end_inset

 and denote the fully faithful Yoneda embedding as 
\begin_inset Formula $\D\xrightarrow{K}\C$
\end_inset

.
 We denote by 
\begin_inset Formula $\D^{+}\xrightarrow{K^{+}}\C$
\end_inset

 the full subcategory of 
\begin_inset Formula $\C$
\end_inset

 consisting of finite coproducts of objects of 
\begin_inset Formula $\D$
\end_inset

.
 Moreover, we adopt 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:context"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for objects of 
\begin_inset Formula $\D^{+}$
\end_inset

, that is, a coproduct 
\begin_inset Formula $\coprod_{i\in\{M,N,\dots\}}Ka_{i}$
\end_inset

 is denoted by a 
\emph on
(metavariable) context
\emph default
 
\begin_inset Formula $M:a_{M},N:a_{N},\dots$
\end_inset

 
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:D-finite-family"

\end_inset


\begin_inset Formula $\D^{+}$
\end_inset

 is equivalent to the category of finite families of objects of 
\begin_inset Formula ${\cal A}$
\end_inset

.
 Thinking of objects of 
\begin_inset Formula ${\cal A}$
\end_inset

 as metavariable arities (
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:ar-A"
plural "false"
caps "true"
noprefix "false"

\end_inset

), 
\begin_inset Formula $\D^{+}$
\end_inset

 can be thought of as the category of metavariable contexts.
\end_layout

\begin_layout Standard
We now abstract the situation by listing a number of properties that we
 will use to justify the unification algorithm.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We will be interested in coequalisers in the Kleisli category restricted
 to 
\begin_inset Formula $\D^{+}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Property
The following properties hold.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
roman{enumi}), ref=
\backslash
theproperty.(
\backslash
roman{enumi})
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "assu:finite-connected"

\end_inset

 
\begin_inset Formula $\D$
\end_inset

 has finite connected colimits.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "assu:K-finite-connected"

\end_inset


\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 preserves finite connected colimits.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "assu:epis"

\end_inset

Given any morphism 
\begin_inset Formula $f:a\rightarrow b$
\end_inset

 in 
\begin_inset Formula $\D$
\end_inset

, the morphism 
\begin_inset Formula $Kf$
\end_inset

 is epimorphic.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "assu:inj-are-mono"

\end_inset

Coproduct injections 
\begin_inset Formula $A_{i}\rightarrow\coprod_{j}A_{j}$
\end_inset

 in 
\begin_inset Formula $\C$
\end_inset

 are monomorphisms.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "assu:connected"

\end_inset

For each 
\begin_inset Formula $d\in\D$
\end_inset

, the object 
\begin_inset Formula $Kd$
\end_inset

 is connected, i.e., any morphism 
\begin_inset Formula $Kd\rightarrow\coprod_{i}A_{i}$
\end_inset

 factors through exactly one coproduct injection 
\begin_inset Formula $A_{j}\rightarrow\coprod_{i}A_{i}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is to deal with the case 
\begin_inset Formula $M(f)=N(g)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Remark
I think that the algorithm still works without this assumption: it is just
 that at some point we need to compute a colimit of elements of 
\begin_inset Formula $\D$
\end_inset

, in particular in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-flex-same-metavar"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We already know that such a colimit exists in 
\begin_inset Formula $\C$
\end_inset

, but in concrete examples, but we need to compute them in 
\begin_inset Formula $\D$
\end_inset

 so that we can chain the coequalisers when unifying multiple terms.
 
\end_layout

\end_inset


\end_layout

\begin_layout Long Proof

\emph on
(i)
\emph default
 We assume that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits.
 Hence, its opposite category 
\begin_inset Formula $\D=\op{{\cal A}}$
\end_inset

 has finite connected colimits.
\end_layout

\begin_layout Long Proof

\emph on
(ii)
\emph default
 Let 
\begin_inset Formula $y:\op{\mathcal{A}}\rightarrow[\mathcal{A},\Set]$
\end_inset

 denote the Yoneda embedding and 
\begin_inset Formula $J:\C\rightarrow[\mathcal{A},\Set]$
\end_inset

 denote the canonical embedding, so that 
\begin_inset Formula 
\begin{equation}
y=J\circ K.\label{eq:def-y}
\end{equation}

\end_inset

Now consider a finite connected limit 
\begin_inset Formula $\lim F$
\end_inset

 in 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
 Then, 
\begin_inset Formula 
\begin{align*}
\C(K\lim F,X) & \cong[{\cal A},\Set](JK\lim F,JX)\tag{\ensuremath{J} is fully faithful}\\
 & \cong[\mathcal{A},\Set](y\lim F,JX)\tag{By \prettyref{eq:def-y}}\\
 & \cong JX(\lim F)\tag{By the Yoneda Lemma.}\\
 & \cong\lim(JX\circ F)\tag{\ensuremath{X} preserves finite connected limits}\\
 & \cong\lim([\mathcal{A},\Set](yF-,JX)]\tag{By the Yoneda Lemma}\\
 & \cong\lim([\mathcal{A},\Set](JKF-,JX)]\tag{By \prettyref{eq:def-y}}\\
 & \cong\lim\C(KF-,X)\tag{\ensuremath{J} is full and faithful}\\
 & \cong\C(\colim KF,X)\tag{By left continuity of the hom-set bifunctor}
\end{align*}

\end_inset

Thus, 
\begin_inset Formula $K\lim F\cong\colim KF$
\end_inset

.
\end_layout

\begin_layout Long Proof

\emph on
(iii)
\emph default
 A morphism 
\begin_inset Formula $f:a\rightarrow b$
\end_inset

 is epimorphic if and only if the following square is a pushout 
\begin_inset CommandInset citation
LatexCommand cite
after "Exercise III.4.4"
key "MacLane:cwm"
literal "false"

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
YADE DIAGRAM {"graph":{"edges":[{"from":0,"id":4,"label":{"label":"f","style":{"
alignment":"left","bend":0,"dashed":false,"double":false,"head":"default","posit
ion":0.5,"tail":"none"}},"to":1},{"from":1,"id":5,"label":{"label":"","style":{"a
lignment":"left","bend":0,"dashed":false,"double":true,"head":"none","position":
0.5,"tail":"none"}},"to":2},{"from":0,"id":6,"label":{"label":"f","style":{"align
ment":"right","bend":0,"dashed":false,"double":false,"head":"default","position"
:0.5,"tail":"none"}},"to":3},{"from":3,"id":7,"label":{"label":"","style":{"align
ment":"left","bend":0,"dashed":false,"double":true,"head":"none","position":0.5,"
tail":"none"}},"to":2}],"latexPreamble":"","nodes":[{"id":0,"label":{"isMath":tr
ue,"label":"A","pos":[300,100]}},{"id":1,"label":{"isMath":true,"label":"B","pos
":[500,100]}},{"id":2,"label":{"isMath":true,"label":"B","pos":[500,300]}},{"id"
:3,"label":{"isMath":true,"label":"A","pos":[300,300]}}],"sizeGrid":200},"versio
n":5}
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJBIl0sWzEsMCwiQiJdLFsxLDEsIkIiXSxbMCwxLCJBI
l0sWzAsMSwiZiJdLFsxLDIsIiIsMCx7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub
25lIn19fV0sWzAsMywiZiIsMl0sWzMsMiwiIiwwLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsib
mFtZSI6Im5vbmUifX19XV0= 
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	a & b 
\backslash

\backslash
 	b & b 	
\backslash
arrow["f", from=1-1, to=1-2] 	
\backslash
arrow[Rightarrow, no head, from=1-2, to=2-2] 	
\backslash
arrow["f"', from=1-1, to=2-1] 	
\backslash
arrow[Rightarrow, no head, from=2-1, to=2-2] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We conclude by 
\emph on
(ii)
\emph default

\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset

, because all morphisms in 
\begin_inset Formula $\D=\op{{\cal A}}$
\end_inset

 are epimorphic by assumption.
\end_layout

\end_deeper
\begin_layout Long Proof

\emph on
(iv)
\emph default
 This follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lims-coprod-pw"
plural "false"
caps "true"
noprefix "false"

\end_inset

, because a morphism 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 is monomorphic if and only if the following square is a pullback
\end_layout

\begin_layout Long Proof
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	A & A 
\backslash

\backslash
 	A & B 	
\backslash
arrow["f", from=1-2, to=2-2] 	
\backslash
arrow[equal, from=1-1, to=1-2] 	
\backslash
arrow["f"', from=2-1, to=2-2] 	
\backslash
arrow[Rightarrow, no head, from=1-1, to=2-1] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Long Proof

\emph on
(v)
\emph default
 This follows from coproducts being computed pointwise (
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lims-coprod-pw"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and representable functors being connected, by the Yoneda Lemma.
\end_layout

\begin_layout Remark
Continuing 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:res-monad"
plural "false"
caps "true"
noprefix "false"

\end_inset

, unification of two metavariables as pullbacks or equalisers in 
\begin_inset Formula ${\cal A}$
\end_inset

 crucially relies on 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

, which holds because we restrict to functors preserving finite connected
 limits.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following two properties are direct consequences of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lims-coprod-pw"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\C(Kd,-)$
\end_inset

 preserves coproducts
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(i.e., 
\begin_inset Formula $d$
\end_inset

 is connected) and filtered colimits (TODO: do we really need the latter?).
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
coproducts of filtered cat?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is useful to know to factor 
\begin_inset Formula $Kd\rightarrow A+B$
\end_inset

 as 
\begin_inset Formula $Kd\rightarrow A$
\end_inset

 or 
\begin_inset Formula $Kd\rightarrow B$
\end_inset

, or to show non-existence of a unifier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Property
\begin_inset CommandInset label
LatexCommand label
name "assu:compact"

\end_inset

For each 
\begin_inset Formula $d\in\D$
\end_inset

, the object 
\begin_inset Formula $Kd$
\end_inset

 is finitely presentable, i.e., 
\begin_inset Formula $\C(Kd,-)$
\end_inset

 preserves filtered colimits.
\end_layout

\begin_layout Plain Layout
This is used to prove correctness of the occur-check by induction.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\C$
\end_inset

 is extensive
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Proposition 2.14"
key "ExtensiveCats"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Itemize
sums are disjoints, i.e., coproduct injections 
\begin_inset Formula $A\hookrightarrow A+B\hookleftarrow B$
\end_inset

 are monomorphic, and their pullback is the initial object 
\begin_inset Formula $0$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNCxbMCwwLCIwIl0sWzEsMCwiQSJdLFsxLDEsIkErQiJdLFswLDEsI
kIiXSxbMCwxXSxbMSwyLCIiLDAseyJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJob29rIiwic2lkZSI6I
nRvcCJ9fX1dLFswLDNdLFszLDIsIiIsMCx7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Imhvb2siLCJza
WRlIjoidG9wIn19fV1d 
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	0 & A 
\backslash

\backslash
 	B & {A+B} 	
\backslash
arrow[from=1-1, to=1-2] 	
\backslash
arrow[hook, from=1-2, to=2-2] 	
\backslash
arrow[from=1-1, to=2-1] 	
\backslash
arrow[hook, from=2-1, to=2-2] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
sums are universal: for any morphism 
\begin_inset Formula $P\rightarrow A+B$
\end_inset

, the object 
\begin_inset Formula $P$
\end_inset

 is the coproduct of 
\begin_inset Formula $A'$
\end_inset

 and 
\begin_inset Formula $B'$
\end_inset

, defined as pullbacks of 
\begin_inset Formula $P$
\end_inset

 along the coproduct injections:
\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
YADE DIAGRAM {"graph":{"edges":[{"from":0,"id":6,"label":{"label":"","style":{"a
lignment":"left","bend":0,"dashed":false,"double":false,"head":"default","positi
on":0.5,"tail":"none"}},"to":1},{"from":2,"id":7,"label":{"label":"","style":{"al
ignment":"left","bend":0,"dashed":false,"double":false,"head":"default","positio
n":0.5,"tail":"none"}},"to":1},{"from":3,"id":8,"label":{"label":"","style":{"ali
gnment":"left","bend":0,"dashed":false,"double":false,"head":"default","position
":0.5,"tail":"none"}},"to":1},{"from":4,"id":9,"label":{"label":"","style":{"alig
nment":"left","bend":0,"dashed":false,"double":false,"head":"default","position"
:0.5,"tail":"none"}},"to":2},{"from":4,"id":10,"label":{"label":"","style":{"alig
nment":"left","bend":0,"dashed":false,"double":false,"head":"default","position"
:0.5,"tail":"none"}},"to":3},{"from":5,"id":11,"label":{"label":"","style":{"alig
nment":"left","bend":0,"dashed":false,"double":false,"head":"default","position"
:0.5,"tail":"none"}},"to":0},{"from":5,"id":12,"label":{"label":"","style":{"alig
nment":"left","bend":0,"dashed":false,"double":false,"head":"default","position"
:0.5,"tail":"none"}},"to":3}],"latexPreamble":"","nodes":[{"id":0,"label":{"isMat
h":true,"label":"A","pos":[500,100]}},{"id":1,"label":{"isMath":true,"label":"A+
B","pos":[700,100]}},{"id":2,"label":{"isMath":true,"label":"B","pos":[900,100]}
},{"id":3,"label":{"isMath":true,"label":"P","pos":[700,300]}},{"id":4,"label":{
"isMath":true,"label":"B'","pos":[900,300]}},{"id":5,"label":{"isMath":true,"lab
el":"A'","pos":[500,300]}}],"sizeGrid":200},"version":5}
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNixbMCwwLCJBIl0sWzEsMCwiQStCIl0sWzIsMCwiQiJdLFsxLDEsI
lAiXSxbMiwxLCJCJyJdLFswLDEsIkEnIl0sWzAsMV0sWzIsMV0sWzMsMV0sWzQsMl0sWzQsM10sWzUsM
F0sWzUsM11d
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	A & {A+B} & B 
\backslash

\backslash
 	{A'} & P & {B'} 	
\backslash
arrow[from=1-1, to=1-2] 	
\backslash
arrow[from=1-3, to=1-2] 	
\backslash
arrow[from=2-2, to=1-2] 	
\backslash
arrow[from=2-3, to=1-3] 	
\backslash
arrow[from=2-3, to=2-2] 	
\backslash
arrow[from=2-1, to=1-1] 	
\backslash
arrow[from=2-1, to=2-2] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Using 
\begin_inset CommandInset citation
LatexCommand cite
after "Proposition 2.14"
key "ExtensiveCats"
literal "false"

\end_inset

, this is a direct consequence of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lims-coprod-pw"
plural "false"
caps "true"
noprefix "false"

\end_inset

, since the category of sets is itself extensive.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We will use the following corollaries.
\end_layout

\begin_layout Corollary
The pullback of 
\begin_inset Formula $A+B\rightarrow C\leftarrow D$
\end_inset

 is computed as the coproduct of 
\begin_inset Formula $A\times_{C}D$
\end_inset

 and 
\begin_inset Formula $B\times_{C}D$
\end_inset

.
\end_layout

\begin_layout Proof
By 
\begin_inset CommandInset citation
LatexCommand cite
after "Corollary 4.9"
key "ExtensiveCats"
literal "false"

\end_inset

, since 
\begin_inset Formula $\C$
\end_inset

 is complete (
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:presentable"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
There is no commutative square of the shape
\begin_inset Formula 
\[
\xymatrix{Kd\ar[r]\ar[d] & A\ar[d]\\
B\ar[r] & A+B
}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
This is useful to show in-existence of unifier.
\end_layout

\begin_layout Proof
By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:connected-no-commuting"
plural "false"
caps "true"
noprefix "false"

\end_inset

, since 
\begin_inset Formula $Kd$
\end_inset

 is connected (
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The endofunctor for syntax
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:endo-syntax"

\end_inset


\end_layout

\begin_layout Standard
We assume given an endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[\mathcal{A},\Set]$
\end_inset

 defined by 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\coprod_{o\in O}\prod_{j\in J_{o}}X\circ L_{o,j}\times S_{o},
\]

\end_inset

 for some set 
\begin_inset Formula $O$
\end_inset

 of 
\emph on
operation
\emph default
s, where for each 
\begin_inset Formula $o\in O$
\end_inset

, 
\begin_inset Formula $S_{o}\in\C$
\end_inset

, 
\begin_inset Formula $J_{o}$
\end_inset

 is a finite set (the 
\emph on
arity
\emph default
 of the operation 
\begin_inset Formula $o$
\end_inset

), and 
\begin_inset Formula $L_{o,j}$
\end_inset

 is an endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 preserving finite connected limits for each 
\begin_inset Formula $j\in J_{o}$
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Formula 
\[
F(X)_{a}=\coprod_{o\in O_{a}}\prod_{j\in J_{o,a}}X_{L_{o,j,a}},
\]

\end_inset

 for some functors 
\begin_inset Formula $O:{\cal A}\rightarrow\Set$
\end_inset

, 
\begin_inset Formula $J:\op{(\int O)}\rightarrow\mathbb{F}$
\end_inset

 and 
\begin_inset Formula $L:\op{(\int J)}\rightarrow{\cal A}$
\end_inset

, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
such that 
\begin_inset Formula $J$
\end_inset

 preserving finite connected colimits in 
\begin_inset Formula $\op{\int O}$
\end_inset

, while 
\begin_inset Formula $O$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 preserve finite connected limits
\end_layout

\end_inset

, where
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbb{F}$
\end_inset

 is the category of finite cardinals and any morphisms between them;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\int O$
\end_inset

 denotes the category of elements of 
\begin_inset Formula $O$
\end_inset

 whose objects are pairs of an object 
\begin_inset Formula $a$
\end_inset

 of 
\begin_inset Formula ${\cal A}$
\end_inset

 and an element 
\begin_inset Formula $o$
\end_inset

 in 
\begin_inset Formula $O_{a}$
\end_inset

, and morphisms between 
\begin_inset Formula $(a,o)$
\end_inset

 and 
\begin_inset Formula $(a',o')$
\end_inset

 are morphisms 
\begin_inset Formula $f:a\rightarrow a'$
\end_inset

 such that 
\begin_inset Formula $O_{f}(o)=o'$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\int J$
\end_inset

 denotes the category of elements of 
\begin_inset Formula $\int O\xrightarrow{J}\mathbb{F}\hookrightarrow\Set$
\end_inset

.
 Objects are triples 
\begin_inset Formula $(a,o,j)$
\end_inset

, where 
\begin_inset Formula $a$
\end_inset

 is an object of 
\begin_inset Formula ${\cal A}$
\end_inset

, 
\begin_inset Formula $o\in O_{a}$
\end_inset

, and 
\begin_inset Formula $j\in\{0,\dots,J_{a,o}-1\}$
\end_inset

, and a morphism in 
\begin_inset Formula $\int J$
\end_inset

 between 
\begin_inset Formula $(a,o,j)$
\end_inset

 and 
\begin_inset Formula $(a',o',j')$
\end_inset

 is a morphism 
\begin_inset Formula $f:a\rightarrow a'$
\end_inset

 such that 
\begin_inset Formula $o=O_{f}(o')$
\end_inset

 and 
\begin_inset Formula $j'=J_{f}(j)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:lambda-endo"

\end_inset

For pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus where 
\begin_inset Formula ${\cal A}=\mathbb{F}_{m}$
\end_inset

, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
following 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:op-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

,
\end_layout

\end_inset

 we have 
\begin_inset Formula $O_{n}=\{a,l\}+\{v_{i}|0\leq i<n\}$
\end_inset

, and 
\begin_inset Formula $J_{v_{i}}=0$
\end_inset

, 
\begin_inset Formula $J_{a}=2$
\end_inset

, 
\begin_inset Formula $J_{l}=1$
\end_inset

, and 
\begin_inset Formula $L_{n,o,j}=n+1$
\end_inset

 is if 
\begin_inset Formula $o=l$
\end_inset

, or 
\begin_inset Formula $n$
\end_inset

 otherwise.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generalise"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The fact that it preserves pullbacks is crucial when unifying a metavariable
 with a variable, to show that either there is no unifier, either there
 is a coequaliser.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We moreover assume that 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

, i..e, that it maps functors preserving finite connected limits to functors
 preserving finite connected limits.
 This has the following consequence.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:F-restricts-O"

\end_inset


\begin_inset Formula $O$
\end_inset

 preserves finite connected limits.
\end_layout

\begin_layout Long Proof
\begin_inset Formula $O$
\end_inset

 is isomorphic to 
\begin_inset Formula $F(1)$
\end_inset

, where 
\begin_inset Formula $1$
\end_inset

 is the constant functor mapping everything to the singleton set 
\begin_inset Formula $\{0\}$
\end_inset

.
 Since 
\begin_inset Formula $1$
\end_inset

 trivially preserves limits, it is in 
\begin_inset Formula $\C$
\end_inset

 and thus 
\begin_inset Formula $F(1)\cong O$
\end_inset

 also is.
\end_layout

\begin_layout Standard
In 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
fullshort{
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:F-restrict"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Section 2.4"
key "longgenericunif"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

, we provide sufficient and necessary conditions on 
\begin_inset Formula $J$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

 for 
\begin_inset Formula $F$
\end_inset

 to restrict as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $J$
\end_inset

 is induced by a natural transformation 
\begin_inset Formula $\gamma:O\rightarrow\mathbb{N}$
\end_inset

, by 
\begin_inset Formula $J_{a,o}=\underline{\gamma_{a}(o)}$
\end_inset

.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
In this case, 
\begin_inset Formula $L$
\end_inset

 is induced by a family of functors 
\begin_inset Formula $H_{x,j}:\overline{x}\rightarrow{\cal A}$
\end_inset

 for each 
\begin_inset Formula $x\in\colim O$
\end_inset

 and 
\begin_inset Formula $j\in\boldsymbol{\gamma}(x)$
\end_inset

, where 
\begin_inset Formula $\boldsymbol{\gamma}:\colim O\rightarrow\mathbb{N}$
\end_inset

 is the universal morphism induced by 
\begin_inset Formula $\gamma$
\end_inset

, and 
\begin_inset Formula $\overline{x}$
\end_inset

 is the full subcategory of 
\begin_inset Formula $\op{(\int O)}$
\end_inset

 consisting of pairs 
\begin_inset Formula $(a,o)$
\end_inset

 such that 
\begin_inset Formula $x=q_{a}(o)$
\end_inset

, where 
\begin_inset Formula $q_{a}:O(a)\rightarrow\colim O$
\end_inset

 is the canonical coprojection.
 Then, 
\begin_inset Formula $L_{a,o,j}=H_{q_{a}(o),j}$
\end_inset

 
\begin_inset Formula $H_{x,j}$
\end_inset

 there is a simple necessary condition.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
, or equivalently, the functor 
\begin_inset Formula $H'_{\ell,j}:{\cal A}\rightarrow{\cal A}$
\end_inset


\begin_inset Formula 
\[
\coprod H_{\ell,j}(\lim d,x)\rightarrow\int_{i}H_{\ell,j}(d_{i},O_{\ell}(p_{i})(x))
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As a consequence, 
\begin_inset Formula $\int J\cong\coprod_{x\in\colim O}\overline{x}\times\underline{\gamma}(x)$
\end_inset

, where 
\begin_inset Formula $\underline{\gamma}:\colim O\rightarrow\mathbb{N}$
\end_inset

 is the universal morphism induced by 
\begin_inset Formula $\gamma$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Formula $F$
\end_inset

 is finitary and generates a free monad that restricts to a monad 
\begin_inset Formula $T$
\end_inset

 on 
\begin_inset Formula $\C$
\end_inset

.
 Moreover, 
\begin_inset Formula $TX$
\end_inset

 is the initial algebra of 
\begin_inset Formula $Z\mapsto X+FZ$
\end_inset

, as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

.
\end_layout

\begin_layout Long Proof
\begin_inset Formula $F$
\end_inset

 is finitary because filtered colimits commute with finite limits 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem IX.2.1"
key "MacLane:cwm"
literal "false"

\end_inset

 and colimits.
 The free monad construction is due to 
\begin_inset CommandInset citation
LatexCommand cite
key "Reiterman"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
We will be mainly interested in coequalisers in the Kleisli category restricted
 to objects of 
\begin_inset Formula $\D^{+}$
\end_inset

.
\end_layout

\begin_layout Notation
Let 
\begin_inset Formula $\KlD$
\end_inset

 denote the full subcategory of 
\begin_inset Formula $\Kl T$
\end_inset

 consisting of objects in 
\begin_inset Formula $\D^{+}$
\end_inset

.
 Moreover, we denote by 
\begin_inset Formula ${\cal L}^{+}:\D^{+}\rightarrow\KlD$
\end_inset

 the functor which is the identity on objects and postcomposes any morphism
 
\begin_inset Formula $A\rightarrow B$
\end_inset

 by 
\begin_inset Formula $\eta_{B}:B\rightarrow TB$
\end_inset

, and by 
\begin_inset Formula ${\cal L}$
\end_inset

 the functor 
\begin_inset Formula $\D\hookrightarrow\D^{+}\xrightarrow{{\cal L}^{+}}\KlD$
\end_inset

.
\end_layout

\begin_layout Property
\begin_inset CommandInset label
LatexCommand label
name "assu:L-finite-conncted"

\end_inset

The functor 
\begin_inset Formula $\D\xrightarrow{{\cal L}}\KlD$
\end_inset

 preserves finite connected colimits.
\end_layout

\begin_layout Long Proof
\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 preserves finite connected colimits by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:K-finite-connected"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Thus, postcomposition with the left adjoint 
\begin_inset Formula $\C\rightarrow\Kl T$
\end_inset

 yields a functor 
\begin_inset Formula $\D\rightarrow\Kl T$
\end_inset

 preserving those colimits.
 The result follows because this functor factors as 
\begin_inset Formula $\D\xrightarrow{{\cal L}}\KlD\hookrightarrow\Kl T$
\end_inset

, where the right functor is full and faithful.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As anticipated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:res-monad"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is crucial to consider the monad 
\begin_inset Formula $T$
\end_inset

 restricted to 
\begin_inset Formula $\C$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Notation
Given 
\begin_inset Formula $f\in\hom_{\D}(a,b)$
\end_inset

, 
\begin_inset Formula $u:Kb\rightarrow X$
\end_inset

, we denote 
\begin_inset Formula $u\circ Kf$
\end_inset

 by 
\begin_inset Formula $\acton fu$
\end_inset

.
\end_layout

\begin_layout Notation
Given 
\begin_inset Formula $a\in\D$
\end_inset

, 
\begin_inset Formula $o:Ka\rightarrow O$
\end_inset

, we denote 
\begin_inset Formula $\coprod_{j\in J_{a,o}}KL_{a,o,j}$
\end_inset

 by 
\begin_inset Formula $\overline{o}$
\end_inset

.
 Given 
\begin_inset Formula $f\in\hom_{\D}(b,a)$
\end_inset

, we denote the induced morphism 
\begin_inset Formula $\overline{f\cdot o}\rightarrow\overline{o}$
\end_inset

 by 
\begin_inset Formula $f^{o}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:mor-FX"

\end_inset

For any 
\begin_inset Formula $X\in\C$
\end_inset

, a morphism 
\begin_inset Formula $Ka\rightarrow FX$
\end_inset

 is equivalently given by a morphism 
\begin_inset Formula $o\in Ka\rightarrow O$
\end_inset

, and a morphism 
\begin_inset Formula $f:\overline{o}\rightarrow X$
\end_inset

.
\end_layout

\begin_layout Proof
This follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Notation
\begin_inset CommandInset label
LatexCommand label
name "nota:op"

\end_inset

Given 
\begin_inset Formula $o:Ka\rightarrow TX$
\end_inset

 and 
\begin_inset Formula $\vec{t}:\overline{o}\rightarrow TX$
\end_inset

, we denote the induced morphism 
\begin_inset Formula $Ka\rightarrow FTX\hookrightarrow TX$
\end_inset

 by 
\begin_inset Formula $o(\vec{t})$
\end_inset

, where the first morphism 
\begin_inset Formula $Ka\rightarrow FTX$
\end_inset

 is induced by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:mor-FX"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Notation
Let 
\begin_inset Formula $\Gamma=(M_{1}:a_{1},\dots,M_{p}:a_{p})\in\D^{+}$
\end_inset

 and 
\begin_inset Formula $\arg x\in\hom_{{\cal \D}}(a,a_{i})$
\end_inset

, we denote the Kleisli composition 
\begin_inset Formula $Ka\xrightarrow{{\cal L}\arg x}Ka_{i}\xrightarrow{in_{i}}\Gamma$
\end_inset

 by 
\begin_inset Formula $M_{i}(\arg x)\in\hom_{\Kl T}(Ka,\Gamma)=\hom_{\C}(Ka,T\Gamma)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Property
The endofunctor 
\begin_inset Formula $F:\C\rightarrow\C$
\end_inset

 is finitary.
\end_layout

\begin_layout Long Proof
This is a straightforward consequence of Lemmas
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:finitary-restriction"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:lims-coprod-pw"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Together with cocompleteness properties of 
\begin_inset Formula $\C$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:presentable"
plural "false"
caps "true"
noprefix "false"

\end_inset

), this ensures the existence of the (algebraically) free monad generated
 by 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Notation
We denote the free monad 
\begin_inset Formula $F^{*}$
\end_inset

 on 
\begin_inset Formula $F$
\end_inset

 by 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Property
\begin_inset CommandInset label
LatexCommand label
name "assu:F-shape"

\end_inset


\begin_inset Formula $F(X)$
\end_inset

 is of the shape 
\begin_inset Formula $\coprod_{o}R_{o}X\times S_{o}$
\end_inset

, where
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $S_{o}$
\end_inset

 is an object of 
\begin_inset Formula $\C$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $R_{o}$
\end_inset

 is a right adjoint functor
\end_layout

\begin_layout Itemize
its left adjoint 
\begin_inset Formula $L_{i}$
\end_inset

 is such that 
\begin_inset Formula $L_{i}K=\coprod_{j}KL'_{o,j}$
\end_inset

 where 
\begin_inset Formula $L_{o,j}'$
\end_inset

 is an endofunctor on 
\begin_inset Formula $\D$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
for some finite family of endofunctors 
\begin_inset Formula $(L'_{o,j})_{j}$
\end_inset

 on 
\begin_inset Formula ${\cal A}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In fact, using the above property, we can also 
\begin_inset Quotes eld
\end_inset

reconstruct
\begin_inset Quotes erd
\end_inset

 the endofunctor on 
\begin_inset Formula $[\mathcal{A},\Set]=\hat{\D}$
\end_inset

 (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:occur-check"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
a finite colimit is too general, we really need coproducts in the pruning
 phase, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:case-KA-RiTC"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:lambek-lemma"

\end_inset


\begin_inset Formula $T(X)$
\end_inset

 is isomorphic to 
\begin_inset Formula $\coprod_{o}R_{o}T(X)\times S_{o}+X$
\end_inset

.
\end_layout

\begin_layout Proof
By Lambek's lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Lambeklemma"
literal "false"

\end_inset

, applied to the endofunctor 
\begin_inset Formula $F(-)+X$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Property
\begin_inset CommandInset label
LatexCommand label
name "assu:facto-TX"

\end_inset

Let 
\begin_inset Formula $\Gamma=M_{1}:a_{1},\dots,M_{n}:a_{n}\in\D^{+}$
\end_inset

.
 Then, any morphism 
\begin_inset Formula $u:Ka\rightarrow T\Gamma$
\end_inset

 is one of the two mutually exclusive following possibilities:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $M_{i}(\arg x)$
\end_inset

 for some unique 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $\arg x:a\rightarrow a_{i}$
\end_inset

, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $o(\vec{t})$
\end_inset

 for some unique 
\begin_inset Formula $o:Ka\rightarrow O$
\end_inset

 and 
\begin_inset Formula $\vec{t}:\overline{o}\rightarrow T\Gamma$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Property
We say that 
\begin_inset Formula $u$
\end_inset

 is 
\emph on
flexible (flex)
\emph default
 in the first case and 
\emph on
rigid
\emph default
 in the other case.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Property
\begin_inset CommandInset label
LatexCommand label
name "assu:op-subst"

\end_inset

Let 
\begin_inset Formula $\Gamma=M_{1}:a_{1},\dots,M_{n}:a_{n}\in\D^{+}$
\end_inset

 and 
\begin_inset Formula $\sigma:\Gamma\rightarrow T\Delta$
\end_inset

.
 Then, for any 
\begin_inset Formula $o:Ka\rightarrow O$
\end_inset

, 
\begin_inset Formula $\vec{t}:\overline{o}\rightarrow T\Gamma$
\end_inset

, 
\begin_inset Formula $u:b\rightarrow a$
\end_inset

, 
\begin_inset Formula $i\in\{1,\dots,n\}$
\end_inset

, 
\begin_inset Formula $\arg x:a\rightarrow a_{i}$
\end_inset

,
\begin_inset Formula 
\begin{align*}
o(\vec{t})[\sigma] & =o(\vec{t}[\sigma]) & M_{i}(\arg x)[\sigma] & =\acton x{\sigma_{i}}\\
\acton u{(o(\vec{t}))} & =(u\cdot o)(\vec{t}\circ u^{o}) & \acton u{M_{i}(\arg x)} & =M(\arg x\circ u)
\end{align*}

\end_inset


\begin_inset Note Note
status open

\begin_layout Itemize
\begin_inset Formula $o(\vec{t})[\sigma]=o(\vec{t}[\sigma])$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\acton u{(o(\vec{t}))}=(u\cdot o)(\vec{t}\circ u^{o})$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $M_{i}(\arg x)[\sigma]=\acton x{\sigma_{i}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\acton u{M_{i}(\arg x)}=M(\arg x\circ u)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Notation
Let 
\begin_inset Formula $\KlD$
\end_inset

 denote the full subcategory of 
\begin_inset Formula $\Kl T$
\end_inset

 spanned by coproducts of objects in 
\begin_inset Formula ${\cal D}$
\end_inset

.
 We denote by 
\begin_inset Formula $K:\D\rightarrow\KlD$
\end_inset

 the obvious embedding.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:D-kleisli-finite-connected-colims"

\end_inset


\begin_inset Formula $K$
\end_inset

 preserves finite connected colimits.
 
\end_layout

\begin_layout Proof
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:proof-kleisli-finite"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Examples
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:examples-settings"

\end_inset

The following table sketches some examples among those detailed in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Section 8"
key "longgenericunif"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:applications"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 The shape of metavariable arities determine the objects of 
\begin_inset Formula ${\cal A}$
\end_inset

, as hinted by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:ar-A"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In the case of quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus, 
\begin_inset Formula $\bang\Delta$
\end_inset

 consists of non linear types, whereas 
\begin_inset Formula $\Gamma,\Delta$
\end_inset

 consist of linear types only.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Metavariable arity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operations (example)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n\in\mathbb{F}_{m}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
See the introduction.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simply-typed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\underbrace{\tau_{1},\dots,\tau_{n}\vdash\tau_{o}}_{\text{simple types}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{\Gamma\vdash t:\tau_{1}\Rightarrow\tau_{2}\qquad\Gamma\vdash u:\tau_{1}}{\Gamma\vdash t\ u:\tau_{2}}\vphantom{\dfrac{\dfrac{}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
System F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m;\underbrace{\tau_{1},\dots,\tau_{n}\vdash\tau_{o}}_{\mathclap{<\text{ \ensuremath{m} type variables}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{m+1|wk(\Gamma)\vdash t:\tau}{m|\Gamma\vdash\Lambda t:\Lambda\tau}\textsc{Type-Abstr}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{m|\Gamma\vdash t:\Lambda\tau\qquad m\vdash\sigma}{m|\Gamma\vdash t[\sigma]:\tau[*\mapsto\sigma]}\textsc{Type-App}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\tau_{1},\dots,\tau_{n}\vdash\tau_{o}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:B}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{p\vdash t\quad q\vdash u}{p+q\vdash t\ u}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Restricting 
\begin_inset Formula $F$
\end_inset

 as an endofunctor on 
\begin_inset Formula $\C$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:F-restrict"

\end_inset


\end_layout

\begin_layout Standard
In this section, we provide sufficient and necessary conditions for the
 functor 
\begin_inset Formula $F$
\end_inset

 to restrict as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

.
 Let us first introduce some notations.
\end_layout

\begin_layout Notation
Given a functor 
\begin_inset Formula $F:D\rightarrow\B$
\end_inset

, we denote the limit (resp.
 colimit) of 
\begin_inset Formula $F$
\end_inset

 by 
\begin_inset Formula $\int_{d:D}F(d)$
\end_inset

 or 
\begin_inset Formula $\lim F$
\end_inset

 (resp.
 
\begin_inset Formula $\int^{d:D}F(d)$
\end_inset

 or 
\begin_inset Formula $\colim F$
\end_inset

), and the canonical projection 
\begin_inset Formula $\lim F\rightarrow Fd$
\end_inset

 by 
\begin_inset Formula $p_{d}$
\end_inset

.
\end_layout

\begin_layout Notation
We denote the set of connected components of a category 
\begin_inset Formula $D$
\end_inset

 by 
\begin_inset Formula $||D||$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:shape-examples"

\end_inset

In all our examples (see 
\begin_inset CommandInset citation
LatexCommand cite
after "Section 8"
key "longgenericunif"
literal "false"

\end_inset

), 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $O$
\end_inset

 is a coproduct
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $\coprod_{\ell\in V}O_{\ell}$
\end_inset

 for some 
\begin_inset Formula $O_{\ell}:{\cal A}\rightarrow\Set$
\end_inset

 and 
\begin_inset Formula $J_{a,in_{\ell}(o)}=\gamma_{\ell}$
\end_inset

 for some finite cardinal 
\begin_inset Formula $\gamma_{\ell}$
\end_inset

.
 In this case, 
\begin_inset Formula $L$
\end_inset

 is equivalently given by a family of functors 
\begin_inset Formula $H_{\ell,j}:\int O_{\ell}\rightarrow\Set$
\end_inset

 for each 
\begin_inset Formula $j\in\gamma_{\ell}$
\end_inset

 by 
\begin_inset Formula $L_{a,in_{\ell}(o),j}=H_{\ell,j}(a,o)$
\end_inset

.
 Then, 
\begin_inset Formula 
\[
F(X)_{a}\cong\coprod_{\ell\in V}\coprod_{o\in O_{\ell}}\prod_{j\in\gamma_{\ell}}X_{H_{\ell,j}(a,o)}
\]

\end_inset


\end_layout

\begin_layout Standard
In this case there is a simple characterisation.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:F-restricts-simpl"

\end_inset

If 
\begin_inset Formula $O$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

 are in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:shape-examples"
plural "false"
caps "true"
noprefix "false"

\end_inset

, then 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

 if and only if each 
\begin_inset Formula $O_{l}\in\C$
\end_inset

 and each 
\begin_inset Formula $H_{\ell,j}$
\end_inset

 preserves finite limits, or equivalently, the canonical morphism
\begin_inset Formula 
\[
H_{\ell,j}(\lim d,x)\rightarrow\int_{i}H_{\ell,j}(d_{i},O_{\ell}(p_{i})(x))
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
 
\begin_inset Formula $L$
\end_inset

 preserves finite connected limits, or equivalently, for any finite connected
 limit 
\begin_inset Formula $\lim d$
\end_inset

 in 
\begin_inset Formula ${\cal A}$
\end_inset

, 
\begin_inset Formula $x\in O_{\lim d}$
\end_inset

, and 
\begin_inset Formula $\beta\in\underline{\gamma_{\lim d}(x)}$
\end_inset

, the canonical morphism
\begin_inset Formula 
\[
L_{\lim d,x,\beta}\rightarrow\int_{i}L_{d_{i},O_{p_{i}}(x),\beta}
\]

\end_inset


\end_layout

\end_inset

is an isomorphism.
\end_layout

\begin_layout Standard
As we will see, this is a consequence of the following general proposition.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:F-restricts"

\end_inset

The functor 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

 if and only if 
\begin_inset Formula $O\in\C$
\end_inset

 and one of the following conditions hold:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "prop:F-restriction-L-hom-1"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
roman{enumi}), ref=
\backslash
theproposition.(
\backslash
roman{enumi})
\end_layout

\end_inset


\end_layout

\end_inset

for each object 
\begin_inset Formula $b$
\end_inset

 of 
\begin_inset Formula ${\cal A}$
\end_inset

, the functor 
\begin_inset Formula $(a,o)\mapsto\prod_{j\in J_{a,o}}{\cal A}(b,L_{a,o,j})$
\end_inset

 from 
\begin_inset Formula $\op{(\int O)}$
\end_inset

 to 
\begin_inset Formula $\Set$
\end_inset

 preserves finite connected limits;
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "prop:F-restriction-L-hom-2"

\end_inset

for each object 
\begin_inset Formula $b$
\end_inset

 of 
\begin_inset Formula ${\cal A}$
\end_inset

, any functor 
\begin_inset Formula $d:I\rightarrow O$
\end_inset

 with 
\begin_inset Formula $I$
\end_inset

 finite and connected, and for any 
\begin_inset Formula $x\in O_{\lim d}$
\end_inset

, the canonical morphism 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\int^{i:I}\prod_{j\in J_{d_{i},O_{p_{i}}(x)}}{\cal A}(b,L_{d_{i},O_{p_{i}}(x),j})\rightarrow\prod_{j\in J_{\lim d,x}}{\cal A}(b,L_{\lim d,x,j})
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\prod_{j\in J_{\lim d,x}}{\cal A}(b,L_{\lim d,x,j})\rightarrow\int_{i:I}\prod_{j\in J_{d_{i},O_{p_{i}}(x)}}{\cal A}(b,L_{d_{i},O_{p_{i}}(x),j})
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\prod_{j\in J_{\lim d,x}}{\cal A}(b,L_{\lim d,x,j})\rightarrow{\cal A}(b,\int_{(i,j):\int J_{d-,O_{p_{i}}(x)}}L_{d_{i},O_{p_{i}}(x),j})
\]

\end_inset


\end_layout

\end_inset

is an isomorphism.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "prop:F-restriction-L"

\end_inset


\begin_inset Formula $J:\op{(\int O)}\rightarrow\mathbb{F}$
\end_inset

 preserves finitely connected colimits (i.e., it maps finitely connected limits
 in 
\begin_inset Formula $\int O$
\end_inset

 to colimits in 
\begin_inset Formula $\mathbb{F}$
\end_inset

) and for any 
\begin_inset Formula $d:I\rightarrow O$
\end_inset

 with 
\begin_inset Formula $I$
\end_inset

 finite and connected, any 
\begin_inset Formula $x\in O_{\lim d}$
\end_inset

 and 
\begin_inset Formula $\beta\in J_{\lim d,x}$
\end_inset

, the canonical morphism in 
\begin_inset Formula ${\cal A}$
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
L_{\lim d,x,\beta}\rightarrow\int_{i:I}\prod_{\substack{j\\
J_{p_{i}}(j)=\beta
}
}L_{d_{i},O_{p_{i}}(x),j}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
L_{\lim d,x,\beta}\rightarrow\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(x),j}
\]

\end_inset

is an isomorphism, where 
\begin_inset Formula $\overline{\beta}$
\end_inset

 is the full subcategory of 
\begin_inset Formula $\int J_{d-,O_{p_{-}}(x)}$
\end_inset

 consisting of pairs 
\begin_inset Formula $(i,j)$
\end_inset

 such that 
\begin_inset Formula $\beta=J_{p_{i}}(j)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:colim-connected-elt"

\end_inset

The colimit of a functor 
\begin_inset Formula $d:I\rightarrow\Set$
\end_inset

 can be computed as the set 
\begin_inset Formula $||\int d||$
\end_inset

 of connected components of 
\begin_inset Formula $\int d$
\end_inset

.
 In the last condition of the above proposition, 
\begin_inset Formula $\overline{\beta}$
\end_inset

 is equivalently the connected component of 
\begin_inset Formula $\int J_{d-,O_{p-}(x)}$
\end_inset

 corresponding to the element in the colimit 
\begin_inset Formula $\int^{i}J_{d_{i},O_{p_{i}}(x)}$
\end_inset

 which is mapped to 
\begin_inset Formula $\beta\in J_{\lim d,x}$
\end_inset

 by the canonical morphism.
\end_layout

\begin_layout Standard
We have already seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-O"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that if 
\begin_inset Formula $F$
\end_inset

 restricts on 
\begin_inset Formula $\C$
\end_inset

, then 
\begin_inset Formula $O\in\C$
\end_inset

.
 We need a few technical lemmas in order to address the other statements.
\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

[Limits commute with dependent pairs]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lem:lim-commute-dependent-pairs"

\end_inset

Given functors 
\begin_inset Formula $K:D\rightarrow\Set$
\end_inset

 and 
\begin_inset Formula $G:\int K\rightarrow\Set$
\end_inset

, the following canonical morphism is an isomorphism
\begin_inset Formula 
\[
\int_{d:D}\coprod_{x\in K(d)}G(d,x)\rightarrow\coprod_{\alpha\in\lim K}\int_{d}G(d,\alpha_{d})
\]

\end_inset


\end_layout

\begin_layout Proof
It is straightforward to check that both sets share the same universal property.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:data-functor-elt"

\end_inset

Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 be a functor.
 A functor 
\begin_inset Formula $G:D\rightarrow\int F$
\end_inset

 is equivalently given by a functor 
\begin_inset Formula $H:D\rightarrow\B$
\end_inset

 and an element 
\begin_inset Formula $x\in\lim(F\circ H)$
\end_inset

, retrieving 
\begin_inset Formula $G$
\end_inset

 as 
\begin_inset Formula $Gd=(Hd,x_{d})$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Formula $\int F$
\end_inset

 is isomorphic to the opposite of the comma category 
\begin_inset Formula $y/F$
\end_inset

, where 
\begin_inset Formula $y:\op{\B}\rightarrow[\B,\Set]$
\end_inset

 is the Yoneda embedding.
 The statement follows from the universal property of a comma category.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:lim-elt"

\end_inset

Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 preserving a limit 
\begin_inset Formula $\lim G$
\end_inset

.
 Let 
\begin_inset Formula $x\in F\lim G$
\end_inset

, thus inducing a functor 
\begin_inset Formula $G_{x}:D\rightarrow\int F$
\end_inset

 by the previous lemma.
 Then, the limit of 
\begin_inset Formula $G_{x}$
\end_inset

 is 
\begin_inset Formula $(\lim D,x)$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $\C$
\end_inset

 denote the full subcategory of 
\begin_inset Formula $[\B,\Set]$
\end_inset

 of functors preserving 
\begin_inset Formula $\lim G$
\end_inset

.
 Note that 
\begin_inset Formula $\int F$
\end_inset

 is isomorphic to the opposite of the comma category 
\begin_inset Formula $K/F$
\end_inset

, where 
\begin_inset Formula $K:\op{\B}\rightarrow\C$
\end_inset

 is the Yoneda embedding, which preserves 
\begin_inset Formula $\colim G$
\end_inset

, by an argument similar to the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The forgetful functor from a comma category 
\begin_inset Formula $L/R$
\end_inset

 to the product of the categories creates colimits that 
\begin_inset Formula $L$
\end_inset

 preserve.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:preserves-elt"

\end_inset

Given categories 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $\B$
\end_inset

 such that any functor 
\begin_inset Formula $d:I\rightarrow\B$
\end_inset

 has a limit, if a functor 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 preserves each such limit, then the following properties are equivalent
 for a functor 
\begin_inset Formula $G:\int F\rightarrow\B'$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
roman{enumi}), ref=
\backslash
theproperty.(
\backslash
roman{enumi})
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula $G$
\end_inset

 preserves limits over any 
\begin_inset Formula $d':I\rightarrow\int F$
\end_inset

.
\end_layout

\begin_layout Enumerate
For any 
\begin_inset Formula $d:I\rightarrow\B$
\end_inset

 and 
\begin_inset Formula $x\in F\lim d$
\end_inset

, the canonical morphism 
\begin_inset Formula $G(\lim d,x)\rightarrow\int_{i:I}G(d_{i},Fp_{i}(x))$
\end_inset

 is an isomorphism, where 
\begin_inset Formula $p_{i}:\lim d\rightarrow d_{i}$
\end_inset

 is the canonical projection.
\end_layout

\end_deeper
\begin_layout Proof
\begin_inset Formula $(i)\Rightarrow(ii)$
\end_inset

 Define 
\begin_inset Formula $d':I\rightarrow\int F$
\end_inset

 as 
\begin_inset Formula $d'_{i}=(d_{i},Fp_{i}(x))$
\end_inset

.
 The implication follows from 
\begin_inset Formula $\lim d'=(\lim d,x)$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lim-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Formula $(ii)\Rightarrow(i)$
\end_inset

 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:data-functor-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-O"
plural "false"
caps "true"
noprefix "false"

\end_inset

, there exists 
\begin_inset Formula $d:I\rightarrow\B$
\end_inset

 and 
\begin_inset Formula $x\in F\lim d$
\end_inset

 such that 
\begin_inset Formula $d'_{i}=(d_{i},Fp_{i}(x))$
\end_inset

.
 Again, the implication follows from 
\begin_inset Formula $\lim d'=(\lim d,x)$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lim-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Proof
It is straightforward to check that both objects share the same universal
 property.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:colim-commute-dependent-pairs"

\end_inset

Given functors 
\begin_inset Formula $K:D\rightarrow\Set$
\end_inset

 and 
\begin_inset Formula $G:\int K\rightarrow\B$
\end_inset

, the following canonical morphism is an isomorphism
\end_layout

\begin_layout Lemma
\begin_inset Formula 
\[
\int^{d:D}\coprod_{x\in K(d)}G(d,x)\rightarrow\int^{(d,x):\int K}G(d,x)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:colim-connected-component"

\end_inset

Given a functor 
\begin_inset Formula $K:D\rightarrow\B$
\end_inset

, the following canonical morphism is an isomorphism
\begin_inset Formula 
\[
\coprod_{\beta\in||D||}\int^{d:\beta}Kd\rightarrow\int^{d:D}Kd
\]

\end_inset

where 
\begin_inset Formula $||D||$
\end_inset

 is the set of connected components of 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Standard
We now have enough tools to address the proof of 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:F-restricts"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Let us introduce auxiliary lemmas.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
We define the functor 
\begin_inset Formula $M:\op{(\int O)}\rightarrow\C$
\end_inset

 by 
\begin_inset Formula 
\[
M(a,o)=\coprod_{j\in J_{a,o}}KL_{a,o,j}.
\]

\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:F-M"

\end_inset

Given any 
\begin_inset Formula $X\in\C$
\end_inset

 and object 
\begin_inset Formula $a$
\end_inset

 of 
\begin_inset Formula ${\cal A}$
\end_inset

, 
\begin_inset Formula 
\[
F(X)_{a}\cong\coprod_{o\in O_{a}}\C(M(a,o),X)
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:M-preserves"

\end_inset

If 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

, then the functor 
\begin_inset Formula $M$
\end_inset

 preserves finite connected colimits.
\end_layout

\begin_layout Proof
\begin_inset Note Note
status open

\begin_layout Plain Layout
This remark does not make the proof easier; it merely allows us to use 
\begin_inset Formula $K$
\end_inset

 and thus alleviate notations.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-O"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is enough to show that given a functor 
\begin_inset Formula $d:I\rightarrow{\cal A}$
\end_inset

, where 
\begin_inset Formula $I$
\end_inset

 is a finite connected category, the canonical morphism 
\begin_inset Formula $\alpha_{x}:\int^{i}M_{d_{i},O_{p_{i}}(x)}\rightarrow M_{\lim d,x}$
\end_inset

 is an isomorphism, for any 
\begin_inset Formula $x\in O_{\lim d}$
\end_inset

.
\end_layout

\begin_layout Proof
Now, if 
\begin_inset Formula $X\in\C$
\end_inset

, then 
\begin_inset Formula $F(X)_{a}$
\end_inset

 is isomorphic to 
\begin_inset Formula $\coprod_{o\in O_{a}}\C(M_{a,o},X)$
\end_inset

.
 Since then 
\begin_inset Formula $F(X)\in\C$
\end_inset

, the canonical morphism 
\begin_inset Formula $F(X)_{\lim d}\rightarrow\int_{i}F(X)_{d_{i}}$
\end_inset

 is an isomorphism.
 The codomain unfolds as
\color red
 
\color inherit

\begin_inset Formula 
\begin{align*}
\int_{i}F(X)_{d_{i}} & \cong\int_{i:I}\coprod_{o\in O_{d_{i}}}\C(M_{d_{i},o},X)\tag{By \prettyref{rem:F-M}}\\
 & \cong\coprod_{o\in\int_{i}O_{d_{i}}}\int_{i:I}\C(M_{d_{i},o_{i}},X)\tag{By \prettyref{lem:lim-commute-dependent-pairs}}\\
 & \cong\coprod_{o\in O_{\lim d}}\int_{i:I}\C(M_{d_{i},O_{p_{i}}(o)},X)\tag{By \prettyref{lem:F-restricts-O}}\\
 & \cong\coprod_{o\in O_{\lim d}}\C(\int^{i:I}M_{d_{i},O_{p_{i}}(o)},X)\tag{By left cocontinuity of the homset bifunctor}
\end{align*}

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Existence of the colimit in 
\begin_inset Formula $\C$
\end_inset

 is ensured by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lims-coprod-pw"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Now, the domain unfolds as
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\[
F(X)_{\lim d}\cong\coprod_{o\in O_{\lim d}}\C(M_{\lim d,o},X)
\]

\end_inset


\end_layout

\begin_layout Proof
Through these isomorphisms, the canonical morphism 
\begin_inset Formula $F(X)_{\lim d}\rightarrow\int_{i}F(X)_{d_{i}}$
\end_inset

 is
\begin_inset Formula 
\begin{equation}
\coprod_{o\in O_{\lim d}}\C(M_{\lim d,o},X)\xrightarrow{\coprod_{o\in O_{\lim d}}\C(\alpha_{o},X)}\coprod_{o\in O_{\lim d}}\C(\int^{i:I}M_{d_{i},O_{p_{i}}(o)},X)\label{eq:M-preserve}
\end{equation}

\end_inset


\end_layout

\begin_layout Proof
Because it is a bijection, each 
\begin_inset Formula $\C(\alpha_{o},X)$
\end_inset

 also is.
 By the Yoneda lemma, each 
\begin_inset Formula $\alpha_{o}$
\end_inset

 is itself an isomorphism.
\end_layout

\begin_layout Standard
It is easy to see from the proof that the converse implication also holds.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:M-preserves-converse"

\end_inset

If 
\begin_inset Formula $O\in\C$
\end_inset

 and the functor 
\begin_inset Formula $M$
\end_inset

 preserves finite connected colimits, then 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

.
\end_layout

\begin_layout Proof
It easily follows from the fact that 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:M-preserve"
plural "false"
caps "true"
noprefix "false"

\end_inset

 is an isomorphism if and only if each 
\begin_inset Formula $\alpha_{o}$
\end_inset

 is.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:F-restricts-J"

\end_inset

If 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

, then 
\begin_inset Formula $J:\op{(\int O)}\rightarrow\mathbb{F}$
\end_inset

 preserves finite connected colimits.
\end_layout

\begin_layout Proof
By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-O"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is enough to show that given a functor 
\begin_inset Formula $d:I\rightarrow{\cal A}$
\end_inset

, where 
\begin_inset Formula $I$
\end_inset

 is a finite connected category, the canonical morphism 
\begin_inset Formula $\alpha_{x}:\int^{i}J_{d_{i},O_{p_{i}}(x)}\rightarrow J_{\lim d,x}$
\end_inset

 is an isomorphism, for any 
\begin_inset Formula $x\in O_{\lim d}$
\end_inset

.
\end_layout

\begin_layout Proof
Given a set 
\begin_inset Formula $X$
\end_inset

, we denote by 
\begin_inset Formula $\underline{X}:{\cal A}\rightarrow\Set$
\end_inset

 the constant functor mapping anything to 
\begin_inset Formula $X$
\end_inset

.
 Since 
\begin_inset Formula $\underline{X}$
\end_inset

 preserves finite connected limits, 
\begin_inset Formula $F(\underline{X})$
\end_inset

 also does.
 Thus, we know that the canonical morphism 
\begin_inset Formula $F(\underline{X})_{\lim d}\rightarrow\int_{i:I}F(\underline{X})_{d_{i}}$
\end_inset

 is an isomorphism.
 The codomain unfolds as
\begin_inset Formula 
\begin{align*}
\int_{i:I}F(\underline{X})_{d_{i}} & \cong\int_{i:I}{\displaystyle \coprod_{o\in O_{d_{i}}}}X^{J_{d_{i},o}}\\
 & \cong\coprod_{o\in\int_{i}O_{d_{i}}}\int_{i:I}X^{J_{d_{i},o_{i}}}\tag{By \prettyref{lem:colim-commute-dependent-pairs}}\\
 & \cong\coprod_{o\in O_{\lim d}}\int_{i:I}X^{J_{d_{i},O_{p_{i}}(o)}}\tag{By \prettyref{lem:F-restricts-O}}\\
 & \cong\coprod_{o\in O_{\lim d}}X^{\int^{i:I}J_{d_{i},O_{p_{i}}(o)}}\tag{By left cocontinuity of the homset bifunctor}
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
The domain unfolds as
\begin_inset Formula 
\begin{align*}
F(\underline{X})_{\lim d} & \cong{\displaystyle \coprod_{o\in O_{\lim d}}}X^{J_{\lim d,o}}
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Through these isomorphisms, the canonical morphism 
\begin_inset Formula $F(\underline{X})_{\lim d}\rightarrow\int_{i:I}F(\underline{X})_{d_{i}}$
\end_inset

 becomes
\begin_inset Formula 
\[
{\displaystyle \coprod_{o\in O_{\lim d}}}X^{J_{\lim d,o}}\xrightarrow{\coprod_{o\in O_{\lim d}}X^{\alpha_{o}}}\coprod_{o\in O_{\lim d}}X^{\int^{i:I}J_{d_{i},O_{p_{i}}(o)}}
\]

\end_inset

 Because it is a bijection, each 
\begin_inset Formula $X^{\alpha_{o}}$
\end_inset

 also is.
 Since this is true for any set 
\begin_inset Formula $X$
\end_inset

, by the Yoneda lemma, each 
\begin_inset Formula $\alpha_{o}$
\end_inset

 is itself an isomorphism.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:F-restricts-L"

\end_inset

If 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

, then for any 
\begin_inset Formula $d:I\rightarrow O$
\end_inset

 with 
\begin_inset Formula $I$
\end_inset

 finite and connected, any 
\begin_inset Formula $x\in O_{\lim d}$
\end_inset

 and 
\begin_inset Formula $\beta\in J_{\lim d,x}$
\end_inset

, the canonical morphism in 
\begin_inset Formula ${\cal A}$
\end_inset


\begin_inset Formula 
\begin{equation}
\alpha_{\beta}:L_{\lim d,x,\beta}\rightarrow\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(x),j}\label{eq:canonical-L}
\end{equation}

\end_inset

is an isomorphism, where 
\begin_inset Formula $\overline{\beta}$
\end_inset

 is full subcategory of 
\begin_inset Formula $\op{\left(\int J_{d-,O_{p_{-}}(x)}\right)}$
\end_inset

 consisting of pairs 
\begin_inset Formula $(i,j)$
\end_inset

 such that 
\begin_inset Formula $\beta=J_{p_{i}}(j)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is not a limit preservation, since 
\begin_inset Formula $\int^{(i,j):\overline{\beta}}(d_{i},O_{p_{i}}(x),j)$
\end_inset

 in 
\begin_inset Formula $\int J$
\end_inset

 may differ from 
\begin_inset Formula $(\lim d,x,\beta)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-L"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset


\end_layout

\end_inset

By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:M-preserves"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the canonical morphism 
\begin_inset Formula $\int^{i}M_{d_{i},O_{p_{i}}(x)}\rightarrow M_{\lim d,x}$
\end_inset

 is an isomorphism.
 The domain unfolds as 
\begin_inset Formula 
\begin{align*}
\int^{i}M_{d_{i},O_{p_{i}}(x)} & \cong\int^{i}\coprod_{j\in J_{d_{i},O_{p_{i}}(x)}}KL_{d_{i},O_{p_{i}(x)},j}\\
 & \cong\int_{(i,j):\int J_{d-,O_{p-}(x)}}KL_{d_{i},O_{p_{i}(x)},j}\tag{By \prettyref{lem:colim-commute-dependent-pairs}}\\
 & \cong\coprod_{\beta\in\int^{i}J_{d_{i},O_{p_{i}}(x)}}\int^{(i,j):\overline{\beta}}KL_{d_{i},O_{p_{i}(x)},j}\tag{By \prettyref{lem:colim-connected-component}}
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
where 
\begin_inset Formula $\overline{\beta}$
\end_inset

 is the connected component of 
\begin_inset Formula $\int J_{d_{-},\alpha_{-}}$
\end_inset

 corresponding to 
\begin_inset Formula $\beta$
\end_inset

 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:colim-connected-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Since the domain category of 
\begin_inset Formula $i\mapsto J_{d-,\alpha-}$
\end_inset

 is assumed to be finite, and any 
\begin_inset Formula $J_{d,\alpha}$
\end_inset

 is finite, 
\begin_inset Formula $\int J_{d_{-},\alpha_{-}}$
\end_inset

 is finite, and thus 
\begin_inset Formula $\overline{\beta}$
\end_inset

 also is.
 Since 
\begin_inset Formula $K$
\end_inset

 preserves finite connected limits by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we get
\begin_inset Formula 
\begin{align*}
\int^{i}M_{d_{i},O_{p_{i}}(x)} & \cong\coprod_{\beta\in\int^{i}J_{d_{i},O_{p_{i}}(x)}}K\int^{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}(x)},j}\\
 & \cong\coprod_{\beta\in J_{\int_{i}(d_{i},O_{p_{i}}(x))}}K\int^{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}(x)},j}\tag{By \prettyref{lem:F-restricts-J}}\\
 & \cong\coprod_{\beta\in J_{\lim d,x}}K\int^{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}(x)},j}\tag{By \prettyref{lem:lim-elt}}
\end{align*}

\end_inset

Through this isomorphism, the canonical morphism 
\begin_inset Formula $\int^{i}M_{d_{i},O_{p_{i}}(x)}\rightarrow M_{\lim d,x}$
\end_inset

 becomes
\begin_inset Formula 
\begin{equation}
\coprod_{\beta\in J_{\lim d,x}}K\int^{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}(x)},j}\xrightarrow{\coprod_{\beta\in J_{\lim d,x}}K\alpha_{\beta}}\coprod_{j\in J_{\lim d,x}}KL_{\lim d,x,j}\label{eq:canonoical-L-iso}
\end{equation}

\end_inset

where 
\begin_inset Formula $\alpha_{\beta}$
\end_inset

 is considered as a morphism in 
\begin_inset Formula $\D=\op{{\cal A}}$
\end_inset

.
 Now, because coproducts are computed pointwise in 
\begin_inset Formula $\C$
\end_inset

 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lims-coprod-pw"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this is an isomorphism if and only if each 
\begin_inset Formula $K\alpha_{\beta}$
\end_inset

 is.
 Since 
\begin_inset Formula $K$
\end_inset

 is full and faithful, this means that each 
\begin_inset Formula $\alpha_{\beta}$
\end_inset

 is an isomorphism.
\end_layout

\begin_layout Standard
The converse statement holds
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:F-preserve-L-converse"

\end_inset

If 
\begin_inset Formula $O\in\C$
\end_inset

, 
\begin_inset Formula $J:\op{(\int O)}\rightarrow\mathbb{F}_{m}$
\end_inset

 preserves finite connected colimits, and each 
\begin_inset Formula $\alpha_{\beta}$
\end_inset

 as defined in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:canonical-L"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is an isomorphism then 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

.
\end_layout

\begin_layout Proof
This follows easily from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:M-preserves-converse"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and the fact that 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:canonoical-L-iso"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is an isomorphism if and only if each 
\begin_inset Formula $\alpha_{\beta}$
\end_inset

 is.
\end_layout

\begin_layout Standard
We finally prove 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restricts"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restricts"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset


\end_layout

\begin_layout Proof
Assume that 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

.
 Then, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-O"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $O\in\C$
\end_inset

.
 Moreover, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-J"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $J:\op{(\int O)}\rightarrow\mathbb{F}$
\end_inset

 preserves finite connected colimits and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restriction-L"
plural "false"
caps "true"
noprefix "false"

\end_inset

 holds by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-L"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Conversely, if 
\begin_inset Formula $O\in\C$
\end_inset

, 
\begin_inset Formula $J$
\end_inset

 preserves finite connected colimits and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restriction-L"
plural "false"
caps "true"
noprefix "false"

\end_inset

 holds, then 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-preserve-L-converse"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Proof
Assuming 
\begin_inset Formula $O\in\C$
\end_inset

, it remains to show that 
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

 if and only if 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restriction-L-hom-1"
plural "false"
caps "true"
noprefix "false"

\end_inset

 or 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restriction-L-hom-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Note that both are equivalent by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Proof
Let us show that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restriction-L-hom-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 is equivalent to 
\begin_inset Formula 
\[
\alpha_{\beta}:L_{\lim d,x,\beta}\rightarrow\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(x),j}
\]

\end_inset

 being an isomorphism, under the further assumption that 
\begin_inset Formula $J$
\end_inset

 preserves finite connected colimits, as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restriction-L"
plural "false"
caps "true"
noprefix "false"

\end_inset

 thus concluding the argument.
 First, 
\begin_inset Formula $\alpha_{\beta}:L_{\lim d,x,\beta}\rightarrow\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(x),j}$
\end_inset

 is an isomorphism if and only if the induced natural transformation 
\begin_inset Formula ${\cal A}(-,L_{\lim d,x,\beta})\rightarrow{\cal A}(-,\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(x),j})$
\end_inset

 is an isomorphism, by the Yoneda lemma, that is, if for each object 
\begin_inset Formula $b$
\end_inset

 of 
\begin_inset Formula ${\cal A}$
\end_inset

, the canonical morphism 
\begin_inset Formula ${\cal A}(b,L_{\lim d,x,\beta})\rightarrow{\cal A}(b,\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(x),j})$
\end_inset

 is an isomorphism.
 Since this is true for any 
\begin_inset Formula $\beta$
\end_inset

, this implies that 
\begin_inset Formula 
\begin{equation}
\prod_{\beta\in J_{\lim d,x}}{\cal A}(b,L_{\lim d,x,\beta})\xrightarrow{\prod_{\beta\in J_{\lim d,x}}{\cal A}(b,\alpha_{\beta})}\prod_{\beta\in J_{\lim d,x}}{\cal A}(b,\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(x),j})\label{eq:fin-prop}
\end{equation}

\end_inset

 is an isomorphism.
 In fact, the converse implication holds as well.
 Now, the codomain is
\begin_inset Formula 
\begin{align*}
\prod_{\beta\in J_{\lim d,x}}{\cal A}(b,\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(x),j}) & \cong\prod_{\beta\in J_{\lim d,x}}\int_{(i,j):\overline{\beta}}{\cal A}(b,L_{d_{i},O_{p_{i}}(x),j})\tag{By right continuity of the homset bifunctor}\\
 & \cong\prod_{\beta\in J_{\int_{i}(d_{i},O_{p_{i}}(x))}}\int_{(i,j):\overline{\beta}}{\cal A}(b,L_{d_{i},O_{p_{i}}(x),j})\tag{By \prettyref{lem:lim-elt}}\\
 & \cong\prod_{\beta\in\int^{i}J_{d_{i},O_{p_{i}}(x)}}\int_{(i,j):\overline{\beta}}{\cal A}(b,L_{d_{i},O_{p_{i}}(x),j})\tag{\ensuremath{J} preserves finite connected colimits}\\
 & \cong\prod_{\beta\in||J_{d_{i},O_{p_{i}}(x)}||}\int_{(i,j):\overline{\beta}}{\cal A}(b,L_{d_{i},O_{p_{i}}(x),j})\tag{By \prettyref{rem:colim-connected-elt}}\\
 & \cong\int_{(i,j):\int J_{d-,O_{p-}(x)}}{\cal A}(b,L_{d_{i},O_{p_{i}}(x),j})\tag{By \prettyref{lem:colim-connected-component}}\\
 & \cong\int_{i:I}\prod_{j\in J_{d_{i},O_{p_{i}}(x)}}{\cal A}(b,L_{d_{i},O_{p_{i}}(x),j})\tag{By \prettyref{lem:colim-commute-dependent-pairs}}
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Therefore, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:fin-prop"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is an isomorphism if and only if the canonical morphism 
\begin_inset Formula 
\[
\prod_{j\in J_{\lim d,x}}{\cal A}(b,L_{\lim d,x,j})\rightarrow\int_{i:I}\prod_{j\in J_{d_{i},O_{p_{i}}(x)}}{\cal A}(b,\int_{i:I}L_{d_{i},O_{p_{i}}(x),j})
\]

\end_inset

 is an isomorphism, which is precisely what 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:F-restriction-L-hom-2"
plural "false"
caps "true"
noprefix "false"

\end_inset

 states.
\end_layout

\begin_layout Standard
We can now address the simple situation of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:shape-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-simpl"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

First, let us show that 
\begin_inset Formula $O=\coprod_{\ell\in V}O_{\ell}$
\end_inset

 preserves finite connected limits if and only if each 
\begin_inset Formula $O_{\ell}$
\end_inset

 does.
 By 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 2.4 and Example 2.3.(iii)"
key "classificationaccessible"
literal "false"

\end_inset

, since 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits, a functor 
\begin_inset Formula $G:{\cal A}\rightarrow\Set$
\end_inset

 preserves those limits if and only if 
\begin_inset Formula $\int G$
\end_inset

 is a coproduct of filtered categories.
 The equivalence follows from 
\begin_inset Formula $\int O=\coprod_{\ell\in V}\int O_{\ell}$
\end_inset

.
 
\end_layout

\begin_layout Proof
Let us assume that 
\begin_inset Formula $O$
\end_inset

 preserves finite connected limits: let us show that the other condition
 of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-simpl"
plural "false"
caps "true"
noprefix "false"

\end_inset

 is equivalent to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-L"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 First, 
\begin_inset Formula $\int J$
\end_inset

 is isomorphic to 
\begin_inset Formula $\coprod_{\ell\in V}\gamma_{\ell}\times\int O_{\ell}$
\end_inset

,, 
\begin_inset Formula $J$
\end_inset

 preserves finite connected limits, by the same argument as above (
\begin_inset Formula $\int O$
\end_inset

 has finite connected limits by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:data-functor-elt"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lim-elt"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Proof
Now, consider the canonical morphism 
\begin_inset Formula $L_{\lim d,in_{\ell}(x),\beta}\rightarrow\int_{(i,j):\overline{\beta}}L_{d_{i},O_{p_{i}}(in_{\ell}(x)),j}$
\end_inset

, where 
\begin_inset Formula $\overline{\beta}$
\end_inset

 is the full subcategory of 
\begin_inset Formula $\int J_{d-,O_{p_{-}}(x)}$
\end_inset

 consisting of pairs 
\begin_inset Formula $(i,j)$
\end_inset

 such that 
\begin_inset Formula $\beta=J_{p_{i}}(j)$
\end_inset

.
 Because of the specific shape of 
\begin_inset Formula $J$
\end_inset

, this means 
\begin_inset Formula $\beta=j$
\end_inset

.
 Therefore, 
\begin_inset Formula $\overline{\beta}$
\end_inset

 is isomorphic to 
\begin_inset Formula $I$
\end_inset

, and this canonical morphism rewrites as 
\begin_inset Formula 
\[
H_{\ell,\beta}(\lim d,x)\rightarrow\int_{i:I}H_{\ell,\beta}(d_{i},O_{\ell,p_{i}}(x))
\]

\end_inset

which is the same morphism that is considered in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-simpl"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 It is an isomorphism if and only if 
\begin_inset Formula $H_{\ell,\beta}$
\end_inset

 preserves finite connected limits, by It 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Main result
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Main-result"

\end_inset


\end_layout

\begin_layout Standard
The main point of pattern unification is that a coequaliser diagram in 
\begin_inset Formula $\KlD$
\end_inset

 either has no unifier, either has a colimiting cocone.
 Working with this logical disjunction is slightly inconvenient; we rephrase
 it in terms of a true coequaliser by freely adding a terminal object.
\end_layout

\begin_layout Definition
Given a category 
\begin_inset Formula $\mathscr{B}$
\end_inset

, let 
\begin_inset Formula $\mathscr{B}^{*}$
\end_inset

 be 
\begin_inset Formula $\mathscr{B}$
\end_inset

 extended freely with a terminal object.
\end_layout

\begin_layout Notation
We denote by 
\begin_inset Formula $\bot$
\end_inset

 the freely added terminal object in 
\begin_inset Formula $\B^{*}$
\end_inset

.
 Recall that 
\begin_inset Formula $\bang$
\end_inset

 denotes any terminal morphism.
\end_layout

\begin_layout Standard
Adding a terminal object results in adding a terminal cocone to all diagrams.
 As a consequence, we have the following lemma.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $J$
\end_inset

 be a diagram in a category 
\begin_inset Formula $\mathscr{B}$
\end_inset

.
 The following are equivalent:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $J$
\end_inset

 has a colimit as long as there exists a cocone;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $J$
\end_inset

 has a colimit in 
\begin_inset Formula $\mathscr{B}^{*}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Long Proof
Straightforward, because a colimit is defined as an initial cocone.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The following result is also useful.
\end_layout

\begin_layout Lemma
Given a category 
\begin_inset Formula $\mathscr{B}$
\end_inset

, the canonical embedding functor 
\begin_inset Formula $\mathscr{B}\rightarrow\mathscr{B}^{*}$
\end_inset

 creates colimits.
\end_layout

\begin_layout Standard
As a consequence,
\end_layout

\begin_layout Enumerate
whenever the colimit in 
\begin_inset Formula $\KlD^{*}$
\end_inset

 is not 
\begin_inset Formula $\bot$
\end_inset

, it is also a colimit in 
\begin_inset Formula $\KlD$
\end_inset

;
\end_layout

\begin_layout Enumerate
existing colimits in 
\begin_inset Formula $\KlD$
\end_inset

 are also colimits in 
\begin_inset Formula $\KlD^{*}$
\end_inset

;
\end_layout

\begin_layout Enumerate
in particular, coproducts in 
\begin_inset Formula $\KlD$
\end_inset

 (which are computed in 
\begin_inset Formula $\C$
\end_inset

) are also coproducts in 
\begin_inset Formula $\KlD^{*}$
\end_inset

.
\end_layout

\begin_layout Standard
The main point of pattern unification is the following result.
\end_layout

\begin_layout Theorem
\begin_inset Formula $\KlD^{*}$
\end_inset

 has coequalisers.
\end_layout

\begin_layout Standard
In the next sections, we show how the generic unification algorithm summarised
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 provides a construction of such coequalisers.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The pattern unification algorithm indeed provides a construction of coequalisers
 in 
\begin_inset Formula $\Kl{\D^{+}}^{*}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
and the inclusion 
\begin_inset Formula $\Kl{\D^{+}}^{*}\rightarrow\Kl T^{*}$
\end_inset

 preserves them.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\color red
\begin_inset Note Note
status open

\begin_layout Plain Layout

\color red
We need to say somewhere that this Kleisli category is the same as the Kleisli
 category of the monad on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

, restricted to 
\begin_inset Formula $\C$
\end_inset

 or 
\begin_inset Formula $\D^{+}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In other words, for any coequaliser diagram 
\begin_inset Formula $A\rightrightarrows TB$
\end_inset

 in 
\begin_inset Formula $\Kl T$
\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are in 
\begin_inset Formula $\D^{+}$
\end_inset

, either there is no cocone, either there is a coequaliser 
\begin_inset Formula $B\rightarrow TC$
\end_inset

, with 
\begin_inset Formula $C\in\D^{+}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Unification phase
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:coequalising-phase"

\end_inset


\end_layout

\begin_layout Standard
In this section, we describe the main unification phase, which computes
 a coequaliser in 
\begin_inset Formula $\KlD^{*}$
\end_inset

.
 We denote a coequaliser 
\begin_inset Formula $\xymatrix{\coprod_{i}Ka_{i}\coeqr{\vec{t}}{\vec{u}} & \Gamma\ar[r]^{\sigma} & \Delta}
$
\end_inset

 in 
\begin_inset Formula $\Kl{\D^{+}}^{*}$
\end_inset

 by 
\begin_inset Formula $\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

, following 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:coeq"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
, implicitly assuming that 
\begin_inset Formula $A\in\D^{+}$
\end_inset

 and 
\begin_inset Formula $B,C\in\D^{+}\cup\{\bot\}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us start with the structural rules.
 When 
\begin_inset Formula $\Gamma=\bot$
\end_inset

, the coequaliser is the terminal cocone, i.e., 
\begin_inset Formula $\unificationtopconcl$
\end_inset

 holds.
 When the coproduct is empty, the coequaliser is just 
\begin_inset Formula $\Gamma$
\end_inset

, i.e., 
\begin_inset Formula $\unificationemptyconcl$
\end_inset

 holds.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We have already discussed the structural rules of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generalise"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset

 Let us explicitly state the categorical involved lemma for the rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

[Theorem 9, 
\backslash
cite{DBLP:books/daglib/0068768}]
\end_layout

\end_inset

In any category, denoting morphism  composition 
\begin_inset Formula $f\circ g$
\end_inset

 by 
\begin_inset Formula $g[f]$
\end_inset

, the following rule applies.
\begin_inset Formula 
\[
\unificationstepwise{}
\]

\end_inset


\end_layout

\begin_layout Lemma
In other words, if the first two diagrams below are coequalisers, then the
 last one as well
\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/coeq-pointwise.json
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsOCxbMCwxLCJBXzEiXSxbMSwxLCJcXEdhbW1hIl0sWzIsMSwiXFxEZ
Wx0YV8xIl0sWzMsMSwiQV8yIl0sWzQsMCwiXFxHYW1tYSJdLFs1LDEsIlxcRGVsdGFfMSJdLFs0LDIsI
lxcR2FtbWEiXSxbNiwxLCJcXERlbHRhXzIiXSxbMCwxLCJ0XzEiLDAseyJjdXJ2ZSI6LTF9XSxbMCwxL
CJ1XzEiLDIseyJjdXJ2ZSI6MX1dLFsxLDIsIlxcc2lnbWFfMSIsMCx7InN0eWxlIjp7ImJvZHkiOnsib
mFtZSI6ImRhc2hlZCJ9fX1dLFszLDQsInRfMiJdLFs0LDUsIlxcc2lnbWFfMSJdLFszLDYsInVfMiIsM
l0sWzYsNSwiXFxzaWdtYV8xIiwyXSxbNSw3LCJcXHNpZ21hXzIiLDAseyJzdHlsZSI6eyJib2R5Ijp7I
m5hbWUiOiJkYXNoZWQifX19XV0=
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	&&&& 
\backslash
Gamma 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	{A_1} & 
\backslash
Gamma & {
\backslash
Delta_1} & {A_2} && {
\backslash
Delta_1} & {
\backslash
Delta_2} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	&&&& 
\backslash
Gamma
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_1}", curve={height=-6pt}, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_1}"', curve={height=6pt}, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}", dashed, from=2-2, to=2-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_2}", from=2-4, to=1-5]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}", from=1-5, to=2-6]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_2}"', from=2-4, to=3-5]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}"', from=3-5, to=2-6]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2}", dashed, from=2-6, to=2-7]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\xymatrix{A_{1}+A_{2}\coeqr{t_{1},t_{2}}{u_{1},u_{2}} & \Gamma\ar@{-->}[r]^{\sigma_{2}\circ\sigma_{1}} & \Delta_{2}}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsMyxbMCwwLCJBXzErQV8yIl0sWzEsMCwiQiJdLFsyLDAsIkQiXSxbM
CwxLCJmXzEsZl8yIiwwLHsiY3VydmUiOi0yfV0sWzAsMSwiZl8xJyxmXzInIiwyLHsiY3VydmUiOjJ9X
SxbMSwyLCJ2XFxjaXJjIHUiXV0=
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	{A_1+A_2} & 
\backslash
Gamma & 
\backslash
Delta_2 	
\backslash
arrow["{t_1,t_2}"above, curve={height=-12pt}, from=1-1, to=1-2] 	
\backslash
arrow["{u_1,u_2}"', curve={height=12pt}, from=1-1, to=1-2] 	
\backslash
arrow["{
\backslash
sigma_2
\backslash
circ 
\backslash
sigma_1}", from=1-2, to=1-3, dashed] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thanks to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
fullshort{
\end_layout

\end_inset

this
\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset

the 
\begin_inset Formula $\refrule{U-Split}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 rule which constructs coequalisers sequentially
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
fullshort{}{
\end_layout

\end_inset

 (as discussed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

, we can now focus on the rules dealing with singleton lists, that is, with
 coequaliser diagrams 
\begin_inset Formula $\xymatrix{Ka\ar@<+.5ex>[r]^{t}\ar@<-.5ex>[r]_{u} & T\Gamma.}
$
\end_inset

 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:facto-TX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $t,u:Ka\rightarrow T\Gamma$
\end_inset

 are either rigid or flexible.
 In the next subsections, we discuss all the different mutually exclusive
 situations (up to symmetry): 
\end_layout

\begin_layout Itemize
both 
\begin_inset Formula $t$
\end_inset

 or 
\begin_inset Formula $u$
\end_inset

 are rigid (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:rig-rig"
plural "false"
caps "true"
noprefix "false"

\end_inset

), 
\end_layout

\begin_layout Itemize
\begin_inset Formula $t=M(\dots)$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 does not occur in 
\begin_inset Formula $u$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-star-nocycle"
plural "false"
caps "true"
noprefix "false"

\end_inset

), 
\end_layout

\begin_layout Itemize
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 are 
\begin_inset Formula $M(\dots)$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-flex-same-metavar"
plural "false"
caps "true"
noprefix "false"

\end_inset

), 
\end_layout

\begin_layout Itemize
\begin_inset Formula $t=M(\dots)$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 occurs deeply in 
\begin_inset Formula $u$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-rig-cyclic"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Rigid-rigid
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:rig-rig"

\end_inset

Here we detail unification of 
\begin_inset Formula $o(\vec{t})$
\end_inset

 and 
\begin_inset Formula $o'(\vec{u})$
\end_inset

 for some 
\begin_inset Formula $o,o':Ka\rightarrow O$
\end_inset

, morphisms 
\begin_inset Formula $\vec{t}:\overline{o}\rightarrow T\Gamma$
\end_inset

, 
\begin_inset Formula $\vec{u}:\overline{o'}\rightarrow T\Gamma$
\end_inset

.
\end_layout

\begin_layout Standard
Assume given a unifier 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:op-subst"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $o(\vec{t}[\sigma])=o'(\vec{u}[\sigma])$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:facto-TX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this implies that 
\begin_inset Formula $o=o'$
\end_inset

, 
\begin_inset Formula $\vec{t}[\sigma]=\vec{u}[\sigma]$
\end_inset

.
 Therefore, we get the following failing rule
\begin_inset Formula 
\[
\unificationrigrigneqo
\]

\end_inset

We now assume 
\begin_inset Formula $o=o'$
\end_inset

.
 Then, 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 is a unifier if and only if it unifies 
\begin_inset Formula $\vec{t}$
\end_inset

 and 
\begin_inset Formula $\vec{u}$
\end_inset

.
 This induces an isomorphism between the category of unifiers for 
\begin_inset Formula $o(\vec{t})$
\end_inset

 and 
\begin_inset Formula $o(\vec{u})$
\end_inset

 and the category of unifiers for 
\begin_inset Formula $\vec{t}$
\end_inset

 and 
\begin_inset Formula $\vec{u}$
\end_inset

, justifying the rule 
\begin_inset Formula $\refrule{U-RigRig}$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
We therefore get the rule
\begin_inset Formula 
\[
\unificationrigrig
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Flex-*, no cycle
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:flex-star-nocycle"

\end_inset

Here we detail unification of 
\begin_inset Formula $M(\arg x),$
\end_inset

 which is nothing but 
\begin_inset Formula ${\cal L}\arg x[in_{M}]$
\end_inset

, and 
\begin_inset Formula $u:Ka\rightarrow T(\Gamma,M:b)$
\end_inset

, such that 
\begin_inset Formula $M$
\end_inset

 does not occur in 
\begin_inset Formula $u$
\end_inset

, in the sense that 
\begin_inset Formula $u=u'[in_{\Gamma}]$
\end_inset

 for some 
\begin_inset Formula $u':Ka\rightarrow T\Gamma$
\end_inset

.
 We exploit the following general lemma, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
with 
\begin_inset Formula $t={\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula $t'=u'$
\end_inset

, 
\end_layout

\end_inset

recalling 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:pushouts"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

[
\backslash
cite{BorceuxI}, Exercise 2.17.1]
\end_layout

\end_inset

In any category, denoting morphism composition 
\begin_inset Formula $g\circ f$
\end_inset

 by 
\begin_inset Formula $f[g]$
\end_inset

, the following rule applies:
\begin_inset Formula 
\[
\dfrac{\Gamma\prune t{t'}{\sigma}v\dashv\Delta}{\Gamma+B\vdash t[in_{1}]=t'[in_{2}]\Rightarrow\sigma,v\dashv\Delta}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
In other words, if the below left diagram is a pushout, then the below right
 diagram is a coequaliser.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/pushout-coeq.json
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[
\end_layout

\begin_layout Plain Layout


\backslash
begin{array}{c}
\backslash
xymatrix{A
\backslash
ar[r]^{t'}
\backslash
ar[d]_{t} & B
\backslash
ar@{-->}[d]^{v}
\backslash

\backslash

\backslash
Gamma
\backslash
ar@{-->}[r]_{
\backslash
sigma} & 
\backslash
Delta}
\backslash
end{array}
\end_layout

\begin_layout Plain Layout


\backslash
qquad
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% pushout-coeq.json
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzcd}[row sep=-4pt]
\end_layout

\begin_layout Plain Layout

 & 
\backslash
Gamma 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 A && {
\backslash
Gamma+B} & 
\backslash
Delta 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 & B
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["t'"above, curve={height=-6pt}, from=2-1, to=1-2]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["t"below, curve={height=6pt}, from=2-1, to=3-2]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["{in_2}"below, curve={height=6pt}, from=3-2, to=2-3]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["{in_1}"above, curve={height=-6pt}, from=1-2, to=2-3]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["{
\backslash
sigma,v}", dashed, from=2-3, to=2-4]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\begin{array}{c}
\xymatrix{A\ar[r]^{x}\ar[d]_{y} & B\ar@{-->}[d]^{u}\\
C\ar@{-->}[r]_{v} & D
}
\end{array}\qquad\begin{array}{c}
\xymatrix{ & B\ar[rd]^{in_{1}}\\
A\ar[ru]^{x}\ar[rd]_{y} &  & B+C\ar@{-->}[r]_{u,v} & D\\
 & C\ar[ru]_{in_{2}}
}
\end{array}.
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
fullshort{
\end_layout

\end_inset

Therefore, it is enough to compute the above left pushout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{Ka\ar[d]_{u'}\ar[r]^{M(\arg x)} & M:b\ar@{-->}[d]^{v}\\
\Gamma\ar@{-->}[r]_{\sigma} & \Delta
}
,
\]

\end_inset


\end_layout

\end_inset

 with 
\begin_inset Formula $B=(M:b)$
\end_inset

, 
\begin_inset Formula $t=M(\arg x)={\cal L}\arg x:Ka\rightarrow(M:b)$
\end_inset

 and 
\begin_inset Formula $t'=u'$
\end_inset

.
 We 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

 Taking 
\begin_inset Formula $t=M(\arg x)={\cal L}\arg x:Ka\rightarrow(M:b)$
\end_inset

 and 
\begin_inset Formula $t'=u'$
\end_inset

, we thus have the rule
\begin_inset Formula 
\begin{equation}
\unificationoccurcheck\label{eq:flex-no-cycle-facto}
\end{equation}

\end_inset

Let us make the factorisation assumption about 
\begin_inset Formula $u$
\end_inset

 more effective.
 We can define by recursion a partial morphism from 
\begin_inset Formula $T(\Gamma,M:b)$
\end_inset

 to 
\begin_inset Formula $T\Gamma$
\end_inset

 that tries to compute 
\begin_inset Formula $u'$
\end_inset

 from an input data 
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lem:facto-m"

\end_inset

There is a morphism 
\begin_inset Formula $m_{\Gamma;b}:T(\Gamma,M:b)\rightarrow T\Gamma+1$
\end_inset

 such that the following square commutes and is a pullback.
\begin_inset Formula 
\[
\xymatrix{T\Gamma\ar@{=}[d]\ar[rr]^{Tin_{\Gamma}} &  & T(\Gamma,M:b)\ar[d]^{m_{\Gamma;b}}\\
T\Gamma\ar[rr]_{in_{1}} &  & T\Gamma+1
}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:factor-occur-check"

\end_inset

There exists 
\begin_inset Formula $m_{\Gamma;b}:T(\Gamma,M:b)\rightarrow T\Gamma+1$
\end_inset

 such that a morphism 
\begin_inset Formula $u:Ka\rightarrow T(\Gamma,M:b)$
\end_inset

 factors as 
\begin_inset Formula $Ka\xrightarrow{u'}T\Gamma\hookrightarrow T(\Gamma,M:b)$
\end_inset

 if and only if 
\begin_inset Formula $m_{\Gamma;b}\circ u=in_{1}\circ u'$
\end_inset

.
\end_layout

\begin_layout Proof
We construct 
\begin_inset Formula $m$
\end_inset

 by 
\emph on
recursion
\emph default
, by equipping 
\begin_inset Formula $T\Gamma+1$
\end_inset

 with an adequate 
\begin_inset Formula $F$
\end_inset

-algebra.
 Considering the embedding 
\begin_inset Formula $(\Gamma,M:b)\xrightarrow{\eta+!}T\Gamma+1$
\end_inset

, we then get the desired morphism by universal property of 
\begin_inset Formula $T(\Gamma,M:b)$
\end_inset

 as a free 
\begin_inset Formula $F$
\end_inset

-algebra.
 The claimed property is proven by induction
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{.}{
\end_layout

\end_inset

 (see the induction lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:induction-TX"
plural "false"
caps "true"
noprefix "false"

\end_inset

 introduced later).
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Therefore, we can rephrase
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:flex-no-cycle-facto"
plural "false"
caps "true"
noprefix "false"

\end_inset

 as the rule 
\begin_inset Formula $\refrule{U-NoCycle}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

, using the following notation.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\unificationoccurcheckeffective
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Notation
\begin_inset CommandInset label
LatexCommand label
name "nota:occur-check"

\end_inset

Given 
\begin_inset Formula $u:Ka\rightarrow T(\Gamma,M:b)$
\end_inset

, we denote 
\begin_inset Formula $m_{\Gamma;b}\circ u$
\end_inset

 by 
\begin_inset Formula $u_{|\Gamma}$
\end_inset

.
 Moreover, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
we denote the morphism 
\begin_inset Formula $Ka\xrightarrow{\bang}1\xrightarrow{in_{2}}T\Gamma+1$
\end_inset

 by merely 
\begin_inset Formula $\none$
\end_inset


\end_layout

\end_inset

 for any 
\begin_inset Formula $u':Ka\rightarrow T\Gamma$
\end_inset

, we denote 
\begin_inset Formula $in_{1}\circ u':Ka\rightarrow T\Gamma+1$
\end_inset

 by 
\begin_inset Formula $\underline{u'}$
\end_inset

.
\end_layout

\begin_layout Subsection
Flex-Flex, same metavariable
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:flex-flex-same-metavar"

\end_inset

Here we detail unification of 
\begin_inset Formula $M(\arg x)={\cal L}\arg x[in_{M}]$
\end_inset

 and 
\begin_inset Formula $M(\arg y)={\cal L}\arg y[in_{M}]$
\end_inset

, with 
\begin_inset Formula $\arg x,\arg y\in\hom_{\D}(a,b)$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In other words, we want to coequalise, in 
\begin_inset Formula $\Kl T^{*}$
\end_inset

, the following morphisms
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/coeq-flex-flex.json
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNixbMCwxLCJLQSJdLFsxLDAsIktCIl0sWzIsMCwiVEtCIl0sWzMsM
SwiVChLQitcXGRvdHMpIl0sWzEsMiwiS0IiXSxbMiwyLCJUS0IiXSxbMCwxLCJLZiJdLFsxLDIsIlxcZ
XRhIl0sWzIsMywiVGluX00iXSxbMCw0LCJLZyIsMl0sWzQsNSwiXFxldGEiLDJdLFs1LDMsIlRpbl9NI
iwyXV0=
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

 & Kb & TKb 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 Ka &&& {T(
\backslash
dots,M:b)} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 & Kb & TKb
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["Kf", from=2-1, to=1-2]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["
\backslash
eta", from=1-2, to=1-3]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["{Tin_M}", from=1-3, to=2-4]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["Kg"', from=2-1, to=3-2]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["
\backslash
eta"', from=3-2, to=3-3]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["{Tin_M}"', from=3-3, to=2-4]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Note that this is coequaliser diagram of the shape (in 
\begin_inset Formula $\Kl T^{*}$
\end_inset

) of the shape
\begin_inset Formula 
\[
\xymatrix{ & Kb\ar[rd]\\
Ka\ar[ru]^{{\cal L}f}\ar[rd]_{{\cal L}\arg y} &  & Kb+\dots\\
 & Kb\ar[ru]
}
,
\]

\end_inset

where 
\begin_inset Formula $\mathcal{L}$
\end_inset

 denotes the left adjoint 
\begin_inset Formula $\C\rightarrow\Kl T$
\end_inset

, postcomposing morphisms with 
\begin_inset Formula $\eta$
\end_inset

.
 
\end_layout

\end_inset

We exploit the following lemma with 
\begin_inset Formula $u={\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula $v={\cal L}\arg y$
\end_inset

.
\end_layout

\begin_layout Lemma
In any category, denoting morphism composition 
\begin_inset Formula $g\circ f$
\end_inset

 by 
\begin_inset Formula $f[g]$
\end_inset

, the following rule applies:
\begin_inset Formula 
\[
\dfrac{B\vdash u=v\Rightarrow h\dashv C}{B+D\dashv u[in_{B}]=v[in_{B}]\Rightarrow h+1_{D}\dashv C+D}
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset

In other words, if the below left diagram is a coequaliser, then so is the
 below right diagram.
 
\begin_inset Formula 
\[
\xymatrix{A\ar@<+.5ex>[r]^{u}\ar@<-.5ex>[r]_{v} & B\ar@{-->}[r]^{h} & C}
\qquad\begin{array}{c}
\xymatrix{ & B\ar[rd]^{in_{B}}\\
A\ar[ru]^{u}\ar[rd]_{v} &  & B+D\ar@{-->}[r]^{h+1_{D}} & C+D\\
 & B\ar[ru]_{in_{B}}
}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It follows that it is enough to compute the coequaliser of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

.
 Furthermore, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it can be computed as the image of the coequaliser of 
\begin_inset Formula $\arg x$
\end_inset

 and 
\begin_inset Formula $\arg y$
\end_inset

, thus justifying the rule 
\begin_inset Formula $\refrule{U-FlexFlex}$
\end_inset

, using the following notation.
\end_layout

\begin_layout Notation
Let 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Delta$
\end_inset

 be metavariable contexts and 
\begin_inset Formula $a\in\D$
\end_inset

.
 Any 
\begin_inset Formula $t:Ka\rightarrow T(\Gamma+\Delta)$
\end_inset

 induces a Kleisli morphism 
\begin_inset Formula $(\Gamma,M:a)\xrightarrow{}T(\Gamma+\Delta)$
\end_inset

 which we denote by 
\begin_inset Formula $M\mapsto t$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\unificationflexflex
\]

\end_inset

Note that such a coequaliser always exists by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Flex-rigid, cyclic
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:flex-rig-cyclic"

\end_inset

Here we handle unification of 
\begin_inset Formula $M(\arg x)$
\end_inset

 for some 
\begin_inset Formula $\arg x\in\hom_{\D}(a,b)$
\end_inset

 and 
\begin_inset Formula $u:Ka\rightarrow\Gamma,M:b$
\end_inset

, such that 
\begin_inset Formula $u$
\end_inset

 is rigid and 
\begin_inset Formula $M$
\end_inset

 occurs in 
\begin_inset Formula $u$
\end_inset

, i.e., 
\begin_inset Formula $\Gamma\rightarrow\Gamma,M:b$
\end_inset

 does not factor 
\begin_inset Formula $u$
\end_inset

.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:occur-check"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we show that in this situation, there is no unifier.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: exploit regularity of monomorphisms 
\begin_inset Formula $TA\rightarrow T(A+B)$
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
justifying the rule
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\unificationfailingoccurcheck
\]

\end_inset


\end_layout

\end_inset

 Then, 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:factor-occur-check"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:occur-check"
plural "false"
caps "true"
noprefix "false"

\end_inset

 justify the rule 
\begin_inset Formula $\refrule{U-Cyclic}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\unificationfailingoccurcheckeffective
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/coeq-flex1.json
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pruning phase
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:pruning-phase"

\end_inset


\end_layout

\begin_layout Standard
The pruning phase computes a pushout in 
\begin_inset Formula $\Kl{\D^{+}}^{*}$
\end_inset

 of a span 
\begin_inset Formula $\Gamma\xleftarrow{\vec{t}}\coprod_{i}Ka_{i}\xrightarrow{\coprod_{i}{\cal L}\arg x_{i}}\coprod_{i}Kb_{i}$
\end_inset

.
 We always implicitly assume (and enforce) that the right branch is a finite
 coproduct of free morphisms.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Notation
We denote a pushout 
\begin_inset Formula $\begin{array}{c}
\xymatrix{A\ar[r]^{f}\ar[d]_{g} & B\ar@{-->}[d]^{u}\\
C\ar@{-->}[r]_{\sigma} & D
}
\end{array}$
\end_inset

 in a category 
\begin_inset Formula $\B$
\end_inset

 by 
\begin_inset Formula $B\prunecat gf{\sigma}u{\B}\dashv C$
\end_inset

, sometimes even omitting 
\begin_inset Formula $\B$
\end_inset

.
 When 
\begin_inset Formula $\B=\Kl T^{*}$
\end_inset

 we moreover implicitly assume that 
\begin_inset Formula $C,D\in\D^{+}\cup\{\bot\}$
\end_inset

 and 
\begin_inset Formula $f=\coprod_{i\in I}{\cal L}f'_{i}:\coprod_{i}Ka_{i}\rightarrow\coprod_{i}Kb_{i}$
\end_inset

 for some finite set 
\begin_inset Formula $I$
\end_inset

 and morphisms 
\begin_inset Formula $f'_{i}:a_{i}\rightarrow b_{i}$
\end_inset

.
\end_layout

\begin_layout Personal Question
Can we prove in general that the pushout of a free morphism, if it exists,
 is a free morphism?
\end_layout

\begin_layout Remark
For the intuition behind the notation and the relation to the so-called
 pruning process, consider the case of 
\begin_inset Formula $\lambda$
\end_inset

-calculus, as in the introduction.
 A span 
\begin_inset Formula $\Gamma\xleftarrow{g}Kn\xrightarrow{{\cal L}\arg x}Km$
\end_inset

 corresponds to a term in 
\begin_inset Formula $t\in T\Gamma_{n}$
\end_inset

 and a choice of distinct 
\begin_inset Formula $m$
\end_inset

 variables in 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

, that is, an injection 
\begin_inset Formula $\arg x:m\rightarrow n$
\end_inset

.
 The pushout, if it exists, consists in 
\begin_inset Quotes eld
\end_inset

coercing
\begin_inset Quotes erd
\end_inset

 (hence the symbol 
\begin_inset Formula $:>$
\end_inset

) the term 
\begin_inset Formula $t$
\end_inset

 to live in 
\begin_inset Formula $T\Gamma_{m}$
\end_inset

, by restricting the arity of the metavariables according to 
\begin_inset Formula $\sigma:\Gamma\rightarrow T\Delta$
\end_inset

.
 The resulting term 
\begin_inset Formula $u\in\hom(Kn,T\Delta)\cong T\Delta_{n}$
\end_inset

 is 
\begin_inset Formula $t$
\end_inset

 but living in the 
\begin_inset Quotes eld
\end_inset

smaller
\begin_inset Quotes erd
\end_inset

 context 
\begin_inset Formula $\{0,\dots,m-1\}$
\end_inset

 in the restricted metavariable context 
\begin_inset Formula $\Delta$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:cocone-pruning"

\end_inset

A pushout cocone for the above span consists in morphisms 
\begin_inset Formula $\Gamma\xrightarrow{\sigma}T\Delta\xleftarrow{\vec{u}}\coprod_{i}Kb_{i}$
\end_inset

 such that 
\begin_inset Formula $\vec{t}[\sigma]=\vec{u}\circ\coprod_{i}K\arg x_{i}$
\end_inset

, i.e., 
\begin_inset Formula $t_{i}[\sigma]=\acton{\vec{x_{i}}}{u_{i}}$
\end_inset

 for each 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $\Gamma\xrightarrow{\sigma}\Delta\xleftarrow{\vec{u}}\coprod_{i}Kb_{i}$
\end_inset

 induces a pushout of the above span, we use 
\begin_inset CommandInset ref
LatexCommand formatted
reference "nota:pushouts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and denote such a situation by 
\begin_inset Formula $\Gamma\prune{\vec{t}}{\coprod_{i}{\cal L}x_{i}}{\sigma}{\vec{u}}\dashv\Delta$
\end_inset

.
 
\end_layout

\begin_layout Personal Question
Could we use Reddy's syntax, to differentiate the input/output? We need
 to know what his syntax is the internal language of.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We have already discussed the structural rules of the pruning phase in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generalise"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us start with the structural rules.
 When 
\begin_inset Formula $\Gamma=\bot$
\end_inset

, the pushout is the terminal cocone, i.e., 
\begin_inset Formula $\pruningtopconcl$
\end_inset

 holds.
 When the coproduct is empty, the pushout is just 
\begin_inset Formula $\Gamma$
\end_inset

, i.e., 
\begin_inset Formula $\pruningemptyconcl$
\end_inset

 holds.
 Finally, let us note that the sequential rule 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

 is in fact valid in any category.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
When 
\begin_inset Formula $\Gamma=\bot$
\end_inset

, the pushout is the terminal cocone, i.e., 
\begin_inset Formula $\pruningtopconcl$
\end_inset

 holds.
 .
 When the coproduct is empty, the pushout is just 
\begin_inset Formula $\Gamma$
\end_inset

, i.e., 
\begin_inset Formula $\pruningemptyconcl$
\end_inset

 holds.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The pushout can be decomposed into smaller components, thanks to the following
 lemma.
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:p-split"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/pushout-stepwise.json
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
In any category, denoting morphism composition 
\begin_inset Formula $f\circ g$
\end_inset

 by 
\begin_inset Formula $g[f]$
\end_inset

, the following rule 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\refrule{P-Split}$
\end_inset

 
\end_layout

\end_inset

applies.
\begin_inset Formula 
\[
\pruningstepwise{}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
In other words, if the first two diagrams below are pushouts, then the last
 one as well.
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	A & {A'} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
Gamma & {
\backslash
Delta_1}
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_1}"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{f_1}", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}"', dashed, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_1}", dashed, from=1-2, to=2-2]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
quad
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	B & {B'} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
Gamma 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	{
\backslash
Delta_1} & {
\backslash
Delta_2}
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_2}"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{f_2}", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}"', from=2-1, to=3-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_2}", dashed, from=1-2, to=3-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2}"', dashed, from=3-1, to=3-2]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
quad
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	{A+B} && {A'+B'} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
Gamma && {
\backslash
Delta_2}
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_1,t_2}"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{f_1+f_2}", from=1-1, to=1-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2
\backslash
circ u_1, u_2}", dashed, from=1-3, to=2-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2
\backslash
circ 
\backslash
sigma_1}"', dashed, from=2-1, to=2-3]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsOSxbMCwwLCJBIl0sWzAsMSwiWCJdLFsxLDAsIkEnIl0sWzEsMSwiW
iJdLFsyLDAsIkIiXSxbMiwxLCJYIl0sWzMsMCwiQiciXSxbMiwyLCJaIl0sWzMsMiwiWiciXSxbMCwxL
CJnIiwyXSxbMCwyLCJmIl0sWzEsMywiXFxzaWdtYSIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6I
mRhc2hlZCJ9fX1dLFsyLDMsInUiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19X
SxbNCw1LCJnJyIsMl0sWzQsNiwiZiciXSxbNSw3LCJcXHNpZ21hIiwyXSxbNiw4LCJ1JyIsMCx7InN0e
WxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFs3LDgsIlxcc2lnbWEnIiwyLHsic3R5bGUiO
nsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	A & {B} & 
\backslash
Gamma & {
\backslash
Delta_1} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	X & Z & X 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	&& Z & {Z'}
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["t_1"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["f_1", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["
\backslash
sigma_1"', dashed, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["u_1", dashed, from=1-2, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_2}"', from=1-3, to=2-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{f_2}", from=1-3, to=1-4]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["
\backslash
sigma_1"', from=2-3, to=3-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_2}", dashed, from=1-4, to=3-4]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2}"', dashed, from=3-3, to=3-4]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
quad
\end_layout

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJBK0IiXSxbMCwxLCJYIl0sWzIsMCwiQScrQiciXSxbM
iwxLCJaJyJdLFswLDEsIltnLGcnXSIsMl0sWzAsMiwiZitmJyJdLFsyLDMsIltcXHNpZ21hJ1xcY2lyY
yB1LCB1J10iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMSwzLCJcXHNpZ
21hJ1xcY2lyYyBcXHNpZ21hIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	{A+B} && {A'+B'} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	X && {Z'}
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_1,t_2}"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{f_1+f_2}", from=1-1, to=1-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2
\backslash
circ u_1, u_2}", dashed, from=1-3, to=2-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2
\backslash
circ 
\backslash
sigma_1}"', dashed, from=2-1, to=2-3]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Thanks to the above rule, we can now focus on the case where 
\begin_inset Formula $\vec{t}$
\end_inset

 is a singleton list, thus dealing with a span 
\begin_inset Formula $\xymatrix{T\Gamma & Ka\hautr{N(\arg x)}\ar[l]_{t} & T(N:b).}
$
\end_inset

 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:facto-TX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the left morphism 
\begin_inset Formula $Ka\rightarrow T\Gamma$
\end_inset

 is either flexible or rigid.
 Each case is handled separately in the following subsections.
\end_layout

\begin_layout Subsection
Rigid
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:case-KA-RiTC"

\end_inset


\end_layout

\begin_layout Standard
Here, we describe the construction of a pushout of 
\begin_inset Formula $\xymatrix{\Gamma & Ka\hautr{N(\arg x)}\ar[l]_{o(\vec{t})} & N:b}
$
\end_inset

 where 
\begin_inset Formula $o:Ka\rightarrow O$
\end_inset

 and 
\begin_inset Formula $\vec{t}:\overline{o}\rightarrow T\Gamma$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:cocone-pruning"
plural "false"
caps "true"
noprefix "false"

\end_inset

, a cocone is a cospan 
\begin_inset Formula $T\Gamma\xrightarrow{\sigma}T\Delta\xleftarrow{t'}Kb$
\end_inset

 such that 
\begin_inset Formula $o(\vec{t})[\sigma]=\acton{\arg x}{t'}.$
\end_inset

 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:op-subst"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this means that 
\begin_inset Formula $o(\vec{t}[\sigma])=\acton{\arg x}{t'}$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:facto-TX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $t'$
\end_inset

 is either some 
\begin_inset Formula $M(\arg y)$
\end_inset

 or 
\begin_inset Formula $o'(\vec{u})$
\end_inset

.
 But in the first case, 
\begin_inset Formula $\acton{\arg x}{t'}=\acton{\arg x}{M(\arg y)}=M(\arg y\circ\arg x)$
\end_inset

 by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:op-subst"
plural "false"
caps "true"
noprefix "false"

\end_inset

, so it cannot equal 
\begin_inset Formula $o(\vec{t}[\sigma])$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:facto-TX"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Therefore, 
\begin_inset Formula $t'=o'(\vec{u})$
\end_inset

 for some 
\begin_inset Formula $o':Kb\rightarrow O$
\end_inset

 and 
\begin_inset Formula $\vec{u}:\overline{o'}\rightarrow T\Delta$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:op-subst"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $\acton{\arg x}{t'}=(\acton{\arg x}{o')}(\vec{u}\circ\arg x^{o})$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:facto-TX"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $o=\acton{\arg x}{o'}$
\end_inset

, and 
\begin_inset Formula $\vec{t}[\sigma]=\vec{u}\circ\arg x^{o}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We introduce some notation for the latter condition.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Notation
Given 
\begin_inset Formula $f\in\hom_{\D}(a,b)$
\end_inset

 and 
\begin_inset Formula $o\in Ka\rightarrow O$
\end_inset

, we write 
\begin_inset Formula $o_{|f}\Rightarrow\bang$
\end_inset

 to mean that 
\begin_inset Formula $Kf$
\end_inset

 does not factor 
\begin_inset Formula $o$
\end_inset

.
 Otherwise, if 
\begin_inset Formula $o=o'\circ Kf$
\end_inset

, then we write 
\begin_inset Formula $o_{|f}\Rightarrow\underline{o'}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Remark
Note that if there were more than one possible 
\begin_inset Formula $o'$
\end_inset

, then the most general unifier would not exist.
 But such a 
\begin_inset Formula $o'$
\end_inset

, if it exists, is unique because 
\begin_inset Formula $K\arg x$
\end_inset

 is epimorphic, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:epis"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In fact, this is the only place where we use this property.
 As a consequence, we could weaken the condition that morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 are monomorphic and require instead that the image of such a morphism by
 
\begin_inset Formula $O$
\end_inset

 is monomorphic.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{
\end_layout

\end_inset

Note that there is at most one 
\begin_inset Formula $o'$
\end_inset

 such that 
\begin_inset Formula $o=\acton x{o'}$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:epis"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In this case,
\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset

In case 
\begin_inset Formula $o=\acton{\arg x}{o'}$
\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 it follows from the above observations that a cocone is equivalently given
 by a cospan 
\begin_inset Formula $T\Gamma\xrightarrow{\sigma}T\Delta\xleftarrow{\vec{u}}b^{o}$
\end_inset

 such that 
\begin_inset Formula $\vec{t}[\sigma]=\vec{u}\circ\arg x^{o}$
\end_inset

.
 But, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:cocone-pruning"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this is precisely the data for a pushout cocone for 
\begin_inset Formula $\Gamma\xleftarrow{\vec{t}}a^{o}\xrightarrow{{\cal L}^{+}\arg x^{o}}b^{o}$
\end_inset

.
 This actually induces an isomorphism between the two categories of cocones,
 thus justifying the rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We therefore have the following rules.
\begin_inset Formula 
\[
\pruningrig\quad\pruningrigfail
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Remark
If 
\begin_inset Formula $S_{o}$
\end_inset

 is orthogonal
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Definition 1.32"
key "Adamek"
literal "false"

\end_inset

 to all morphisms (i.e., given any span 
\begin_inset Formula $S_{o}\leftarrow a\rightarrow b$
\end_inset

, there exists a unique 
\begin_inset Formula $b\rightarrow S_{o}$
\end_inset

 completing the triangle), as in the case where 
\begin_inset Formula $S_{o}$
\end_inset

 is the output type 
\begin_inset Quotes eld
\end_inset

Dirac
\begin_inset Quotes erd
\end_inset

, then this rule never applies.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Flex
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:pruning-metavar"

\end_inset


\end_layout

\begin_layout Standard
Here, we construct the pushout of 
\begin_inset Formula $\xymatrix{(\Gamma,M:c) & Ka\hautr{N(\arg x)}\hautl{M(\arg y)} & N:b}
$
\end_inset

.
 Note that in this span, 
\begin_inset Formula $N(\arg x)={\cal L}\arg x$
\end_inset

 while 
\begin_inset Formula $M(\arg y)={\cal L}\arg y[in_{M}]$
\end_inset

.
 Thanks to the following lemma, it is actually enough to compute the pushout
 of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/pushout-in.json
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
In any category, denoting morphism composition by 
\begin_inset Formula $f\circ g=g[f]$
\end_inset

, the following rule applies
\begin_inset Formula 
\[
\dfrac{X\prune gf{\sigma}u\dashv Z}{X+Y\prune{g[in_{1}]}f{\sigma+Y}{u[in_{1}]}\dashv Z+Y}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset

In other words, if the diagram below left is a pushout, then so is the right
 one.
\end_layout

\begin_layout Lemma
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJBIl0sWzAsMSwiWCJdLFsxLDAsIkIiXSxbMSwxLCJaI
l0sWzAsMSwiZyIsMl0sWzAsMiwiZiJdLFsxLDMsIlxcc2lnbWEiLDIseyJzdHlsZSI6eyJib2R5Ijp7I
m5hbWUiOiJkYXNoZWQifX19XSxbMiwzLCJ1IiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFza
GVkIn19fV1d
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	A & B 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	X & Z
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["g"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["f", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["
\backslash
sigma"', dashed, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["u", dashed, from=1-2, to=2-2]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
qquad
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	A & B 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	X & Z 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	{X+Y} & {Z+Y}
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["g"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["f", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{in_1}"', from=2-1, to=3-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma+Y}"', dashed, from=3-1, to=3-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["u", dashed, from=1-2, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{in_1}", dashed, from=2-2, to=3-2]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the pushout of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

 is the image by 
\begin_inset Formula ${\cal L}$
\end_inset

 of the pushout of 
\begin_inset Formula $\arg x$
\end_inset

 and 
\begin_inset Formula $\arg y$
\end_inset

, thus justifying the rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Therefore, we get the rule
\begin_inset Formula 
\[
\pruningflex y
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Occur-check
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:occur-check"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
plus de discussion: cf.
 occurcheck.lyx
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The occur-check allows to jump from the main unification phase (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:coequalising-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

) to the pruning phase (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

), whenever the metavariable appearing at the top-level of the l.h.s does
 not occur in the r.h.s.
 This section is devoted to the proof that if there is a unifier of 
\begin_inset Formula $M(\vec{x})$
\end_inset

 and 
\begin_inset Formula $t$
\end_inset

, then either 
\begin_inset Formula $M$
\end_inset

 does not occur in 
\begin_inset Formula $t$
\end_inset

, either it occurs at top-level (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:occurcheck-final"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 The argument formalises the basic intuition that 
\begin_inset Formula $t=u[M\mapsto t]$
\end_inset

 is impossible if 
\begin_inset Formula $M$
\end_inset

 occurs deeply in 
\begin_inset Formula $u$
\end_inset

 because the sizes of both hand sides can never match.
 To make this statement precise, we need some recursive definitions and
 properties of size, formally justified by exploiting the universal property
 of 
\begin_inset Formula $TX$
\end_inset

 as the free 
\begin_inset Formula $F$
\end_inset

-algebra on 
\begin_inset Formula $X$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:size-occur-check"

\end_inset

The size 
\begin_inset Formula $|t|\in\mathbb{N}$
\end_inset

 of a morphism 
\begin_inset Formula $t:Ka\rightarrow T\Gamma$
\end_inset

 is recursively defined by 
\begin_inset Formula $|M(\arg x)|=0$
\end_inset

 and 
\begin_inset Formula $|o(\vec{t})|=1+|\vec{t}|$
\end_inset

, with 
\begin_inset Formula $|\vec{t}|=\sum_{i}t_{i}$
\end_inset

, for any 
\begin_inset Formula $\vec{t}:\coprod_{i}Ka_{i}\xrightarrow{\dots,t_{i},\dots}T\Gamma$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
We will also need to count the occurrences of a metavariables in a term.
\end_layout

\begin_layout Definition
For each morphism 
\begin_inset Formula $t:Ka\rightarrow T(\Gamma,M:b)$
\end_inset

 we define 
\begin_inset Formula $|t|_{M}$
\end_inset

 recursively by 
\begin_inset Formula $|M(\arg x)|_{M}=1$
\end_inset

, 
\begin_inset Formula $|N(\arg x)|_{M}=0$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 if 
\begin_inset Formula $N\neq M$
\end_inset

, and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $|o(\vec{t})|_{M}=|\vec{t}|_{M}$
\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
|N(\arg x)|_{M}=0\text{ if \ensuremath{N\neq M}}\qquad|M(f)|_{M}=1\qquad|o(g)|_{M}=|g|_{M}
\]

\end_inset


\end_layout

\end_inset

with the sum convention as above for 
\begin_inset Formula $|\vec{t}|_{M}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Remark
More formally, given 
\begin_inset Formula $t:Ka\rightarrow T\Gamma$
\end_inset

, the size 
\begin_inset Formula $|t|$
\end_inset

 is defined as the natural number 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $1\xrightarrow{n}\mathbb{N}$
\end_inset

 factors 
\begin_inset Formula $Ka\rightarrow T\Gamma\rightarrow\mathbb{N}$
\end_inset

 (by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:connected"
plural "false"
caps "false"
noprefix "false"

\end_inset

, since 
\begin_inset Formula $\mathbb{N}$
\end_inset

 is the coproduct 
\begin_inset Formula $\coprod_{n\in\mathbb{N}}1$
\end_inset

), where 
\begin_inset Formula $T\Gamma\rightarrow\mathbb{N}$
\end_inset

 is the universal 
\begin_inset Formula $F$
\end_inset

-algebra morphism induced by the constant morphism 
\begin_inset Formula $\Gamma\xrightarrow{0}\mathbb{N}$
\end_inset

 and the 
\begin_inset Formula $F$
\end_inset

-algebra 
\begin_inset Formula $F\mathbb{N}\cong\coprod_{o}\mathbb{N}^{J_{o}}\times S_{o}\xrightarrow{\coprod_{o}\pi_{1}}\coprod_{o}\mathbb{N}^{J_{o}}\xrightarrow{\coprod_{o}(1+\sum)}\coprod_{o}\mathbb{N}\rightarrow\mathbb{N}$
\end_inset

, informally mapping 
\begin_inset Formula $o(\vec{n})$
\end_inset

 to 
\begin_inset Formula $1+\sum_{j}n_{j}$
\end_inset

.
\end_layout

\begin_layout Remark
Given 
\begin_inset Formula $t:Ka\rightarrow T(\Gamma,M:b)$
\end_inset

, the natural number 
\begin_inset Formula $|t|_{M}$
\end_inset

 is computed similarly by the postcomposition with the universal 
\begin_inset Formula $F$
\end_inset

-algebra morphism 
\begin_inset Formula $T(\Gamma,M:b)\rightarrow\mathbb{N}$
\end_inset

 induced by 
\begin_inset Formula $\Gamma,M:b\xrightarrow{0,1}\mathbb{N}$
\end_inset

 and the 
\begin_inset Formula $F$
\end_inset

-algebra structure 
\begin_inset Formula $F\mathbb{N}\cong\coprod_{o}\mathbb{N}^{J_{o}}\times S_{o}\xrightarrow{\coprod_{o}\pi_{1}}\coprod_{o}\mathbb{N}^{J_{o}}\xrightarrow{\coprod_{o}\sum}\coprod_{o}\mathbb{N}\rightarrow\mathbb{N}$
\end_inset

, informally mapping 
\begin_inset Formula $o(\vec{n})$
\end_inset

 to 
\begin_inset Formula $\sum_{j}n_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
The lemmas below are easy consequences of the following standard induction
 lemma.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:induction-TX"

\end_inset

Assume given, for each object 
\begin_inset Formula $a$
\end_inset

 of 
\begin_inset Formula ${\cal A}$
\end_inset

, a predicate 
\begin_inset Formula $P_{a}$
\end_inset

 on 
\begin_inset Formula $\hom(Ka,T\Gamma$
\end_inset

) such that
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $P_{a}(M(\arg x))$
\end_inset

 holds for any 
\begin_inset Formula $M:b\in\Gamma$
\end_inset

 and 
\begin_inset Formula $\arg x\in\hom_{\D}(a,b)$
\end_inset

;
\end_layout

\begin_layout Itemize
given 
\begin_inset Formula $o\in O_{a}$
\end_inset

 and 
\begin_inset Formula $\vec{t}:\coprod_{j\in J_{a,o}}KL_{a,o,j}\rightarrow T\Gamma$
\end_inset

, the property 
\begin_inset Formula $P_{a}(o(\vec{t}))$
\end_inset

 holds whenever 
\begin_inset Formula $P_{L_{a,o,j}}(t_{j})$
\end_inset

 holds for every 
\begin_inset Formula $j\in J_{a,o}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Lemma
Then, 
\begin_inset Formula $P_{a}(t)$
\end_inset

 holds for any 
\begin_inset Formula $t:Ka\rightarrow T\Gamma$
\end_inset

.
\end_layout

\begin_layout Proof
Consider the functor 
\begin_inset Formula $X:{\cal A}\rightarrow\Set$
\end_inset

 defined by 
\begin_inset Formula $X_{a}=\{t\in Ka\rightarrow T\Gamma|\forall f:b\rightarrow a,P_{a}(\acton ft)\}$
\end_inset

.
 By the Yoneda lemma, there is an injective projection 
\begin_inset Formula $X\rightarrow T\Gamma$
\end_inset

.
 By universal property of 
\begin_inset Formula $T\Gamma$
\end_inset

 as the free 
\begin_inset Formula $F$
\end_inset

-algebra on 
\begin_inset Formula $\Gamma$
\end_inset

, this projection has a section, and is thus an isomorphism.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sizeM-factor"

\end_inset

For any 
\begin_inset Formula $t:Ka\rightarrow T(\Gamma,M:b)$
\end_inset

, if 
\begin_inset Formula $|t|_{M}=0$
\end_inset

, then 
\begin_inset Formula $T\Gamma\hookrightarrow T(\Gamma,M:b)$
\end_inset

 factors 
\begin_inset Formula $t$
\end_inset

.
 Moreover, for any 
\begin_inset Formula $\Gamma=(M_{1}:a_{1},\dots,M_{n}:a_{n})$
\end_inset

, 
\begin_inset Formula $t:Ka\rightarrow T\Gamma$
\end_inset

, and 
\begin_inset Formula $\sigma:\Gamma\rightarrow T\Delta$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma]|=|t|+\sum_{i}|t|_{M_{i}}\times|\sigma_{i}|$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset

 In fact, this is a logical equivalence, i.e., the following diagram is an
 equaliser.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/sizeM-equaliser.json
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNCxbMCwxLCJUXFxHYW1tYSJdLFsxLDEsIlQoXFxHYW1tYSxNOmIpI
l0sWzIsMCwiMSJdLFszLDEsIlxcbWF0aGJie059Il0sWzAsMSwiIiwwLHsic3R5bGUiOnsidGFpbCI6e
yJuYW1lIjoiaG9vayIsInNpZGUiOiJ0b3AifSwiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzEsM
iwiIiwwLHsiY3VydmUiOi0xfV0sWzIsMywiMCIsMCx7ImN1cnZlIjotMX1dLFsxLDMsInwtfF9NIiwyL
HsiY3VydmUiOjJ9XV0=
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

 && 1 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 T
\backslash
Gamma & {T(
\backslash
Gamma,M:b)} && {
\backslash
mathbb{N}}
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow[dashed, hook, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow[curve={height=-6pt}, from=2-2, to=1-3]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["0", curve={height=-6pt}, from=1-3, to=2-4]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["{|-|_M}"', curve={height=12pt}, from=2-2, to=2-4]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:size-consequences"

\end_inset

For any 
\begin_inset Formula $t:Ka\rightarrow T(\Gamma,M:b)$
\end_inset

, 
\begin_inset Formula $\sigma:\Gamma\rightarrow T\Delta$
\end_inset

, 
\begin_inset Formula $x\in\hom_{\D}(a,b)$
\end_inset

, 
\begin_inset Formula $u:Kb\rightarrow T\Delta$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma,u]|\geq|t|+|u|\times|t|_{M}$
\end_inset

 and 
\begin_inset Formula $|M(x)[u]|=|u|$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:occurcheck-final"

\end_inset

If there is a commuting square in 
\begin_inset Formula $\Kl T$
\end_inset


\begin_inset Formula 
\[
\xymatrix{Ka\ar[d]_{M(\arg x)}\hautr{t} & \Gamma,M:b\ar[d]^{\sigma,u}\\
M:b\ar[r]_{u} & \Delta
}
\]

\end_inset

then either 
\begin_inset Formula $t=M(\arg y)$
\end_inset

 for some 
\begin_inset Formula $y$
\end_inset

, or 
\begin_inset Formula $T\Gamma\hookrightarrow T(\Gamma,M:b)$
\end_inset

 factors 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $t[\sigma,u]=M(x)[u]$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma,u]|=|M(x)[u]|$
\end_inset

.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:size-consequences"
plural "false"
caps "true"
noprefix "false"

\end_inset

 implies 
\begin_inset Formula $|u|\geq|t|+|u|\times|t|_{M}$
\end_inset

.
 Therefore, either 
\begin_inset Formula $|t|_{M}=0$
\end_inset

 and we conclude by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sizeM-factor"
plural "false"
caps "true"
noprefix "false"

\end_inset

, either 
\begin_inset Formula $|t|_{M}=1$
\end_inset

 and 
\begin_inset Formula $|t|=0$
\end_inset

 and so 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $M(\arg y)$
\end_inset

 for some 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Section
Completeness
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:completeness"

\end_inset


\end_layout

\begin_layout Standard
Each inductive rule presented so far provides an elementary step for the
 construction of coequalisers.
 We need to ensure that this set of rules allows to construct a coequaliser
 in a finite number of steps.
 To make the argument more straightforward, we explicitly assume that in
 the splitting rules 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the expressions with vector notation are not empty lists.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To this end, we consider in this section some alternative rules to make
 the argument more straightforward: we simply remove the stepwise rules
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unify-stepwise"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-stepwise"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and replace the recursive rules
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unifying-rec"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pruning-rec"
plural "false"
caps "true"
noprefix "false"

\end_inset

 by the following ones:
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash f_{1}=g_{1}\Rightarrow\sigma_{1}\dashv\Delta_{1}}{\Gamma\vdash o(f)=o(g)\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset

 The following two properties are sufficient to ensure that applying rules
 eagerly eventually leads to a coequaliser: 
\emph on
progress
\emph default
, i.e., there is always one rule that applies given some input data
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
et aussi que ca preserve la propriete qu'une des branches est un coproduit
 +
\end_layout

\end_inset

, and 
\emph on
termination
\emph default
, i.e., there is no infinite sequence of rule applications.
 In this section, we sketch the proof of the latter termination property,
 following a standard argument.
 Roughly, it consists in defining the size of an input and realising that
 it strictly decreases in the premises.
 This relies on the notion of the size 
\begin_inset Formula $|\Gamma|$
\end_inset

 of a context 
\begin_inset Formula $\Gamma$
\end_inset

 (as an element of 
\begin_inset Formula $\D^{+}$
\end_inset

), which can be defined as its size as a finite family of elements of 
\begin_inset Formula ${\cal A}$
\end_inset

 (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:D-finite-family"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We extend this definition to the case where 
\begin_inset Formula $\Gamma=\bot$
\end_inset

, by taking 
\begin_inset Formula $|\bot|=0$
\end_inset

.
 We also define the size
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
The difference with 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:size-occur-check"
plural "false"
caps "true"
noprefix "false"

\end_inset

 is that metavariables are no longer of empty size.
 As a consequence, any term has a non empty size.
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset Formula $||t||$
\end_inset

 of a 
\emph on
term
\emph default
 
\begin_inset Formula $t:Ka\rightarrow T\Gamma$
\end_inset

 as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:size-occur-check"
plural "false"
caps "true"
noprefix "false"

\end_inset

 except that we assign a size of 
\begin_inset Formula $1$
\end_inset

 to metavariables, so that no term is of empty size.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
recursively by 
\begin_inset Formula $||M(\arg x)||=1$
\end_inset

 and 
\begin_inset Formula $||o(\vec{t})||=1+||\vec{t}||$
\end_inset

, where the size of a list of terms is the sum of the sizes of each term
 in the list.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The main difficulty to show termination is that the case 
\begin_inset Formula $M(\arg x)=o(\vec{u})$
\end_inset

 involves a recursive call with an extended context, while all the other
 rules are reducing or keeping the same context size.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
One way to solve this issue consists in avoiding creating new metavariables.
 Instead, we could first (potentially) reduce the arities of metavariables
 appearing in 
\begin_inset Formula $o(\vec{u})$
\end_inset

 so that they don't refer to free variables outside 
\begin_inset Formula $\arg x$
\end_inset

 and then directly instantiate 
\begin_inset Formula $M$
\end_inset

 with the resulting term.
 This seems to be a bit tedious to describe precisely (not to mention to
 prove correctness).
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
First, we sketch the termination argument for the pruning phase, and then
 for the main unification phase.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us first quickly justify termination of the pruning phase.
 We define the size of a judgment 
\begin_inset Formula $\Gamma\prune fg{\sigma}u\dashv\Delta$
\end_inset

 as 
\begin_inset Formula $||f||$
\end_inset

.
 It is straightforward to check that the sizes of the premises are strictly
 smaller than the size of the conclusion, for the two recursive rules 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 of the pruning phase, thanks to the following lemmas
\end_layout

\begin_layout Lemma
For any 
\begin_inset Formula $t:Ka\rightarrow T\Gamma$
\end_inset

 and 
\begin_inset Formula $\sigma:\Gamma\rightarrow T\Delta$
\end_inset

, if 
\begin_inset Formula $\sigma$
\end_inset

 is a renaming, i.e., 
\begin_inset Formula $\sigma={\cal L}^{+}\sigma'$
\end_inset

, for some 
\begin_inset Formula $\sigma'$
\end_inset

, then 
\begin_inset Formula $||t[\sigma]||=||t||$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
If there is a finite derivation tree of 
\begin_inset Formula $\Gamma\prune fg{\sigma}u\dashv\Delta$
\end_inset

 and 
\begin_inset Formula $\Delta\neq\bot$
\end_inset

, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\bot$
\end_inset

 n'est pas connexe car 
\begin_inset Formula $\bot+\bot=\bot$
\end_inset


\end_layout

\end_inset

 then 
\begin_inset Formula $|\Gamma|=|\Delta|$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 is a 
\emph on
renaming
\emph default
.
\end_layout

\begin_layout Personal Question
Can we define it truly recursively?
\end_layout

\begin_layout Standard
Now, we tackle termination for the unification phase.
 We define the size of a judgment 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 to be the pair 
\begin_inset Formula $(|\Gamma|,||t||)$
\end_inset

.
 The following lemma ensures that for the two recursive rules 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 and 
\begin_inset Formula $\refrule{U-RigRig}$
\end_inset

 in the unification phase, the sizes of the premises are strictly smaller
 than the size of the conclusion, for the lexicographic order.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There are two recursive rules: 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unify-stepwise"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unifying-rec"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Contrary to the pruning phase, the first one is not structurally recursive
 since a substitution is applied to the argument.
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
If there is a finite derivation tree of 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

, then 
\begin_inset Formula $|\Gamma|\geq|\Delta|$
\end_inset

, and moreover if 
\begin_inset Formula $|\Gamma|=|\Delta|$
\end_inset

 and 
\begin_inset Formula $\Delta\neq\bot$
\end_inset

, then 
\begin_inset Formula $\sigma$
\end_inset

 is a renaming.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
, i.e., it is 
\begin_inset Formula ${\cal L}^{+}\sigma'$
\end_inset

 for some 
\begin_inset Formula $\sigma'$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The proof of the first lemma relies on the fact that when the pruning phase
 does not fail, it produces a renaming targetting a metavariable context
 of the same size as the input one.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Applications
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:applications"

\end_inset

In the examples, we motivate the definition of the category 
\begin_inset Formula ${\cal A}$
\end_inset

 based on what we expect from metavariable arities, following 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:ar-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We also adopt the format of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:shape-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where the endofunctor 
\begin_inset Formula $F$
\end_inset

 is defined as
\begin_inset Formula 
\[
F(X)_{a}\cong\coprod_{\ell\in V}\coprod_{o\in O_{\ell}}\prod_{j\in\gamma_{\ell}}X_{H_{\ell,j}(a,o)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
we propose an interpretation of typing rules to define the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 accounting for the syntax:
\begin_inset Formula 
\[
\Gamma
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simply-typed second-order syntax
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:simply-typed-so"

\end_inset

 In this section, we present the example of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 Our treatment generalises to any second-order binding signature (see
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "FioreHur"
literal "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $T$
\end_inset

 denote the set of simple types generated by a set of simple types.
 A metavariable arity 
\begin_inset Formula $\tau_{1},\dots,\tau_{n}\vdash\tau_{f}$
\end_inset

 is given by a list of input types 
\begin_inset Formula $\tau_{1},\dots,\tau_{n}$
\end_inset

 and an output type 
\begin_inset Formula $\tau_{f}$
\end_inset

.
 Substituting a metavariable 
\begin_inset Formula $M:(\Gamma\vdash\tau)$
\end_inset

 with another 
\begin_inset Formula $M':(\Gamma'\vdash\tau')$
\end_inset

 requires that 
\begin_inset Formula $\tau=\tau'$
\end_inset

 and involves an injective renaming 
\begin_inset Formula $\Gamma\rightarrow\Gamma'$
\end_inset

.
 Thus, we consider 
\begin_inset Formula ${\cal A}=\mathbb{F}_{m}[T]\times T$
\end_inset

 , where 
\begin_inset Formula $\mathbb{F}_{m}[T]$
\end_inset

 is the category of finite lists of elements of 
\begin_inset Formula $T$
\end_inset

 and injective renamings between them.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The syntax for simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus can be specified by a suitable endofunctor, see e.g.
 
\begin_inset CommandInset citation
LatexCommand cite
key "FioreHur"
literal "false"

\end_inset

.
\end_layout

\end_inset

 The following table summarises the definition of the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 specifying the syntax, where 
\begin_inset Formula $|\Gamma|_{\tau}$
\end_inset

 denotes the number (as a cardinal set) of occurrences of 
\begin_inset Formula $\tau$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{\ell}(\Gamma\vdash\tau)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{\ell,j}(\Gamma\vdash\tau)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\Gamma|_{\tau}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\vdash t:\tau'\Rightarrow\tau\quad\Gamma\vdash u:\tau'}{\Gamma\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in T\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\Gamma\vdash\tau'\Rightarrow\ensuremath{\tau}\\
H_{-,1}=\Gamma\vdash\tau'
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Gamma,\tau_{1}\vdash\tau_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Arguments as sets
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:ex-arg-sets"

\end_inset

If we think of the arguments of a metavariable as specifying the available
 variables, then it makes sense to assemble them in a set rather than in
 a list.
 This motivates considering the category 
\begin_inset Formula ${\cal A}=\mathbb{I}$
\end_inset

 whose objects are natural numbers and a morphism 
\begin_inset Formula $n\rightarrow p$
\end_inset

 is a subset of 
\begin_inset Formula $\{0,\dots,p-1\}$
\end_inset

 of cardinal 
\begin_inset Formula $n$
\end_inset

.
 For instance, 
\begin_inset Formula $\mathbb{I}$
\end_inset

 can be taken as subcategory of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 consisting of strictly increasing injections, or as the subcategory of
 the augmented simplex category consisting of injective functions.
 Again, we can define the endofunctor for 
\begin_inset Formula $\lambda$
\end_inset

-calculus as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generalise"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Then, a metavariable takes as argument a set of available variables, rather
 than a list of distinct variables.
 In this approach, unifying two metavariables (see the rules 
\begin_inset Formula $\refrule{U-FlexFlex}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

) amount to computing a set intersection.
\end_layout

\begin_layout Subsection
Arities as sets
\end_layout

\begin_layout Standard
In this example, we describe pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with metavariables whose arities are sets of free variables.
 They do not take any explicit argument and they cannot be applied to bound
 variables.
 
\end_layout

\begin_layout Standard
We adopt a locally nameless approach, with two kinds of variables: the named
 ones, chosen in an infinite set 
\begin_inset Formula ${\cal V}$
\end_inset

 of names (e.g., 
\begin_inset Formula $\mathbb{N}$
\end_inset

), and the unnamed ones, as before, which will be used for binding.
 We thus choose 
\begin_inset Formula $\mathcal{A}$
\end_inset

 to be 
\begin_inset Formula $\mathbb{S}\times\mathbb{F}_{m}$
\end_inset

 where 
\begin_inset Formula $\mathbb{S}$
\end_inset

 is the category of finite subsets of 
\begin_inset Formula $\mathcal{V}$
\end_inset

 and inclusions (not injections!) between them.
 Pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus can be specified by an endofunctor 
\begin_inset Formula $F$
\end_inset

 defined by 
\begin_inset Formula $F(X)_{A,n}=n+A+X_{A,n+1}+X_{A,n}\times X_{A,n}$
\end_inset

.
\end_layout

\begin_layout Standard
A metavariable arity, as an object of 
\begin_inset Formula ${\cal A}$
\end_inset

, consists of two components: a finite set of named variables, and a number
 of arguments among unnamed variables.
 Let us define pure arities as those whose second component is 
\begin_inset Formula $0$
\end_inset

.
 A metavariable is said pure if its arity is, and a metavariable context
 is said pure if each metavariable is.
 
\end_layout

\begin_layout Standard
The pure metavariables are the ones mentioned at the beginning of this section.
 Unifying a pure metavariable with itself, as in the rule 
\begin_inset Formula $\refrule{U-FlexFlex}$
\end_inset

, is a no-op, while unifying a pure metavariable with another one (rule
 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

) produces a new pure metavariable whose arity is the intersection of the
 input metavariable arities.
 Exploiting this observation, an easy induction shows that the most general
 unifier targets a pure metavariable context.
\end_layout

\begin_layout Lemma
Assume an endofunctor for syntax as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:endo-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 If 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 or 
\begin_inset Formula $\Gamma\prune t{\coprod_{i}{\cal L}f_{i}}{\sigma}u\dashv\Delta$
\end_inset

, and 
\begin_inset Formula $\Delta\neq\bot$
\end_inset

, then 
\begin_inset Formula $\Delta$
\end_inset

 is pure whenever 
\begin_inset Formula $\Gamma$
\end_inset

 is.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\color red
I don't know if that's useful
\color inherit
: the metavariable arity rather specify which closest bound variables it
 can use.A metavariable can be substituted with another if the arity of the
 latter is included in the arity of the former.
 This motivates considering the category 
\begin_inset Formula ${\cal A}=\mathbb{S}$
\end_inset

 whose objects are finite subsets of 
\begin_inset Formula $\mathbb{N}$
\end_inset

, and morphisms are inclusions.
 In this approach, the rule 
\begin_inset Formula $\textsc{U-FlexFlex}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 unifying a metavariable with itself is a no-op, while unifying a metavariable
 with another one (rule 
\begin_inset Formula $\textsc{P-Flex}$
\end_inset

) amounts to computing the intersection of their arities.
\end_layout

\begin_layout Plain Layout
We can adapt the specification of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus to this setting: 
\begin_inset Formula $F(X)_{A}=A+X_{A}\times X_{A}+X_{A+1}$
\end_inset

, where 
\begin_inset Formula $A\mapsto A+1$
\end_inset

 is the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping a subset 
\begin_inset Formula $A$
\end_inset

 of 
\begin_inset Formula $\mathbb{N}$
\end_inset

 to 
\begin_inset Formula $\{0\}\cup\{a+1|a\in A\}$
\end_inset

.
 Let us describe inductively the syntax.
 A variable context 
\begin_inset Formula $C$
\end_inset

 is then a finite subset of 
\begin_inset Formula $\mathbb{N}$
\end_inset

.
\begin_inset Formula 
\[
\dfrac{x\in C}{\Gamma;C\vdash x}\qquad\dfrac{\Gamma;C\vdash t\quad\Gamma;C\vdash u}{\Gamma;C\vdash t\ u}\qquad\dfrac{\Gamma;C+1\vdash t}{\Gamma;C\vdash\lambda t}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{M:A\in\Gamma\quad A\subset C}{\Gamma;C\vdash M}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Note that a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $\{0\}$
\end_inset

 can be used either at top level in the variable context 
\begin_inset Formula $\{0\}$
\end_inset

, or in 
\begin_inset Formula $\lambda t$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Thinking of metavariables as sets rather than
\end_layout

\begin_layout Plain Layout
Consider 
\begin_inset Formula $\mathbb{S}$
\end_inset

 the category where objects are natural numbers and a morphism 
\begin_inset Formula $n\rightarrow p$
\end_inset

 is a subset of 
\begin_inset Formula $\{0,\dots,p-1\}$
\end_inset

 of cardinal 
\begin_inset Formula $n$
\end_inset

.
 For instance, 
\begin_inset Formula $\mathbb{S}$
\end_inset

 can be taken as subcategory of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 consisting of strictly increasing injections, or as the subcategory of
 the augmented simplex category consisting of injective functions.
 Again, we can define the endofunctor for 
\begin_inset Formula $\lambda$
\end_inset

-calculus as before.
 Then, a metavariable takes as argument a set of available variables, rather
 than a list of distinct variables.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\begin_layout Standard
In this section we explain how we can define pattern unification for quantum
 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/popl/PaganiSV14"
literal "false"

\end_inset

.
 We denote by 
\begin_inset Formula $S$
\end_inset

 the set of types, which is inductively generated as follows
\begin_inset Formula 
\[
A,B,C\in S::=\mathbf{qubit}|A\multimap B|!(A\multimap B)|1|A\otimes B|A+B|A^{\ell}
\]

\end_inset

where 
\begin_inset Formula $A^{\ell}$
\end_inset

 is intuitively the type of finite lists of elements of type 
\begin_inset Formula $A$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We denote by 
\begin_inset Formula $!S$
\end_inset

 the set of non-linear types, that is, types of the shape 
\begin_inset Formula $!-$
\end_inset

.
 In fact 
\begin_inset Formula $!S$
\end_inset

 is isomorphic to 
\begin_inset Formula $S\times S$
\end_inset

, since any non linear type must be of the shape 
\begin_inset Formula $!(A\multimap B)$
\end_inset

.
 We denote by 
\begin_inset Formula $\boldsymbol{S}$
\end_inset

 the set of linear types.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We consider metavariable arities of the shape 
\begin_inset Formula $\Delta\vdash A$
\end_inset

, where 
\begin_inset Formula $\Delta$
\end_inset

 is the multiset of the argument types, and 
\begin_inset Formula $A$
\end_inset

 is the output type of the metavariable.
 We denote by 
\begin_inset Formula $!\Delta$
\end_inset

 the non linear part of 
\begin_inset Formula $\Delta$
\end_inset

, i.e., its sub-multiset consisting of its non-linear types, that is, types
 of the shape 
\begin_inset Formula $!A$
\end_inset

.
 We denote by 
\begin_inset Formula $\boldsymbol{\Delta}$
\end_inset

 the linear part of 
\begin_inset Formula $\Delta$
\end_inset

.
 Substituting a metavariable of arity 
\begin_inset Formula $\Delta_{1}\vdash A_{1}$
\end_inset

 with a metavariable of arity 
\begin_inset Formula $\Delta_{2}\vdash A_{2}$
\end_inset

 requires that 
\begin_inset Formula $A_{1}=A_{2}$
\end_inset

, 
\begin_inset Formula $\boldsymbol{\Delta_{1}}=\boldsymbol{\Delta_{2}}$
\end_inset

, and an injective renaming 
\begin_inset Formula $\bang\Delta_{1}\hookrightarrow\bang\Delta_{2}$
\end_inset

.
 Therefore, we choose 
\begin_inset Formula ${\cal A}$
\end_inset

 to be the category whose objects are metavariable arities 
\begin_inset Formula $\Delta\vdash A$
\end_inset

 and the set of morphisms between 
\begin_inset Formula $\Delta_{1}\vdash A_{1}$
\end_inset

 and 
\begin_inset Formula $\Delta_{2}\vdash A_{2}$
\end_inset

 is empty if 
\begin_inset Formula $A_{1}\neq A_{2}$
\end_inset

 or 
\begin_inset Formula $\boldsymbol{\Delta_{1}}\neq\boldsymbol{\Delta_{2}}$
\end_inset

, or is the set of injective renamings between 
\begin_inset Formula $!\Delta_{1}$
\end_inset

 and 
\begin_inset Formula $\bang\Delta_{2}$
\end_inset

 otherwise.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
A metavariable could have linear arguments, and non linear ones.
 We therefore consider metavariable arities 
\begin_inset Formula $\Gamma;!\Delta\vdash A$
\end_inset

, where 
\begin_inset Formula $\Gamma$
\end_inset

 is a finite multi-set of linear types, 
\begin_inset Formula $!\Delta$
\end_inset

 is a multi-set of non linear types, and 
\begin_inset Formula $A$
\end_inset

 is the output type of the metavariable.
 Substituting a metavariable of arity 
\begin_inset Formula $\Gamma_{1};!\Delta_{1}\vdash A_{1}$
\end_inset

 with a metavariable of arity 
\begin_inset Formula $\Gamma_{2};!\Delta_{2}\vdash A_{2}$
\end_inset

 requires that 
\begin_inset Formula $\Gamma_{1}=\Gamma_{2}$
\end_inset

, 
\begin_inset Formula $A_{1}=A_{2}$
\end_inset

, and an injective renaming 
\begin_inset Formula $!\Delta_{1}\hookrightarrow!\Delta_{2}$
\end_inset

.
 Therefore, we choose 
\begin_inset Formula ${\cal A}=\bang S\times\mathbb{R}[\underline{S}]\times S$
\end_inset

, where 
\begin_inset Formula $\mathbb{R}[\underline{S}]$
\end_inset

 is the category of multisets in 
\begin_inset Formula $\underline{S}$
\end_inset

 and injective renamings between them.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The components of the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 are specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:quantum-endo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except for the promotion, which we discuss below.
 We use the following notations.
\end_layout

\begin_layout Notation
\begin_inset Formula $\delta(P)$
\end_inset

 denotes either a singleton set or the empty set, depending on whether the
 property 
\begin_inset Formula $P$
\end_inset

 is true.
\end_layout

\begin_layout Notation
\begin_inset Formula $|\Delta|_{!C}$
\end_inset

 denotes the number of occurrences of 
\begin_inset Formula $!C$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

.
 By convention, we take it to be 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $!C$
\end_inset

 does not make sense (i.e., when 
\begin_inset Formula $C$
\end_inset

 is not 
\begin_inset Formula $A\multimap B$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
, listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:quantum-endo"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 A type 
\begin_inset Formula $\boldsymbol{A}$
\end_inset

 in bold face is implicitly assumed to be linear; a multiset 
\begin_inset Formula $\boldsymbol{\Gamma}$
\end_inset

 in bold face is implicitly assumed to consist of linear types only.
 A context 
\begin_inset Formula $!\Delta$
\end_inset

 in the typing rules consists of non linear types only.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first rule handles the term constants in 
\begin_inset Formula ${\cal C}=\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}$
\end_inset

, that all have typing rules of the following shape
\begin_inset Formula 
\[
\dfrac{c\in{\cal C}}{!\Delta\vdash c:A_{c}\multimap B_{c}}
\]

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Here, the context 
\begin_inset Formula $!\Delta$
\end_inset

 consists only of non linear types.
 We take
\begin_inset Formula 
\[
O_{c}(\Delta\vdash C)=\delta(\Delta\vdash C=\bang\Delta\vdash A_{c}\multimap B_{c})\qquad\gamma_{c}=0
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula ${\cal A}(\emptyset\vdash A_{c}\multimap B_{c},\Gamma\vdash C)$
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{c}}y(\emptyset\vdash A_{c}\multimap B_{c})
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
where 
\begin_inset Formula $\delta(P)$
\end_inset

 denotes either a singleton set or the empty set, depending on whether 
\begin_inset Formula $P$
\end_inset

 is true.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, 
\begin_inset Formula ${\cal A}(\emptyset\vdash\tau,\Delta\vdash C)$
\end_inset

 is non-empty and a singleton set precisely when 
\begin_inset Formula $A=\tau$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\Delta}=\emptyset$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Now, we introduce the linear variable case
\begin_inset Formula 
\[
\infer[ax]{\bang{\Delta},x:A\entail x:A}{\text{\ensuremath{A} linear}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
we take
\begin_inset Formula 
\[
O_{v}(\Delta\vdash C)=\delta(\boldsymbol{\Delta}=C)\qquad\gamma_{v}=0
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{\boldsymbol{A}}y(\boldsymbol{A}\vdash\boldsymbol{A})}
\]

\end_inset

where 
\begin_inset Formula $|\Delta|_{\boldsymbol{A}}$
\end_inset

 counts the number of occurrences of 
\begin_inset Formula $\boldsymbol{A}$
\end_inset

 inIndeed, 
\begin_inset Formula $y(\boldsymbol{A}\vdash\boldsymbol{A})$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is a singleton set (accounting for the variable 
\begin_inset Formula $x$
\end_inset

) and non empty precisely when 
\begin_inset Formula $\Delta$
\end_inset

 is of the shape 
\begin_inset Formula $!\Delta,x:\boldsymbol{A}$
\end_inset

, and 
\begin_inset Formula $\tau=\boldsymbol{A}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us handle the non linear variable case.
\begin_inset Formula 
\[
\infer[axd]{\bang{\Delta},x:\bang(A\loli B)\entail x:A\loli B}{}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
We take
\begin_inset Formula 
\[
O_{v!}(\Delta\vdash C)=\delta(\Delta=\bang\Delta)\times|\Delta|_{!C}\qquad\gamma_{v!}=0
\]

\end_inset

where 
\begin_inset Formula $|\Delta|_{!C}$
\end_inset

 counts the number of occurrences of 
\begin_inset Formula $!C$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

.
 By convention, we take it to be 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $!C$
\end_inset

 does not make sense.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, 
\begin_inset Formula $y(!(A\multimap B)\vdash A\multimap B)$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is the number (as a cardinal set) of occurences of 
\begin_inset Formula $!(A\multimap B)$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

, whenever 
\begin_inset Formula $\tau=A\multimap B$
\end_inset

 (otherwise, it is the empty set).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us now handle the 
\begin_inset Formula $\lambda$
\end_inset

-abstraction rule.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\infer[\loli_{I}]{\Delta\entail\lambda x^{A}.M:A\loli B}{\Delta,x:A\entail M:B}
\]

\end_inset

Denoting linear contexts with a bold face, we take 
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
O_{l}(\Delta\vdash C)=\{l_{A,B}|C=A\multimap B)\qquad H_{l,1}(\Delta\vdash C,l_{A,B})=(\Delta,A\vdash B)
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
where 
\begin_inset Formula $\underline{\Delta},A\vdash B$
\end_inset

 denotes the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping 
\begin_inset Formula $\Delta'\vdash A'$
\end_inset

 to 
\begin_inset Formula $\Delta',A\vdash B$
\end_inset

.
 Note that 
\begin_inset Formula $y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is non-empty only when 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma}$
\end_inset

 and 
\begin_inset Formula $\tau=A\multimap B$
\end_inset

, in which case it is a singleton set.
 This is why we have to quantify over 
\begin_inset Formula $\boldsymbol{\Gamma}$
\end_inset

, so that it works for any 
\begin_inset Formula $\Delta$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us now discuss promotion for values.
\begin_inset Formula 
\[
\infer[p]{\bang\Delta\entail V:\bang{(A\loli B)}}{\bang\Delta\entail V:A\loli B}
\]

\end_inset

This typing rule can be split as in the following table, depending on what
 
\begin_inset Formula $V$
\end_inset

 is: a variable, a 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, or a term constant 
\begin_inset Formula $c\in{\cal C}=\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}$
\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules for values
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\dots+\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{}{!\Delta,x:\bang(A\multimap B)\vdash x:\bang(A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash\bang(A\multimap B))}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{!\Delta,x:A\vdash M:B}{!\Delta\vdash\lambda x^{A}.M:\bang(A\multimap B)}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}X_{\underline{\Delta},A\vdash B}\times y(\emptyset\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{}{!\Delta\vdash c:\bang(A_{c}\multimap B_{c})}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{c}}y(\emptyset\vdash\bang(A_{c}\multimap B_{c}))$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules for values
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{\ell}(\Delta\vdash C)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{\ell,j}(\Delta\vdash C,o)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!\Delta,x:\bang(A\multimap B)\vdash x:\bang(A\multimap B)$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\frac{}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta(\Delta=\bang\Delta)\times|\Delta|_{C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{!\Delta,x:A\vdash M:B}{!\Delta\vdash\lambda x^{A}.M:\bang(A\multimap B)}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{r}
\{l_{A,B,v}|\Delta\vdash C=\\
\bang\Delta\vdash\bang(A\multimap B)\}
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,1}(l_{A,B,v})=\Delta,A\vdash B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!\Delta\vdash c:\bang(A_{c}\multimap B_{c})$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\frac{}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{c}
\delta(\Delta\vdash C=\\
\bang\Delta\vdash\bang(A_{c}\multimap B_{c}))
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Let us explain how the coproduct components are inferred.
 Each premise is straightforwardly translated.
 For example, in the elimination rule for abstraction, the premise 
\begin_inset Formula $\bang\Delta,\Gamma\entail M:A\loli B$
\end_inset

 becomes 
\begin_inset Formula $X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}$
\end_inset

, where 
\begin_inset Formula $\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B$
\end_inset

 is the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 to 
\begin_inset Formula $!\Delta,\boldsymbol{\Gamma}\vdash A\multimap B$
\end_inset

.
 Conclusions are always of the shape 
\begin_inset Formula $!\Delta,\Gamma\vdash t:\tau$
\end_inset

, or 
\begin_inset Formula $!\Delta,\Gamma,\Sigma\vdash t:\tau$
\end_inset

 where 
\begin_inset Formula $\Gamma,\Sigma$
\end_inset

 consist of linear types.
 This justifies the global quantification over 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Sigma$
\end_inset

, and the multiplication by a representable functor 
\begin_inset Formula $y(\boldsymbol{\Gamma}\vdash\tau)$
\end_inset

 or 
\begin_inset Formula $y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash\tau)$
\end_inset

, which evaluated at 
\begin_inset Formula $\Delta\vdash A$
\end_inset

 is non-empty (and a singleton set) precisely when 
\begin_inset Formula $A=\tau$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma}$
\end_inset

, or 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma},\boldsymbol{\Sigma}$
\end_inset

 in the second case.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $!\Delta$
\end_inset

 is non linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $!\Delta$
\end_inset

 is non linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{c\in\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}}{!\Delta\vdash c:A_{c}\multimap B_{c}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{c}}y(\emptyset\vdash A_{c}\multimap B_{c})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{A}}y(\boldsymbol{A}\vdash\boldsymbol{A})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{adjustbox}{rotate=90}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\dots+\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:B}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_E]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma,
\backslash
Sigma
\backslash
entail   
\backslash
letunitterm{M}{N}:A }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash1}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\boldsymbol{\Sigma}}\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_I]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
tensterm{M}{N}:A
\backslash
tensor B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash B}\times y(\boldsymbol{\Gamma},\boldsymbol{\boldsymbol{\Sigma}}\vdash A\otimes B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail    
\backslash
lettensterm{x^{A}}{y^{B}}{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
tensor B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A,y:B
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B,C}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\otimes B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},A,B\vdash C}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^
\backslash
ell]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injl{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A}\times y(\boldsymbol{\Gamma}\vdash A\oplus B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^r]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injr{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\oplus B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
match{P}{x^A}{M}{y^B}N:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail P:A
\backslash
sumtype B   &   
\backslash
deduce{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,y:B
\backslash
entail N:C}{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A
\backslash
entail M:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B,C}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\oplus B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},A\vdash C}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},B\vdash C}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tlist{-
\backslash
!}_{
\backslash
!
\backslash
!I}]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   M:
\backslash
tlist{A} }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit
\backslash
oplus(A{
\backslash
otimes}
\backslash
tlist A) } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash1\oplus(A\otimes A^{l})}\times y(\boldsymbol{\Gamma}\vdash A^{l})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[{
\backslash
tt rec}]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma
\backslash
entail 
\backslash
letrec{f^{A
\backslash
multimap B}}{x}{M}{N}:C }
\end_layout

\begin_layout Plain Layout

{  
\backslash
deduce
\end_layout

\begin_layout Plain Layout

{ 
\backslash
bang
\backslash
Delta,f:
\backslash
bang{(A
\backslash
multimap B)},x:A
\backslash
entail M:B   }
\end_layout

\begin_layout Plain Layout

{  
\backslash
bang
\backslash
Delta,
\backslash
Gamma,f:
\backslash
bang{(A
\backslash
multimap B)}
\backslash
entail N:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B,C}X_{\underline{!\Delta},!(A\multimap B),A\vdash B}\times X_{\underline{!\Delta},\boldsymbol{\Gamma},!(A\multimap B)\vdash C}\times y(\boldsymbol{\Gamma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{\ell}(\Delta\vdash C)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{\ell,j}(\Delta\vdash C,o)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{c\in{\cal C}}{!\Delta\vdash c:A_{c}\multimap B_{c}}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\delta(\Delta\vdash C=\bang\Delta\vdash A_{c}\multimap B_{c})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[ax]{\bang{\Delta},x:A\entail x:A}{\text{\ensuremath{A} linear}}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta(\boldsymbol{\Delta}=C)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[axd]{\bang{\Delta},x:\bang(A\loli B)\entail x:A\loli B}{}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta(\Delta=\bang\Delta)\times|\Delta|_{!C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[\loli_{I}]{\Delta\entail\lambda x^{A}.M:A\loli B}{\Delta,x:A\entail M:B}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\dfrac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{A,B}|C=A\multimap B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,1}=\Delta,A\vdash B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:C}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli C   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\Gamma,\Sigma,A}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\multimap C\\
H_{-,1}=\bang\Delta,\Sigma\vdash A
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_E]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma,
\backslash
Sigma
\backslash
entail   
\backslash
letunitterm{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{u_{\Gamma,\Sigma}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash1\\
H_{-,1}=\bang\Delta,\Sigma\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_I]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
tensterm{M}{N}:A
\backslash
tensor B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{t_{A,B,\Gamma,\Sigma}|\Delta\vdash C=\bang\Delta,\Gamma,\Sigma\vdash A\otimes B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\\
H_{-,1}=\bang\Delta,\Sigma\vdash B
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail    
\backslash
lettensterm{x^{A}}{y^{B}}{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
tensor B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A,y:B
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{t'_{A,B,\Gamma,\Sigma}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\otimes B\\
H_{-,1}=\bang\Delta,\Sigma,A,B\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^
\backslash
ell]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injl{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{inl_{A,B}|C=A\oplus B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^r]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injr{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{inr_{A,B}|C=A\oplus B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
match{P}{x^A}{M}{y^B}N:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail P:A
\backslash
sumtype B   &   
\backslash
deduce{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,y:B
\backslash
entail N:C}{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A
\backslash
entail M:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{\frac{}{}}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{m_{A,B,\Gamma,\Sigma}|\Delta=!\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\oplus B\\
H_{-,1}=\bang\Delta,\Sigma,A\vdash C\\
H_{-,2}=\bang\Delta,\Sigma,B\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tlist{-
\backslash
!}_{
\backslash
!
\backslash
!I}]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   M:
\backslash
tlist{A} }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit
\backslash
oplus(A{
\backslash
otimes}
\backslash
tlist A) } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{tail_{A}|C=A^{\ell}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash1\oplus(A\otimes A^{\ell})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[{
\backslash
tt rec}]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma
\backslash
entail 
\backslash
letrec{f^{A
\backslash
multimap B}}{x}{M}{N}:C }
\end_layout

\begin_layout Plain Layout

{  
\backslash
deduce
\end_layout

\begin_layout Plain Layout

{ 
\backslash
bang
\backslash
Delta,f:
\backslash
bang{(A
\backslash
multimap B)},x:A
\backslash
entail M:B   }
\end_layout

\begin_layout Plain Layout

{  
\backslash
bang
\backslash
Delta,
\backslash
Gamma,f:
\backslash
bang{(A
\backslash
multimap B)}
\backslash
entail N:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{\frac{}{}}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{rec_{A,B}|A,B\in S\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\Delta,f:\bang(A\multimap B)\vdash C\\
H_{-,1}=\bang\Delta,f:\bang(A\multimap B),A\vdash B
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{adjustbox}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Some components of the endofunctor specifying the quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:quantum-endo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset\vdash1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
splitlist]{   
\backslash
bang
\backslash
Delta
\backslash
entail
\backslash
splitlist[A] :    
\backslash
tlist A {
\backslash
multimap}
\backslash
tunit
\backslash
oplus(A{
\backslash
otimes}
\backslash
tlist A) }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A}}y(\emptyset\vdash A^{\ell}{\multimap}\tunit\oplus(A{\otimes}\tlist A))$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
meas]{   
\backslash
bang
\backslash
Delta
\backslash
entail   
\backslash
meas:
\backslash
qubit
\backslash
multimap 
\backslash
bit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset\vdash\qubit\multimap\bit)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
new]{   
\backslash
bang
\backslash
Delta
\backslash
entail   
\backslash
new:
\backslash
bit
\backslash
multimap
\backslash
qubit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset\vdash\bit\multimap\qubit)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[U]{   
\backslash
bang
\backslash
Delta
\backslash
entail   U:
\backslash
qubit^{
\backslash
otimes n}
\backslash
multimap
\backslash
qubit^{
\backslash
otimes n} }{U 
\backslash
text{ of arity $n$}} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{n}\coprod_{U\text{ of arity \ensuremath{n}}}}y(\emptyset\vdash\qubit^{\otimes n}\multimap\qubit^{\otimes n})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
end{adjustbox}
\end_layout

\begin_layout Plain Layout

%
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)_{\Gamma;!\Delta\vdash\tau}=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{ (\ensuremath{\Gamma=\{A\}}, \ensuremath{\tau=A})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A\in\bang S}y(A;\emptyset\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|!\Delta|_{!A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B\in S}y(\emptyset;!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
See note below
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{1,\tau}\delta_{\Gamma,\emptyset}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset;\emptyset\vdash1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{\Gamma,A;!\Delta\vdash B}$
\end_inset

 or 
\begin_inset Formula $X_{\Gamma;!\Delta,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)_{\Delta\vdash\tau}=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\boldsymbol{\Delta},\{A\}}\delta_{\tau,A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A\in\boldsymbol{S}}y(A\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|!\Delta|_{!(A\multimap B)}\delta_{\boldsymbol{\Delta},\emptyset}\delta_{\tau,A\multimap B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B\in S}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
See note below
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\tau,1}\delta_{\boldsymbol{\Delta},\emptyset}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset\vdash1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{\Delta,A\vdash B}\delta_{\tau,A\multimap B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:B}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{!\Delta,\Gamma\vdash A\multimap B}\times X_{!\Delta,\Sigma\vdash A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\Delta,(!\Delta,\Gamma,\Sigma)}\delta_{\tau,B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\Delta}\vdash B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We take the example of linear 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 A metavariable arity is then a natural number specifying the number of
 arguments, and because of linearity, a metavariable can only be substituted
 with another one with the same arity.
 We therefore 
\begin_inset Formula ${\cal A}={\cal P}$
\end_inset

 to be category whose objects are finite cardinals and morphisms are bijections
 as in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/mfcs/Tanaka00"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Each typing rule provides an operation
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1\vdash*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Application
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n\vdash t\qquad m\vdash u}{n+m\vdash t\ u}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{n}\times X_{m}\times y_{n+m}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Intuitively, given 
\begin_inset Formula $X\in\Set$
\end_inset

, the set 
\begin_inset Formula $X_{n}$
\end_inset

 is the set of expressions with exactly 
\begin_inset Formula $n$
\end_inset

 (distinct) variables.
 Then, we can consider the linear lambda-calculus, as an endofunctor on
 
\begin_inset Formula $\Set$
\end_inset

 mapping 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $F(X)$
\end_inset

 where 
\begin_inset Formula $F(X)_{n}=y1+\coprod_{p+q=n}X_{p}\times X_{q}+(n+1)\times X_{n+1}$
\end_inset

.
 Note that we could also specify a non-linear binder by replacing 
\begin_inset Formula $(n+1)\times X_{n+1}$
\end_inset

 with 
\begin_inset Formula $\coprod_{p>n}\left(\begin{array}{c}
p\\
n
\end{array}\right)X_{p}$
\end_inset

.
 We could also have a non linear application by replacing 
\begin_inset Formula $\coprod_{p+q=n}X_{p}\times X_{q}$
\end_inset

 with 
\begin_inset Formula $X_{n}\times X_{n}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Then, 
\begin_inset Formula $F^{*}(0)$
\end_inset

 is the linear lambda-calculus.
 
\begin_inset Formula $F^{*}(yn)$
\end_inset

 is the syntax of linear 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with one 
\begin_inset Formula $n$
\end_inset

-ary metavariable applied to 
\begin_inset Formula $n$
\end_inset

 (distinct) variables.
 
\end_layout

\begin_layout Plain Layout
Note that 
\begin_inset Formula $F(X)$
\end_inset

 is of the shape 
\begin_inset Formula $I+\coprod_{i}X_{p_{i,1}}\times\dots\times X_{p_{i,m_{i}}}\times yn_{i}$
\end_inset

 and each 
\begin_inset Formula $X\mapsto X_{p_{i,1}}\times\dots\times X_{p_{i,m_{i}}}\times yn_{i}$
\end_inset

 is left adjoint to 
\begin_inset Formula $X\mapsto X_{n_{i}}\times(yp_{i,1}+\dots+yp_{i,m_{i}})$
\end_inset

.
 
\color red
No
\color inherit

\begin_inset Formula $\bang$
\end_inset


\color red
 But almost, i.e., if there exists a morphism 
\begin_inset Formula $A\rightarrow X_{p}\times y_{n}$
\end_inset

, then in fact 
\begin_inset Formula $A=A_{n}yn$
\end_inset

 and there exists a morphism 
\begin_inset Formula $A_{n}\times yp\rightarrow X$
\end_inset

, but the converse is false.
 
\end_layout

\begin_layout Remark
We could have done the non-linear version in this setting as well, but the
 abstract syntax is more convoluted (see the binomial coefficient) and metavaria
bles must still be linear.
\end_layout

\begin_layout Example
linear lambda calculus, quantum lambda calculus
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Intrinsic polymorphic syntax
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
We present intrinsic system F, following
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HamanaPoly"
literal "false"

\end_inset

.
 Let 
\begin_inset Formula $S:\mathbb{F}_{m}\rightarrow\Set$
\end_inset

 mapping 
\begin_inset Formula $n$
\end_inset

 to the set 
\begin_inset Formula $S_{n}$
\end_inset

 of types for system 
\begin_inset Formula $F$
\end_inset

 taking free type variables in 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
 Intuitively, a metavariable arity 
\begin_inset Formula $n;\sigma_{1},\dots,\sigma_{p}\vdash\tau$
\end_inset

 specifies the number 
\begin_inset Formula $n$
\end_inset

 of free type variables, the list of input types 
\begin_inset Formula $\vec{\sigma}$
\end_inset

, and the output type 
\begin_inset Formula $\tau$
\end_inset

, all living in 
\begin_inset Formula $S_{n}$
\end_inset

.
 Substituting a metavariable 
\begin_inset Formula $M:(n;\vec{\sigma}\vdash\tau)$
\end_inset

 with another 
\begin_inset Formula $M':(n';\vec{\sigma}'\vdash\tau')$
\end_inset

 requires a choice 
\begin_inset Formula $(\alpha_{0},\dots,\alpha_{n-1})$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 distinct type variables among 
\begin_inset Formula $\{0,\dots n'-1\}$
\end_inset

, such that 
\begin_inset Formula $\tau[\vec{\alpha}]=\tau'$
\end_inset

, and an injective renaming 
\begin_inset Formula $\vec{\sigma'}[\vec{\alpha}]\rightarrow\vec{\sigma}$
\end_inset

.
 We therefore consider the category 
\begin_inset Formula ${\cal A}$
\end_inset

 of metavariable arities where a morphism between 
\begin_inset Formula $n,\Gamma\vdash\tau$
\end_inset

 and 
\begin_inset Formula $n',\Gamma'\vdash\tau'$
\end_inset

 is a morphism 
\begin_inset Formula $\sigma:n\rightarrow n'$
\end_inset

 in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 such that 
\begin_inset Formula $\tau[\sigma]=\tau'$
\end_inset

, and a renaming 
\begin_inset Formula $\Gamma[\sigma]\rightarrow\Gamma'$
\end_inset

 .
 More formally, 
\begin_inset Formula ${\cal A}$
\end_inset

 is the op-lax colimit of 
\begin_inset Formula $n\mapsto\mathbb{F}_{m}[S_{n}]\times S_{n}$
\end_inset

.
 The intrinsic syntax of system 
\begin_inset Formula $F$
\end_inset

 can then be specified as follows.
\end_layout

\begin_layout Standard
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{n;\Gamma\vdash\tau}=\coprod\dots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $L_{n;\Gamma\vdash\tau,o,j}=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{\Delta;\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\Gamma|_{\tau}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n;\Gamma\vdash t:\tau'\Rightarrow\tau\quad n;\Gamma\vdash u:\tau'}{n;\Gamma\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in S_{n}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
L_{-,0}=n;\Gamma\vdash\tau'\Rightarrow\ensuremath{\tau}\\
L_{-,1}=n;\Gamma\vdash\tau'
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n;\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{n;\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $L_{-,0}=n;\Gamma,\tau_{1}\vdash\tau_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n|\Gamma\vdash t:\Lambda\tau_{1}\quad\tau_{2}\in S_{n}}{n|\Gamma\vdash t\cdot\tau_{2}:\tau_{1}[\tau_{2}]}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{A_{\tau_{1},\tau_{2}}|\tau=\tau_{1}[\tau_{2}]\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $L_{-,0}=n;\Gamma\vdash\Lambda\tau_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n+1|wk(\Gamma)\vdash t:\tau}{n|\Gamma\vdash\Lambda t:\Lambda\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{\Lambda_{\tau'}|\tau=\Lambda\tau'\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $L_{-,0}=n+1;wk(\Gamma)\vdash\tau$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{\ell}(n;\Gamma\vdash\tau)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{\ell,j}(n;\Gamma\vdash\tau,o)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{\Delta;\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\Gamma|_{\tau}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n;\Gamma\vdash t:\tau'\Rightarrow\tau\quad n;\Gamma\vdash u:\tau'}{n;\Gamma\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in S_{n}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=n;\Gamma\vdash\tau'\Rightarrow\ensuremath{\tau}\\
H_{-,1}=n;\Gamma\vdash\tau'
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n;\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{n;\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=n;\Gamma,\tau_{1}\vdash\tau_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n|\Gamma\vdash t:\Lambda\tau_{1}\quad\tau_{2}\in S_{n}}{n|\Gamma\vdash t\cdot\tau_{2}:\tau_{1}[\tau_{2}]}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{A_{\tau_{1},\tau_{2}}|\tau=\tau_{1}[\tau_{2}]\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=n;\Gamma\vdash\Lambda\tau_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n+1|wk(\Gamma)\vdash t:\tau}{n|\Gamma\vdash\Lambda t:\Lambda\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{\Lambda_{\tau'}|\tau=\Lambda\tau'\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=n+1;wk(\Gamma)\vdash\tau'$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
To understand how unification of two metavariables works (see the rules
 
\begin_inset Formula $\refrule{U-RigRig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

), let us explain how finite connected limits are computed in 
\begin_inset Formula ${\cal A}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Enumerate
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $F$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

, or equivalently, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-simpl"
plural "false"
caps "true"
noprefix "false"

\end_inset

, each 
\begin_inset Formula $O_{\ell}:{\cal A}\rightarrow\Set$
\end_inset

 and each 
\begin_inset Formula $H_{\ell,j}:\int O_{\ell}\rightarrow{\cal A}$
\end_inset

 preserves finite connected limits.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us introduce the category 
\begin_inset Formula ${\cal A}'$
\end_inset

 whose definition follows that of 
\begin_inset Formula ${\cal A}$
\end_inset

, but without the output types: objects are pairs of a natural number 
\begin_inset Formula $n$
\end_inset

 and an element of 
\begin_inset Formula $S_{n}$
\end_inset

.
 Note that this is op-lax colimit of 
\begin_inset Formula $n\mapsto\mathbb{F}_{m}[S_{n}]$
\end_inset

, and there is an obvious projection 
\begin_inset Formula ${\cal A}\rightarrow{\cal A}'$
\end_inset

, which creates finite limits, as we will show.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:A'-lim"

\end_inset


\begin_inset Formula ${\cal A}'$
\end_inset

 has finite limits, and the projection functor 
\begin_inset Formula ${\cal A}'\rightarrow\mathbb{F}_{m}$
\end_inset

 preserves them.
\end_layout

\begin_layout Proof
The crucial point is that 
\begin_inset Formula ${\cal A}'$
\end_inset

 is not only op-fibred over 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 by construction, it is also fibred over 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
 Intuitively, if 
\begin_inset Formula $\Gamma\in\mathbb{F}_{m}[S_{n}]$
\end_inset

 and 
\begin_inset Formula $f:n'\rightarrow n$
\end_inset

 is a morphism in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

, then 
\begin_inset Formula $f_{!}\Gamma\in\mathbb{F}_{m}[S_{n'}]$
\end_inset

 is essentially 
\begin_inset Formula $\Gamma$
\end_inset

 restricted to elements of 
\begin_inset Formula $S_{n}$
\end_inset

 that are in the image of 
\begin_inset Formula $S_{f}$
\end_inset

.
 Note that 
\begin_inset Formula $f_{!}$
\end_inset

 is right adjoint to 
\begin_inset Formula $\Gamma\mapsto\Gamma[f]$
\end_inset

, and is thus continuous.
 We now apply 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 4.2 and Proposition 4.1"
key "grayfib"
literal "false"

\end_inset

: each 
\begin_inset Formula $\mathbb{F}_{m}[S_{n}]$
\end_inset

 has those limits.
\end_layout

\begin_layout Lemma
The projection functor 
\begin_inset Formula ${\cal A}\rightarrow{\cal A}'$
\end_inset

 creates finite limits.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $d:I\rightarrow{\cal A}$
\end_inset

 be a functor.
 We denote 
\begin_inset Formula $d_{i}$
\end_inset

 by 
\begin_inset Formula $n_{i};\Gamma_{i}\vdash\tau_{i}$
\end_inset

.
 Let 
\begin_inset Formula $n;\Gamma$
\end_inset

 be the limit of 
\begin_inset Formula $i\mapsto n_{i};\Gamma_{i}$
\end_inset

 in 
\begin_inset Formula ${\cal A}'$
\end_inset

.
 By the previous lemma, 
\begin_inset Formula $n$
\end_inset

 is the limit of 
\begin_inset Formula $i\mapsto n_{i}$
\end_inset

.
 Note that 
\begin_inset Formula $S:\mathbb{F}_{m}\rightarrow\Set$
\end_inset

 preserves finite connected limits.
 Thus, we can define 
\begin_inset Formula $\tau\in S_{n}$
\end_inset

 as corresponding to the universal function 
\begin_inset Formula $1\rightarrow S_{n}$
\end_inset

 factorising the cone 
\begin_inset Formula $(1\xrightarrow{\tau_{i}}S_{n_{i}})_{i}$
\end_inset

.
\end_layout

\begin_layout Proof
It is easy to check that 
\begin_inset Formula $n;\Gamma\vdash\tau$
\end_inset

 is the limit of 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
More concretely, a finite connected limit of 
\begin_inset Formula $i\mapsto n_{i};\Gamma_{i}\vdash\tau_{i}$
\end_inset

 in 
\begin_inset Formula ${\cal A}$
\end_inset

 is computed as follows:
\end_layout

\begin_layout Enumerate
compute the limit 
\begin_inset Formula $n$
\end_inset

 of 
\begin_inset Formula $(n_{i})_{i}$
\end_inset

 in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

, denoting 
\begin_inset Formula $p_{i}:n\rightarrow n_{i}$
\end_inset

 is the canonical projections;
\end_layout

\begin_layout Enumerate
define 
\begin_inset Formula $\tau$
\end_inset

 as the (only) element of 
\begin_inset Formula $S_{n}$
\end_inset

 such that 
\begin_inset Formula $\tau[p_{i}]=\tau_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
define 
\begin_inset Formula $\Gamma$
\end_inset

 as the limit in 
\begin_inset Formula $\mathbb{F}_{m}[S_{n}]$
\end_inset

 of 
\begin_inset Formula $p_{i,!}\Gamma_{i}$
\end_inset

, where 
\begin_inset Formula $p_{i,!}:\mathbb{F}_{m}[S_{n_{i}}]\rightarrow\mathbb{F}_{m}[S_{n}]$
\end_inset

 is the reindexing functor described in the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:A'-lim"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
This means that to unify 
\begin_inset Formula $M(\vec{\alpha};\vec{\tau})$
\end_inset

 with 
\begin_inset Formula $M(\vec{\alpha}';\vec{\tau}')$
\end_inset

, with 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $p;\vec{u}\vdash u'$
\end_inset

, we first need to compute the vector of common position 
\begin_inset Formula $\vec{i}$
\end_inset

 between 
\begin_inset Formula $\vec{\alpha}$
\end_inset

 and 
\begin_inset Formula $\vec{\alpha}'$
\end_inset

, i.e, the largest vector 
\begin_inset Formula $(i_{1}<\dots<i_{n})$
\end_inset

 such that 
\begin_inset Formula $\alpha_{i_{j}}=\alpha'_{i_{j}}$
\end_inset

.
 Then, we consider 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma}'$
\end_inset

 so that 
\begin_inset Formula $\vec{\sigma}[j\mapsto i_{j+1}]$
\end_inset

 is the sub-list of 
\begin_inset Formula $\vec{\tau}$
\end_inset

 that only use type variables in 
\begin_inset Formula $\alpha_{i_{1}},\dots,\alpha_{i_{n}}$
\end_inset

, and similarly for 
\begin_inset Formula $\vec{\sigma}'$
\end_inset

 and 
\begin_inset Formula $\vec{\tau}'$
\end_inset

.
 Finally, we define 
\begin_inset Formula $(t_{1},\dots,t_{m})$
\end_inset

 as the vector of common positions between 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma}'$
\end_inset

.
 The most general unifier is then 
\begin_inset Formula $M\mapsto N(\vec{i},\vec{t})$
\end_inset

 for a fresh metavariable 
\begin_inset Formula $N$
\end_inset

 of arity 
\begin_inset Formula $n;\sigma_{t_{1}},\dots\sigma_{t_{m}}\vdash t'$
\end_inset

, where 
\begin_inset Formula $t'$
\end_inset

 is 
\begin_inset Formula $u'[i_{j+1}\mapsto j]$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
With this explicit description, it is straightforward to check that each
 
\begin_inset Formula $O_{\ell}$
\end_inset

 and 
\begin_inset Formula $H_{\ell,j}$
\end_inset

 preserves finite connected limits.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Formula $O\in\C$
\end_inset

.
\end_layout

\begin_layout Proof
It is enough to show that each coproduct component of the above table is
 in 
\begin_inset Formula $\C$
\end_inset

.
 Let us detail type application.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The functor 
\begin_inset Formula $(n;\Gamma\vdash\tau)\mapsto\{\Lambda_{\tau'}|\tau=\Lambda\tau'\}$
\end_inset

 is the equaliser of 
\begin_inset Formula $\xymatrix{S_{\underline{n}+1}\coeqr{u}{v} & S_{\underline{n}}}
$
\end_inset

 where 
\begin_inset Formula $\underline{n}:{\cal A}\rightarrow\mathbb{F}_{m}$
\end_inset

 is the canonical projection, 
\begin_inset Formula $u$
\end_inset

 maps 
\begin_inset Formula $\tau'$
\end_inset

 to 
\begin_inset Formula $\Lambda\tau'$
\end_inset

 and 
\begin_inset Formula $v_{\tau}$
\end_inset

 maps anything to 
\begin_inset Formula $\tau$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\begin_inset Formula $(n;\Gamma\vdash\tau)\mapsto\{A_{\tau_{1},\tau_{2}}|\tau=\tau_{1}[\tau_{2}]\}$
\end_inset

 is the equaliser of 
\begin_inset Formula $\xymatrix{S_{\underline{n}+1}\times S_{\underline{n}}\coeqr{u}{v} & S_{\underline{n}}}
,$
\end_inset

where 
\begin_inset Formula $u$
\end_inset

 maps 
\begin_inset Formula $(\tau_{1},\tau_{2})$
\end_inset

 to 
\begin_inset Formula $\tau_{1}[\tau_{2}]$
\end_inset

 and 
\begin_inset Formula $v_{n;\Gamma\vdash\tau}$
\end_inset

 maps anything to 
\begin_inset Formula $\tau$
\end_inset

.
 
\begin_inset Formula $u$
\end_inset

 is induced by a natural transformation between functors 
\begin_inset Formula $\mathbb{F}_{m}\rightarrow\Set$
\end_inset

.
 Let us check that 
\begin_inset Formula $v$
\end_inset

 is natural.
 Let 
\begin_inset Formula $(n\xrightarrow{f}n',\Gamma[f]\xrightarrow{g}\Gamma')$
\end_inset

 be a morphism between 
\begin_inset Formula $n;\Gamma\vdash\tau$
\end_inset

 and 
\begin_inset Formula $n';\Gamma'\vdash\tau'$
\end_inset

.
 Let 
\begin_inset Formula $(\tau_{1},\tau_{2})\in S_{n+1}\times S_{n}$
\end_inset

.
 We need to check that 
\begin_inset Formula $S_{f}(v_{n;\Gamma\vdash\tau}(\tau_{1},\tau_{2}))=v_{n';\Gamma\vdash\tau'}(S_{f+1}(\tau_{1}),S_{f}(\tau_{2}))$
\end_inset

.
 The l.h.s is 
\begin_inset Formula $S_{f}(\tau)=\tau[f]$
\end_inset

 while the r.h.s is 
\begin_inset Formula $\tau'$
\end_inset

.
 Since 
\begin_inset Formula $(f,g)$
\end_inset

 is a morphism, this equality is ensured.
\end_layout

\begin_layout Lemma
Each 
\begin_inset Formula $H_{\ell,j}$
\end_inset

 preserves finite connected limits, or equivalently, 
\begin_inset Formula 
\[
H_{\ell,j}(\lim d,x)\rightarrow\int_{i}H_{\ell,j}(d_{i},O_{\ell}(p_{i})(x))
\]

\end_inset

is an isomorphism.
\end_layout

\begin_layout Proof
Let us take the example of type application and show that it preserves pullbacks.
 Consider a pullback
\begin_inset Formula 
\[
\xymatrix{n_{0};\Gamma_{0}\vdash\tau_{0}\ar[r]^{(u_{1},v_{1})}\ar[d]_{(u_{2},v_{2})} & n_{1};\Gamma_{1}\vdash\tau_{1}\ar[d]^{(f_{1},g_{1})}\\
n_{2};\Gamma_{2}\vdash\tau_{2}\ar[r]_{(f_{2},g_{2})} & n_{3};\Gamma_{3}\vdash\tau_{3}
}
\]

\end_inset

Let us take 
\begin_inset Formula $x=A_{\sigma_{1},\sigma_{2}}$
\end_inset

, so that 
\begin_inset Formula $\tau_{0}=\sigma_{1}[\sigma_{2}]$
\end_inset

.
 Then, 
\begin_inset Formula $L_{\lim d,x,0}=n_{0};\Gamma_{0}\vdash\Lambda\sigma_{1}$
\end_inset

.
 We need to check that the following square is a pullback
\begin_inset Formula 
\[
\xymatrix{n_{0};\Gamma_{0}\vdash\Lambda\sigma_{1}\ar[r]^{(u_{1},v_{1})}\ar[d]_{(u_{2},v_{2})} & n_{1};\Gamma_{1}\vdash\Lambda\sigma_{1}[u_{1}]\ar[d]^{(f_{1},g_{1})}\\
n_{2};\Gamma_{2}\vdash\Lambda\sigma_{1}[u_{2}]\ar[r]_{(f_{2},g_{2})} & n_{3};\Gamma_{3}\vdash\Lambda\sigma_{1}[u_{1}][f_{1}]
}
\]

\end_inset

This is easy.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We need to consider something like 
\begin_inset Formula $\Set$
\end_inset

, but restricted to a full subcategory embedding so that the Yoneda embedding
 preserve finite connected limits.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Mais en raisonnant sur 
\begin_inset Formula $\Set$
\end_inset

, je ne epu pas considerer la monade T' (cf main)...
 Je pourrais travailler sur 
\begin_inset Formula $\Set$
\end_inset

 ou mieux, sur les ensembles nominaux tiens, comme ca tout le monde preserve
 les pushouts.
 Mais est-ce que c'est skew monoidal, bof c'est pas si grave?
\end_layout

\begin_layout Plain Layout
Mais est -ce que ca fait bien la moande des termes.
 Bof on peut la definir a la main.
 Mais comment on sait que c'est une monade? Ca se voit a la main.
 Ah mais non c'est une moande libre comme le fait remarquer le gars la Ah
 mais attend, les coproduits d'ensembles nominaux c'est complique non? Bah
 non en fait.
 J'ai quand meme besoin que 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "biblio,bib"
options "splncs04"

\end_inset

 
\end_layout

\end_body
\end_document
