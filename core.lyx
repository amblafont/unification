#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass jfp
\begin_preamble
\input{common-preamble}
\end_preamble
\use_default_options false
\begin_modules
enumitem
\end_modules
\maintain_unincluded_children false
\begin_local_layout
#\DeclareLyXModule{Other}
#DescriptionBegin
#Defines Notation
#DescriptionEnd
#Category: theorems

Format 66

Requires    amsmath

# acmart document class includes amssymb
Provides amssymb 1

# The environments defined (regular and starred) are :
# - Property

Style Notation
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             notation
    LabelString           "Notation \thethm."
    Preamble
\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{notation}[theorem]{Notation}}
    EndPreamble
End

Style Remark
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             remark
    LabelString           "Remark \thethm."
    Preamble
\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{remark}[theorem]{Remark}}
    EndPreamble
End

Style Property
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             property
    LabelString           "Property \thethm."
    Preamble
\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{property}[theorem]{Property}}
    EndPreamble
End


Style "Personal Question"
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             personalquestion
    LabelString           "Personal Question \thethm."
    Preamble
      %\newenvironment{personalquestion}{\shortfull{\comment}{\begin{question}\color{red}(personal)}}{\shortfull{\endcomment}{\end{question}}}
      \newenvironment{personalquestion}{\comment}{\endcomment}
    EndPreamble
End


Style "Long Proof"
    CopyStyle             Proof
    DependsOn               Proof
    LatexName             longproof
    LabelString           "Long proof."
    Preamble
      \newenvironment{longproof}{\shortfull{\comment}{\begin{proof}}}{\shortfull{\endcomment}{\end{proof}}}
    EndPreamble
End

Style "Appendix"
    CopyStyle             Section
    DependsOn               Section
    LatexName             secappendix
    LabelString           "Appendix"
    Preamble
    EndPreamble
End
\end_local_layout
\language british
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style ACM-Reference-Format
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Abstract
\begin_inset Note Note
status open

\begin_layout Plain Layout
In a Lawvere theory freely generated by operations, an equaliser diagram
 has a limit as long as it has a cone.
 As it is well-known, this translates in terms of first-order unification
 as the existence of a most general unifier as long as there exists a unifier.
 Generalising the so-called pattern fragment of second-order unification
 identified by Miller, we propose an extension of this result for a class
 of non-free Lawvere theories generated by a new notion of signature in
 order to capture syntax with variable binding and metavariables, including
 simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus, (intrinsic) System F, ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\end_inset

 
\end_layout

\begin_layout Abstract
We propose a notion of syntax with metavariables that generalises Miller's
 decidable 
\emph on
pattern 
\emph default
fragment of second-order unification for simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 Using categorical semantics, we show that, under some conditions, a generalisat
ion of Miller's unification algorithm applies.
 To illustrate our semantic analysis, we implemented our generic unification
 algorithm implemented in Agda.
 The syntax with metavariables given as input of the algorithm is specified
 by a notion of signature generalising binding signatures, covering a wide
 range of examples, including ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus and (intrinsic) polymorphic syntax such as System F.
 Although we do not explicitly handle equations, we also tackle simply-typed
 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

- and 
\begin_inset Formula $\eta$
\end_inset

-equations (Miller's original setting) by working on the syntax of normal
 forms.
 
\end_layout

\begin_layout Title
Semantics of pattern unification
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\type}{\ \mathrm{type}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Th}[1]{\mathrm{MCon}(#1)}
\end_inset


\begin_inset FormulaMacro
\newcommand{\arSep}{\rightarrow}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Thbot}[1]{\mathrm{MCon}(#1)_{\bot}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Fsep}{|}
\end_inset


\begin_inset FormulaMacro
\newcommand{\substofrenamings}[1]{\overline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lamrenaming}[1]{#1\uparrow}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lamsubst}[2]{#1\uparrow^{#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\wk}[1]{\textrm{wk }#1}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\catbot}[1]{#1_{\bot}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\rename}[2]{#1\{#2\}}
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset FormulaMacro
\newcommand{\nar}[1]{\kappa_{#1}}
\end_inset


\end_layout

\end_inset


\begin_inset FormulaMacro
\newcommand{\ntharvec}[1]{\alpha_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\indexedO}{{\cal O}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Oby}[1]{\indexedO_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Oop}[2]{\Oby{#1}(#2)}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\ntharvecaction}[3]{#2_{#3}^{#1}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\ntharvecfunct}{\ntharvec{}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\nthar}[2]{\overline{#1}_{#2}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\nthaarvec}[1]{\alpha'_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\nthaarvecfunct}{\nthaarvec{}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\nthaar}[2]{\alpha'_{#1,#2}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Inj}{\mathrm{Inj}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\veciflyx}[2]{\vecif{#1}{#2}}
{\vec{#2}_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\var}[1]{#1}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lcvar}[1]{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\dotmcontext}[1]{\boldsymbol{#1}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\refruletwo}[2]{\hyperlink{#2}{\textsc{#1}}}
{\underline{\textsc{#1}}(\textsc{#2})}
\end_inset


\begin_inset FormulaMacro
\newcommand{\refrule}[1]{\refruletwo{#1}{#1}}
{\underline{\textsc{#1}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\maybold}[1]{#1}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\refULrule}[1]{\refruletwo{U\ensuremath{\Lambda}-#1}{UL-#1}}
\end_inset


\begin_inset Formula $\newcommand{\niton}{\not\owns}$
\end_inset


\begin_inset FormulaMacro
\newcommand{\refPLrule}[1]{\refruletwo{P\ensuremath{\Lambda}-#1}{PL-#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\labelrule}[2]{\hypertarget{#2}{#1}}
{#1(\textsc{#2})}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\highlighted}[1]{\texHighlighted{\ensuremath{#1}}}
{{\color{blue}#1}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset FormulaMacro
\newcommand{\HighlightedAgdaFunction}[1]{\texHighlightedFunction{\#1}}
{\highlighted{\textrm{#1}}}
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\labelruletwo}[3]{\labelrule{#1\textsc{#2}}{#3}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\labelULrule}[2]{\labelruletwo{#1}{U\ensuremath{\Lambda}-#2}{UL-#2}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\labelPLrule}[2]{\labelruletwo{#1}{P\ensuremath{\Lambda}-#2}{PL-#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\labellabelrule}[2]{\labelruletwo{#1}{#2}{#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kl}[1]{Kl_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\arg}[1]{#1}
{#1}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Eil}[1]{#1\text{-alg}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\something}[1]{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\prunecat}[5]{\vdash_{#5}#1\boldsymbol{:>}#2\Rightarrow#4;#3}
\end_inset


\begin_inset FormulaMacro
\newcommand{\prune}[4]{\prunecat{#1}{#2}{#3}{#4}{}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\B}{\mathscr{B}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\D}{\mathscr{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\C}{\mathscr{C}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\colim}{\mathrm{colim}\ }
\end_inset


\begin_inset FormulaMacro
\newcommand{\Set}{\mathrm{Set}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\FinSet}{\mathrm{FinSet}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Nom}{\mathrm{Nom}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KlD}{\Kl{\D^{+}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\op}[1]{#1^{op}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bang}{\oc}
{!}
\end_inset


\begin_inset FormulaMacro
\newcommand{\none}{\bang}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationtopconcl}{\bot\vdash\vec{t}=\vec{u}\Rightarrow\bang\dashv\bot}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationtop}{\dfrac{}{\unificationtopconcl}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationemptyconcl}{\Gamma\vdash()=()\Rightarrow1_{\Gamma}\dashv\Gamma}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationempty}{\dfrac{}{\unificationemptyconcl}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationstepwisenovec}{\inferruletwo{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{t_{2}}\Rightarrow\sigma\dashv\Delta}{\Delta\vdash\delta_{1}[\text{\ensuremath{\sigma]}}=\delta_{2}[\text{\ensuremath{\sigma]}}\Rightarrow\sigma'\dashv\Delta'}{\Gamma\vdash\veciflyx{}{t_{1}},\delta_{1}=t_{2},\delta_{2}\Rightarrow\sigma[\sigma']\dashv\Delta'}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset FormulaMacro
\newcommand{\unificationstepwisenolabel}[1]{\inferruletwo{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{t_{2}}\Rightarrow\sigma\dashv\Delta}{\Delta\vdash\veciflyx{#1}{\delta_{1}}[\text{\ensuremath{\sigma_{1}]}}=\veciflyx{#1}{\delta_{2}}[\text{\ensuremath{\sigma_{1}]}}\Rightarrow\sigma'\dashv\Delta'}{\Gamma\vdash\veciflyx{}{t_{1}},\veciflyx{#1}{\delta_{1}}=\veciflyx{}{t_{2}},\veciflyx{#1}{\delta_{2}}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta'}}
{\dfrac{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{u_{1}}\Rightarrow\sigma_{1}\dashv\Delta_{1}\quad\Delta_{1}\vdash\veciflyx{#1}{t_{2}}[\text{\ensuremath{\sigma_{1}]}}=\veciflyx{#1}{u_{2}}[\text{\ensuremath{\sigma_{1}]}}\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash\veciflyx{}{t_{1}},\veciflyx{#1}{t_{2}}=\veciflyx{}{u_{1}},\veciflyx{#1}{u_{2}}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}}
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationstepwisenolabel}[1]{\inferruletwo{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{u_{1}}\Rightarrow\sigma_{1}\dashv\Delta_{1}}{\Delta_{1}\vdash\veciflyx{#1}{t_{2}}[\text{\ensuremath{\sigma_{1}]}}=\veciflyx{#1}{u_{2}}[\text{\ensuremath{\sigma_{1}]}}\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash\veciflyx{}{t_{1}},\veciflyx{#1}{t_{2}}=\veciflyx{}{u_{1}},\veciflyx{#1}{u_{2}}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}}
{\dfrac{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{u_{1}}\Rightarrow\sigma_{1}\dashv\Delta_{1}\quad\Delta_{1}\vdash\veciflyx{#1}{t_{2}}[\text{\ensuremath{\sigma_{1}]}}=\veciflyx{#1}{u_{2}}[\text{\ensuremath{\sigma_{1}]}}\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash\veciflyx{}{t_{1}},\veciflyx{#1}{t_{2}}=\veciflyx{}{u_{1}},\veciflyx{#1}{u_{2}}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationstepwise}[1]{\unificationstepwisenolabel{#1}\textsc{U-Split}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationrigrignolabel}{\dfrac{\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash o(\vec{t})=o(\vec{u})\Rightarrow\sigma\dashv\Delta}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationrigrigneqo}{\dfrac{o\neq o'}{\Gamma\vdash o(\vec{t})=o'(\vec{u})\Rightarrow\bang\dashv\bot}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\pruningemptyconcl}{\Gamma\prune{()}{()}{1_{\Gamma}}{()}\dashv\Gamma}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pruningempty}{\dfrac{}{\pruningemptyconcl}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{keywords}Unification, Category theory, Syntax 
\backslash
end{keywords}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Unification deals with languages with 
\emph on
metavariables
\emph default
.
 Let us assume that a language with metavariables comes with a well-formedness
 judgement of the shape 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, meaning that the term 
\begin_inset Formula $t$
\end_inset

 is well-formed in the 
\emph on
metavariable context 
\emph default

\begin_inset Formula $\Gamma$
\end_inset

 and the
\emph on
 scope 
\begin_inset Formula $a$
\end_inset

.
 
\emph default
What we call a scope depends on the language of interest: for a De Bruijn-encode
d untyped syntax, it would be a mere natural number; for a simply-typed
 syntax, it would be a pair of a list of types 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and a type 
\begin_inset Formula $\tau$
\end_inset

 to mean that 
\begin_inset Formula $t$
\end_inset

 has type 
\begin_inset Formula $a$
\end_inset

 in the base context 
\begin_inset Formula $\vec{\sigma}$
\end_inset

.
 A 
\emph on
metavariable context,
\emph default
 or 
\emph on
metacontext
\emph default
, is typically a list of metavariable symbols with their associated 
\emph on
arities
\emph default
.
 Metacontexts should form a category whose morphisms are called 
\emph on
metavariable substitutions
\emph default
 or 
\emph on
metasubstitution
\emph default
.
 A metasubstitution 
\begin_inset Formula $\sigma$
\end_inset

 between 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Delta$
\end_inset

 should also induce a mapping 
\begin_inset Formula $t\mapsto t[\sigma]$
\end_inset

 sending terms well-formed in the metacontext 
\begin_inset Formula $\Gamma$
\end_inset

 and scope 
\begin_inset Formula $a$
\end_inset

 to terms well-formed in the metacontext 
\begin_inset Formula $\Delta$
\end_inset

 and same scope 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
In this situation, a unification problem is specified by a pair of terms
 
\begin_inset Formula $(t_{1},t_{2})$
\end_inset

 such that 
\begin_inset Formula $\Gamma;a\vdash t_{i}$
\end_inset

 for 
\begin_inset Formula $i\in\{1,2\}$
\end_inset

.
 A unifier for this pair is a metasubstitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 such that 
\begin_inset Formula $t_{1}[\sigma]=t_{2}[\sigma]$
\end_inset

, and a most general unifier (abbreviated as mgu) is a unifier 
\begin_inset Formula $\sigma$
\end_inset

 such that given any other unifier 
\begin_inset Formula $\delta$
\end_inset

, there exists a unique 
\begin_inset Formula $\sigma'$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma'\circ\sigma$
\end_inset

.
\end_layout

\begin_layout Paragraph
Example: first-order/second-order/pattern unification for an untyped syntax
\end_layout

\begin_layout Standard
Let us illustrate different standard versions of unification, starting from
 the example of a de Bruijn-encoded untyped syntax specified by a binding
 signature
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "aczel2016general"
literal "false"

\end_inset

.
 We take scopes and also metavariable arities to be natural numbers.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The well-formedness judgement is of the shape 
\begin_inset Formula $\Gamma;n\vdash t$
\end_inset

, where 
\begin_inset Formula $t$
\end_inset

 is a term, 
\begin_inset Formula $n$
\end_inset

 is a
\emph on
 scope, 
\emph default
that is, a natural number indicating the number of available free variables
 in 
\begin_inset Formula $t$
\end_inset

, and 
\begin_inset Formula $\Gamma$
\end_inset

 is a 
\emph on
metavariable context
\emph default
, or 
\emph on
metacontext.
 
\emph default
That is,
\emph on
 
\emph default

\begin_inset Formula $\Gamma$
\end_inset

 is a list of distinct metavariable symbols with their associated scopes
\end_layout

\end_inset

 We can define three variants of unification by adding one of the following
 introduction rules for metavariables.
\begin_inset Formula 
\[
\begin{array}{ccccc}
 &  & \text{First-order} & \text{Second-order} & \text{Pattern}\\
\forall(M:m)\in\Gamma &  & \labelrule{\dfrac{n=m}{\Gamma;n\vdash M}\textsc{Fo}}{Fo} & \labellabelrule{\dfrac{\Gamma;n\vdash t_{1}\ \dots\ \Gamma;n\vdash t_{m}}{\Gamma;n\vdash M(\vec{t})}}{So} & \labellabelrule{\dfrac{\overbrace{\Gamma;n\vdash t_{1}\ \dots\ \Gamma;n\vdash t_{m}}^{\mathclap{(t_{1},\dots,t_{m})\text{ = list of distinct variables}}}}{\Gamma;n\vdash M(\vec{t})}}{Pat}
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Note that first-order unification is enough to solve unification problems
 where metavariables are introduced according to the rule 
\begin_inset Formula $\refrule{Fo}$
\end_inset

, even without the restriction that 
\begin_inset Formula $n=0$
\end_inset

.
 Let us take the example of (untyped) pure lambda-calculus: through it is
 the typical example of a mono-sortedsyntax with binders, it can alternatively
 be presented as a multisorted first-order syntax, where the sorts are the
 natural numbers.
 The syntax is generated by the following operations, for each sort 
\begin_inset Formula $n$
\end_inset

: 
\end_layout

\begin_layout Itemize
n constants of that sort (the variables);
\end_layout

\begin_layout Itemize
a binary operation 
\begin_inset Formula $n\times n\rightarrow n$
\end_inset

 (application); 
\end_layout

\begin_layout Itemize
a unary operation 
\begin_inset Formula $n+1\rightarrow n$
\end_inset

 (lambda-abstraction).
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The third 
\emph on
pattern 
\emph default
variant in the rules above was introduced by 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:journals/logcom/Miller91"
literal "true"

\end_inset

 as a decidable fragment of second-order unification (for simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

- and 
\begin_inset Formula $\eta$
\end_inset

-equations): contrary to the latter case, a metavariable can only be applied
 to a 
\emph on
pattern
\emph default
, that is, to a list of distinct variables.
\end_layout

\begin_layout Standard
In all of these situations, a 
\emph on
metasubstitution 
\emph default

\begin_inset Formula $\sigma$
\end_inset

 between two metacontexts 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Delta$
\end_inset

 is defined the same way: it maps each metavariable declaration 
\begin_inset Formula $M:m$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

 to a term 
\begin_inset Formula $\Delta;m\vdash\sigma_{M}$
\end_inset

.
 Given a term 
\begin_inset Formula $\Gamma;n\vdash t$
\end_inset

 we define by recursion the substituted term 
\begin_inset Formula $\Delta;n\vdash t[\sigma]$
\end_inset

.
 Then, composition of metasubstitutions is defined by 
\begin_inset Formula $(\sigma\circ\delta)_{M}=\delta_{M}[\sigma]$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Now, a unification problem consists of a pair of terms 
\begin_inset Formula $\Gamma;n\vdash t,u$
\end_inset

.
 A unifier is a metasubstitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

, and a most general unifier (abbreviated as mgu) is a unifier 
\begin_inset Formula $\sigma$
\end_inset

 such that given any other unifier 
\begin_inset Formula $\delta$
\end_inset

, there exists a unique 
\begin_inset Formula $\sigma'$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma'\circ\sigma$
\end_inset

.
\end_layout

\begin_layout Plain Layout
a most general 
\emph on
instantiation
\emph default
 (of the metavariables therein) that makes the two terms equal.
\end_layout

\begin_layout Plain Layout
and a notion of instantiation, determining which data is necessary to substitute
 a metavariable.
 Given two terms, the goal is to find a 
\emph on
most general unifier
\emph default
, that is, Pattern unification is an intermediate variant, introduced by
 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:journals/logcom/Miller91"
literal "true"

\end_inset

 as a decidable fragment of second-order unification.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
First contribution: a class of languages with metavariables
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, so that we get three categories
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
These categories induce multi-sorted Lawvere theories.
 Conversely, from any Lawvere theory, we can recover an enriched syntax.
\begin_inset Note Note
status open

\begin_layout Plain Layout
a well-formedness judgement and corresponding sets of enriched terms.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 of metacontexts and substitutions (one for each variant).
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
It is well-known that unification can be formulated categorically
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Goguen89whatis"
literal "true"

\end_inset

.
 Let us make this formulation explicit for our three categories of substitutions.
 The set of terms in the environment 
\begin_inset Formula $\Gamma;n$
\end_inset

 is recovered as the set of morphisms from the singleton metacontext 
\begin_inset Formula $(N:n)$
\end_inset

 to 
\begin_inset Formula $\Gamma$
\end_inset

.
 With this in mind, a unifier of two terms 
\begin_inset Formula $\Gamma;n\vdash t,u$
\end_inset

 can be interpreted as a cocone, that is, a morphism 
\begin_inset Formula $\Gamma\rightarrow\Delta$
\end_inset

 such that its composition with either of the two terms (interpreted as
 morphisms) are equal.
 The mgu is characterised as the coequaliser.
 Note that unification also makes sense for finite families of pairs of
 terms 
\begin_inset Formula $(\Gamma;n_{i}\vdash t_{i},u_{i})_{i\in\{1,\dots,p\}}$
\end_inset

; we get a similar categorical formulation by interpreting 
\begin_inset Formula $\vec{t}$
\end_inset

 and 
\begin_inset Formula $\vec{u}$
\end_inset

 as two parallel morphisms from 
\begin_inset Formula $(N_{1}:n_{1},\dots,N_{p}:n_{p})$
\end_inset

 to 
\begin_inset Formula $\Gamma$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our first contribution is a class of languages with
\emph on
 
\emph default
metavariables.
 Such a language is specified by the following data: 
\end_layout

\begin_layout Itemize
a small category 
\begin_inset Formula ${\cal A}$
\end_inset

 of 
\emph on
scopes 
\emph default
(or 
\emph on
metavariable arities)
\begin_inset Foot
status open

\begin_layout Plain Layout
The fact that the notions of scopes and metavariable arities coincide (as
 in the previous example) allows us to see terms as substitutions and mgus
 as coequalisers, as we will see.
 This is not the case in Vezzosi-Abel's presentation of Miller's original
 setting 
\begin_inset CommandInset citation
LatexCommand citep
key "vezzosi2014categorical"
literal "true"

\end_inset

.
\end_layout

\end_inset

, 
\emph default
and 
\emph on
renamings 
\emph default
between them,
\end_layout

\begin_layout Itemize
an endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 of the shape 
\begin_inset Formula $F(X)_{a}=\coprod_{n\in\mathbb{N}}\coprod_{o\in\Oop na}X_{\nthar o1}\times\dots\times X_{\nthar on}$
\end_inset

, where 
\begin_inset Formula $\Oop na$
\end_inset

 is intuitively the set of 
\begin_inset Formula $n$
\end_inset

-ary available operation symbols in the scope 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
The base syntax (in the empty metacontext) is generated by the following
 single rule.
\begin_inset Formula 
\[
\forall o\in\Oop na\dfrac{\nthar o1\vdash t_{1}\quad\dots\quad\nthar on\vdash t_{n}}{a\vdash o(t_{1},\dots,t_{n})}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Typed syntaxes with typing judgements of the shape 
\begin_inset Formula $C\vdash t:\tau$
\end_inset

 can be accounted by merging the context 
\begin_inset Formula $C$
\end_inset

 and the type 
\begin_inset Formula $\tau$
\end_inset

 into a single scope 
\begin_inset Formula $\vec{\sigma}\rightarrow\tau$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This rule accounts for (possibly simply-typed) binding arities
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "aczel2016general,FioreHur"
literal "false"

\end_inset

 but not only.
 In particular, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 we handle the syntax of normalised 
\begin_inset Formula $\lambda$
\end_inset

-terms, which cannot be specified by a binding signature.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Note that even in the case where scopes are natural numbers, this rule goes
 beyond what is possible to specify with binding arities
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "aczel2016general"
literal "false"

\end_inset

.
 The same remark applies for the simply-typed generalisation, and this is
 crucial to handle Miller's original setting of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

-equations (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We now present the full syntax with metavariables.
 Again, a metacontext is a list of metavariable symbols with their associated
 arities (or scopes).
 The syntax is generated by two rules, one for operations, and one for metavaria
bles.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\forall\Gamma\forall o\in\Oop na\dfrac{\Gamma;\nthar o1\vdash t_{1}\quad\dots\quad\Gamma;\nthar on\vdash t_{n}}{\Gamma;a\vdash o(t_{1},\dots,t_{n})}\qquad\dfrac{M:m\in\Gamma\quad x\in\hom_{{\cal A}}(m,n)}{\Gamma;n\vdash M(x)}
\]

\end_inset

Let us explain how the right rule instantiates to the above metavariable
 introduction rule 
\begin_inset Formula $\refrule{Pat}$
\end_inset

 for pattern unification.
 A list of distinct variables 
\begin_inset Formula $(x_{1},\dots,x_{m})$
\end_inset

 in the scope 
\begin_inset Formula $n$
\end_inset

 is equivalently given by an injective map from 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

 to 
\begin_inset Formula $\{1,\dots,m\}$
\end_inset

.
 Therefore, by taking for 
\begin_inset Formula ${\cal A}$
\end_inset

 the category 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 whose objects are natural numbers and whose morphisms from 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $m$
\end_inset

 consist of injective maps as above, we recover the above  
\begin_inset Formula $\refrule{Pat}$
\end_inset

.
 Note that contrary to the traditional definition of pattern unification,
 where the notion of 
\emph on
pattern 
\emph default
is derived from the notion of variable, in our setting, patterns are built-in
 (they are morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

) and there is no built-in notion of 
\begin_inset Quotes eld
\end_inset

variables
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
We can also recover the above metavariable rule 
\begin_inset Formula $\refrule{Fo}$
\end_inset

 by taking for 
\begin_inset Formula ${\cal A}$
\end_inset

 the discrete category 
\begin_inset Formula $\mathbb{N}$
\end_inset

 whose objects are natural numbers, because a morphism from 
\begin_inset Formula $m$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

 is nothing but the assertion that 
\begin_inset Formula $m=n$
\end_inset

.
 More generally, our setting allows us to see first-order unification as
 the special case of pattern unification where 
\begin_inset Formula ${\cal A}$
\end_inset

 is a discrete category.
 Let us finally mention that the metavariable introduction rule 
\begin_inset Formula $\refrule{So}$
\end_inset

 for second-order unification does not fit into our format
\begin_inset Foot
status open

\begin_layout Plain Layout
Essentially, this is because our languages come from free monads on presheaf
 categories (
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:free-alg-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

), while this is not the case of second-order unification (see
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:conf/aplas/Hamana04"
literal "false"

\end_inset

 for a description of the corresponding monad).
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Following the path sketched for the introductory example, we can define
 metasubstitutions, their action on terms, and their compositions: unification
 problems can then be stated.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Specification of pattern languages
\end_layout

\begin_layout Plain Layout
Each pattern language is specified by the following data.
\end_layout

\begin_layout Itemize
a small category 
\begin_inset Formula ${\cal A}$
\end_inset

 with equalisers and pullbacks, whose objects are called 
\shape italic
scopes
\emph on
,
\shape default
\emph default
 and whose morphisms, called 
\emph on
patterns
\emph default
, are all monomorphic;
\end_layout

\begin_layout Itemize
for each natural number 
\begin_inset Formula $n$
\end_inset

,
\end_layout

\begin_deeper
\begin_layout Itemize
a functorial assignment 
\begin_inset Formula $\Oop n-$
\end_inset

 mapping a scope 
\begin_inset Formula $a$
\end_inset

 to the set of operation symbols available in the context 
\begin_inset Formula $a$
\end_inset

;
\end_layout

\begin_layout Itemize
a functorial assignment 
\begin_inset Formula $\alpha$
\end_inset

 mapping
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:GB-signature"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for a formal definition, involving the construction of a category of elements.
\end_layout

\end_inset

 a scope 
\begin_inset Formula $a$
\end_inset

 and an operation symbol 
\begin_inset Formula $o\in\Oop na$
\end_inset

 to a the list of 
\emph on
input scopes
\emph default
 
\begin_inset Formula $\ntharvec o=(\nthar o1,\dots,\nthar on)$
\end_inset

;
\end_layout

\begin_layout Itemize
such that 
\begin_inset Formula $\Oop n-$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

 preserve equalisers and pullbacks.
\end_layout

\end_deeper
\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The enriched syntax is functorial with respect to the category of renamings
 – we define 
\begin_inset Formula $M(x)\{f\}$
\end_inset

 as 
\begin_inset Formula $M(f\circ x)$
\end_inset

 – and is moreover functorial with respect to metasubstitutions.
 Here, a metasubstitution 
\begin_inset Formula $\sigma$
\end_inset

 between two metacontexts 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Gamma'$
\end_inset

 assigns to each metavariable declaration 
\begin_inset Formula $M:m$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

 a term 
\begin_inset Formula $\Delta;m\vdash\sigma_{M}$
\end_inset

 .
 Then, given 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, the substituted term 
\begin_inset Formula $\Delta;a\vdash t[\sigma]$
\end_inset

 is defined by recursion on the structure of 
\begin_inset Formula $t$
\end_inset

.
 metasubstitutions compose and are morphisms in a category whose objects
 are scopes.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Category of metacontexts and substitutions
\end_layout

\begin_layout Plain Layout
The category of metacontexts and substitutions can be described either starting
 from the syntax or directly from the data generating the syntax.
 We start with the latter.
 Let 
\begin_inset Formula $T$
\end_inset

 be the free monad generated the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

.
 To each metacontext 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

 we can associate a functor 
\begin_inset Formula $\underline{\Gamma}:{\cal A}\rightarrow\Set$
\end_inset

 defined by 
\begin_inset Formula $ym_{1}+\dots+ym_{p}$
\end_inset

 where 
\begin_inset Formula $y$
\end_inset

 is the Yoneda embedding.
 A morphism from 
\begin_inset Formula $\Gamma$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

 is a Kleisli morphism 
\begin_inset Formula $\underline{\Gamma}\rightarrow T\underline{\Delta}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Scope of our class of languages
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Our class of languages obviously includes the case of the syntax of normalised
 simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-terms, detailed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

, and taken as a starting point by Vezzosi-Abel.
 Indeed, replacing an applied variable with a 
\begin_inset Formula $\lambda$
\end_inset

-abstracted term does not yield a normal form.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Typed syntaxes with typing judgements of the shape 
\begin_inset Formula $\Delta\vdash t:\tau$
\end_inset

 can be accounted by We can handle this type system by merging the context
 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and the type 
\begin_inset Formula $\tau$
\end_inset

 into a single entity 
\begin_inset Formula $\vec{\sigma}\rightarrow\tau$
\end_inset

, which we call a scope.
 In other words, in our setting, 
\begin_inset Formula $\Gamma;\vec{\sigma}\vdash t:\tau$
\end_inset

 would be denoted by 
\begin_inset Formula $\Gamma;\vec{\sigma}\rightarrow\tau\vdash t$
\end_inset

, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for more details.
\end_layout

\end_inset

We account for any syntax specified by a multi-sorted binding signature
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "FioreHur"
literal "false"

\end_inset

: we detail the example of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus (without 
\begin_inset Formula $\beta$
\end_inset

- and 
\begin_inset Formula $\eta$
\end_inset

-equations) in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Note that our framework handles typed settings in such a way that knowing
 that 
\begin_inset Formula $M(\vec{x})$
\end_inset

 and 
\begin_inset Formula $M(\vec{y})$
\end_inset

 are well-formed in the same metacontext and scope is enough to conclude
 that the types of 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

 are the same.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The previous description recovers the standard introduction rule 
\begin_inset Formula $\refrule{Pat}$
\end_inset

 but we can equally account for the following variant by restricting to
 monotone renamings.
\begin_inset Formula 
\[
\forall M:m\in\Gamma,\qquad\dfrac{\text{\ensuremath{X} is a \ensuremath{m}-sized set of distinct variables in scope \ensuremath{n}}}{\Gamma;n\vdash M(X)}
\]

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{app_{n}}=(n,n)$
\end_inset

 and 
\begin_inset Formula $\alpha_{abs_{n}}=(n+1)$
\end_inset

.
 Following Vezzosi-Abel's analysis, a pattern, as a morphism between scopes,
 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 is defined as an injective map from 
\begin_inset Formula $\{\underline{1},\dots,\underline{n}\}$
\end_inset

 and 
\begin_inset Formula $\{1,\dots,m\}$
\end_inset

.
 Let us describe functoriality: given a pattern 
\begin_inset Formula $f:n\rightarrow m$
\end_inset

, we define 
\begin_inset Formula $i\{f\}=\underline{f(i)}$
\end_inset

, 
\begin_inset Formula $abs_{n}\{f\}=abs_{m}$
\end_inset

, and 
\begin_inset Formula $app_{n}\{f\}=app_{m}$
\end_inset

.
 Functoriality of 
\begin_inset Formula $\alpha$
\end_inset

 requires us to provide a multi-morphism between 
\begin_inset Formula $\alpha_{app_{n}}=(n,n)$
\end_inset

 and 
\begin_inset Formula $\alpha_{app_{n}\{f\}}=(m,m)$
\end_inset

, that is, two morphisms from 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $m$
\end_inset

: we just pick 
\begin_inset Formula $f$
\end_inset

.
 Similarly, we need to provide a multimorphism between 
\begin_inset Formula $\alpha_{abs_{n}}=(n+1)$
\end_inset

 and 
\begin_inset Formula $\alpha_{abs\{f\}}=(m+1)$
\end_inset

, that is, a morphism between 
\begin_inset Formula $n+1$
\end_inset

 and 
\begin_inset Formula $m+1$
\end_inset

: we take the map that coincides with 
\begin_inset Formula $f$
\end_inset

 for 
\begin_inset Formula $i\leq n$
\end_inset

 and map 
\begin_inset Formula $n+1$
\end_inset

 to 
\begin_inset Formula $m+1$
\end_inset

.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We have not yet defined the morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

.
 Following Vezzosi-Abel's analysis, a pattern, as a morphism between scopes,
 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 is defined as an injective map from 
\begin_inset Formula $\{\underline{1},\dots,\underline{n}\}$
\end_inset

 and 
\begin_inset Formula $\{1,\dots,m\}$
\end_inset

.
\end_layout

\end_inset

This alternative is not specific to pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus but are equally possible for any multi-sorted binding signature.
 
\end_layout

\end_inset

As already said, our notion of language is more expressive than binding
 signatures: we mentioned in particular the syntax of normal forms for simply-ty
ped 
\begin_inset Formula $\lambda$
\end_inset

-calculus (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

), which allows us to cover Miller's original setting.
 Our class also includes languages where terms bind type variables such
 as system F (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

): the scopes then include information about the available type variables.
 In another direction, we can handle certain kind of constraints on the
 variables in the context: in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ordered-calculus"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we treat the calculus for ordered linear logic described by 
\begin_inset CommandInset citation
LatexCommand cite
key "Polakow00lfm"
literal "false"

\end_inset

: their notion of context consists of two components, one of which includes
 variables that must occur exactly once and in the same order as they occur
 in that context.
\end_layout

\begin_layout Standard
All the examples are summarised in Tables
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:all-syntax"
plural "true"
caps "true"
noprefix "false"

\end_inset

 and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:GB-sig-systemF"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:applications"
plural "false"
caps "true"
noprefix "false"

\end_inset

, where the traditional presentation of each calculus is translated into
 our notion of specification.
\end_layout

\begin_layout Standard
Let us finally mention that fully dependently typed languages, where types
 can depend on terms, are not supported.
 Indeed, intuitively, in our notion of specification, types are specified
 through the set of scopes, which must be given independantly and prior
 to the endofunctor of terms: this sequential splitting is not possible
 with dependent types.
\end_layout

\begin_layout Subsection*
Second contribution: a unification algorithm for 
\emph on
pattern-friendly 
\emph default
languages
\end_layout

\begin_layout Standard
Our second key contribution consists of working out some conditions ensuring
 that the main contributions of Miller's work generalise: given two terms
 
\begin_inset Formula $\Gamma;a\vdash t,u$
\end_inset

, either their mgu exists, or there is no unifier, and the proof of this
 statement consists in a recursive procedure (much similar to Miller's original
 algorithm) which computes a mgu or detects the absence of any unifier.
 
\end_layout

\begin_layout Standard
Those conditions are essentially that renamings are monomorphic, and 
\begin_inset Formula ${\cal A}$
\end_inset

 has equalisers and pullbacks, and some additional properties about the
 functor 
\begin_inset Formula $F$
\end_inset

 related to those limits (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:pattern-friendly"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We call one of our languages 
\emph on
pattern-friendly
\emph default
 when it satisfies those properties.
 All the examples that we already mentioned are pattern-friendly, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:applications"
plural "false"
caps "true"
noprefix "false"

\end_inset

 more details.
\end_layout

\begin_layout Paragraph
Agda implementation
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The main feature of pattern unification that holds for our pattern-friendly
 languages is that either the mgu exists, or there is no unifier.
 Moreover, there is a recursive procedure which computes the mgu or detects
 the impossibility of unification.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We implemented our generic unification algorithm (without mechanisation
 of the correctness proof) in Agda.
 We show the most important parts; the interested reader can find the full
 implementation in the supplemental material.
 We used Agda as a programming language rather than a theorem prover.
 In particular, we did not enforce all the invariants in the definition
 of the data structures (e.g., associativity of composition in the category
 of scopes): the user has to check by himself that the input data is valid
 for the algorithm to produce valid outputs.
 Furthermore, we disable the termination checker and provide instead a terminati
on proof on paper in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:termination"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Dependent types were helpful in structuring the implementation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us mention that we use a small trick to avoid the traditional presentation
 of unification as a partial algorithm computing mgus: we add a formal error
 metacontext 
\begin_inset Formula $\bot$
\end_inset

 and a single formal error term 
\begin_inset Formula $\bot;a\vdash\bang$
\end_inset

 for all scopes 
\begin_inset Formula $a$
\end_inset

, so that we get a unique metasubstitution 
\begin_inset Formula $!_{\Gamma}$
\end_inset

 from any metacontext 
\begin_inset Formula $\Gamma$
\end_inset

 to 
\begin_inset Formula $\bot$
\end_inset

.
 This substitution obviously unifies any pair of terms.
 If two terms are not unifiable in the traditional sense, 
\begin_inset Formula $!$
\end_inset

 is the mgu.
 If 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 is the mgu in the traditional sense, then it is still the mgu in this extended
 setting, because 
\begin_inset Formula $!_{\Gamma}$
\end_inset

 uniquely factors as 
\begin_inset Formula $\bang_{\Delta}\circ\sigma$
\end_inset

.
 In this way, unification can be seen as a total algorithm that always computes
 the mgu.
\end_layout

\begin_layout Subsection*
Most general unifiers as coequalisers
\end_layout

\begin_layout Standard
It is well-known that unification can be formulated categorically
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Goguen89whatis"
literal "true"

\end_inset

.
 Let us make this formulation explicit in our setting.
 The set of terms in the metacontext 
\begin_inset Formula $\Gamma$
\end_inset

 and scope 
\begin_inset Formula $a$
\end_inset

 is recovered as the set of morphisms from the singleton metacontext 
\begin_inset Formula $(M:a)$
\end_inset

 to 
\begin_inset Formula $\Gamma$
\end_inset

.
 With this in mind, a unifier of two terms 
\begin_inset Formula $\Gamma;a\vdash t,u$
\end_inset

 can be interpreted as a cocone, that is, as a morphism 
\begin_inset Formula $\Gamma\rightarrow\Delta$
\end_inset

 such that its composition with either of the two terms (interpreted as
 morphisms) are equal.
 A mgu is then a coequaliser: this is the characterisation that we use to
 prove correctness of our unification algorithm.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Note that unification also makes sense for finite families of pairs of terms
 
\begin_inset Formula $(\Gamma;a_{i}\vdash t_{i},u_{i})_{i\in\{1,\dots,p\}}$
\end_inset

; we get a similar categorical formulation by interpreting 
\begin_inset Formula $\vec{t}$
\end_inset

 and 
\begin_inset Formula $\vec{u}$
\end_inset

 as two parallel morphisms from 
\begin_inset Formula $(A_{1}:n_{1},\dots,A_{p}:a_{p})$
\end_inset

 to 
\begin_inset Formula $\Gamma$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us finally mention that given a specification, we provide in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:mcon-kleisli"
plural "false"
caps "true"
noprefix "false"

\end_inset

 a direct characterisation of the category of metacontexts and substitutions
 as a full subcategory of the Kleisli category of the monad 
\begin_inset Formula $T$
\end_inset

 freely generated by the endofunctor 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Subsection*
Motivation
\end_layout

\begin_layout Standard
Let us explain where this work originates from.
 Pattern unification is used in the implementation of various PLs.
 As a concrete example, consider Dunfield-Krishnaswami's type inference
 algorithm for a variant of system F
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:journals/pacmpl/DunfieldK19"
literal "false"

\end_inset

.
 It only involves first-order unification, but simply adding a monomorphic
 type with a binder (for example, a recursive type 𝜇𝑎.𝐴[𝑎]) would require
 pattern unification.
 
\end_layout

\begin_layout Standard
In order to avoid reproving everything for each new type system, pattern
 unification needs to be formulated generically so that it can be used in
 a variety of contexts without modification.
 This is our original motivation for this work.
 To the best of our knowledge, we are the first to give a general definition
 of pattern unification that works for a wide class of languages, in the
 vein of Rydeheard-Burstall's first-order analysis
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

, see the related work in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:related-work"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for more details.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To each metacontext 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

, we associate a functor 
\begin_inset Formula $\underline{\Gamma}:{\cal A}\rightarrow\Set$
\end_inset

 defined by 
\begin_inset Formula $ym_{1}+\dots+ym_{p}$
\end_inset

 where 
\begin_inset Formula $y$
\end_inset

 is the Yoneda embedding.
 A metasubstitution from 
\begin_inset Formula $\Gamma$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

 is a Kleisli morphism 
\begin_inset Formula $\underline{\Gamma}\rightarrow T\underline{\Delta}$
\end_inset

, where 
\begin_inset Formula $T$
\end_inset

 is the free monad generated by the endofunctor 
\begin_inset Formula $F$
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-finitary"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Plan of the paper
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:summary-algo"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we present our generic pattern unification algorithm, parameterised by
 our notion of specification.
 We introduce categorical semantics of pattern unification in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:cat-settings"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We show correctness of the two phases of the unification algorithm in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:coequalising-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Termination and completeness are justified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:termination-completeness"
plural "true"
caps "true"
noprefix "false"

\end_inset

.
 Examples of specifications are given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:applications"
plural "false"
caps "true"
noprefix "false"

\end_inset

, and related work is finally discussed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:related-work"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
before the conclusion, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Conclusion"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset

.
 The appendices can be found in the supplemental material.
\end_layout

\begin_layout Subsection*
General notations
\end_layout

\begin_layout Standard
Given a list 
\begin_inset Formula $\vec{x}=(x_{1},\dots,x_{n})$
\end_inset

 and a list of positions 
\begin_inset Formula $\vec{p}=(p_{1},\dots,p_{m})$
\end_inset

 taken in 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

, we denote 
\begin_inset Formula $(x_{p_{1}},\dots,x_{p_{m}})$
\end_inset

 by 
\begin_inset Formula $x_{\vec{p}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Given a category 
\begin_inset Formula $\B$
\end_inset

, we denote its opposite category by 
\begin_inset Formula $\op{\B}$
\end_inset

.
 If 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are two objects of 
\begin_inset Formula $\B$
\end_inset

, we denote the set of morphisms between 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 by 
\begin_inset Formula $\hom_{\B}(a,b)$
\end_inset

.
 We denote the identity morphism at an object 
\begin_inset Formula $x$
\end_inset

 by 
\begin_inset Formula $1_{x}$
\end_inset

.
 We denote the coproduct of two objects 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 by 
\begin_inset Formula $A+B$
\end_inset

, the coproduct of a family of objects 
\begin_inset Formula $(A_{i})_{i\in I}$
\end_inset

 by 
\begin_inset Formula $\coprod_{i\in I}A_{i}$
\end_inset

, and similarly for morphisms.
 If 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $g:A'\rightarrow B$
\end_inset

, we  denote the induced morphism 
\begin_inset Formula $A+A'\rightarrow B$
\end_inset

 by 
\begin_inset Formula $f,g$
\end_inset

.
 Coproduct injections 
\begin_inset Formula $A_{j}\rightarrow\coprod_{i\in I}A_{i}$
\end_inset

 are typically denoted by 
\begin_inset Formula $in_{j}$
\end_inset

.
 Let 
\begin_inset Formula $T$
\end_inset

 be a monad on a category 
\begin_inset Formula $\B$
\end_inset

.
 We denote its unit by 
\begin_inset Formula $\eta$
\end_inset

, and its Kleisli category by 
\begin_inset Formula $\Kl T$
\end_inset

: the objects are the same as those of 
\begin_inset Formula $\B$
\end_inset

, and a Kleisli morphism from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

 is a morphism 
\begin_inset Formula $A\rightarrow TB$
\end_inset

 in 
\begin_inset Formula $\B$
\end_inset

.
 We denote the Kleisli composition of 
\begin_inset Formula $f:A\rightarrow TB$
\end_inset

 and 
\begin_inset Formula $g:B\rightarrow TC$
\end_inset

 by 
\begin_inset Formula $f[g]:A\rightarrow TC$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
Leftovers from previous intro
\end_layout

\begin_layout Plain Layout
The category of metacontexts of a pattern language, which is always specified
 by a certain monad 
\begin_inset Formula $T$
\end_inset

 on a presheaf category 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

.
 Objects of 
\begin_inset Formula ${\cal A}$
\end_inset

 are called scopes, and a metavariable context is again a lists of metavariable
 symbols with their associated metatypes, which are scopes.
 To each metavariable context 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

 we can associate a functor 
\begin_inset Formula $\underline{\Gamma}:{\cal A}\rightarrow\Set$
\end_inset

 defined by 
\begin_inset Formula $ym_{1}+\dots+ym_{p}$
\end_inset

.
 A morphism from 
\begin_inset Formula $\Gamma$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

 is a Kleisli morphism 
\begin_inset Formula $\underline{\Gamma}\rightarrow T\underline{\Delta}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Let us now describe the syntax: there is again a simple well-formedness
 judgement 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

 where 
\begin_inset Formula $\Gamma$
\end_inset

 is a metacontext, 
\begin_inset Formula $a$
\end_inset

 is a scope, and 
\begin_inset Formula $t$
\end_inset

 is a term.
 Terms of type 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

 are recovered as morphisms from 
\begin_inset Formula $\Gamma$
\end_inset

 to 
\begin_inset Formula $a:A$
\end_inset

, but we can give a more explicit description, exploiting the fact that
 the monad 
\begin_inset Formula $T$
\end_inset

 is freely generated by an endofunctor of the shape 
\begin_inset Formula $F(X)_{a}=\coprod_{n\in\mathbb{N}}\coprod_{o\in\Oop na}X_{\nthar o1}\times\dots\times X_{\nthar on}$
\end_inset

.
 This entails that the syntax is generated by the two following rules:
\begin_inset Formula 
\[
\forall\Gamma\forall o\in\Oop na\dfrac{\Gamma;\nthar o1\vdash t_{1}\quad\dots\quad\Gamma;\nthar on\vdash t_{n}}{\Gamma;a\vdash o(t_{1},\dots,t_{n})}\qquad\dfrac{M:m\in\Gamma\quad x\in\hom_{{\cal A}}(m,a)}{\Gamma;a\vdash M(x)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Let us take the example of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus (without 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

-equation) as a Lawvere theory.
\end_layout

\begin_layout Plain Layout
simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

-equations as a Lawvere theory.
 We take as sorts of the Lawvere theory to be of the shape 
\begin_inset Formula $\vec{\sigma}\rightarrow\tau$
\end_inset

, where 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 is a list of simple types and 
\begin_inset Formula $\tau$
\end_inset

 is a simple type.
 An object is then a finite multiset of such sorts.
 A morphism from 
\begin_inset Formula $\vec{\sigma_{1}}\rightarrow\tau_{1},\dots,\vec{\sigma_{n}}\rightarrow\tau_{n}$
\end_inset

 to 
\begin_inset Formula $\vec{\sigma}\rightarrow\tau$
\end_inset

 is a term of type 
\begin_inset Formula $\tau$
\end_inset

 in the object context 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 declaring the types of the variables, and which can involve metavariables
 of metatypes 
\begin_inset Formula $\sigma_{1}\rightarrow\tau_{i}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
There is a common semantic account of syntax consists in a monad 
\begin_inset Formula $T$
\end_inset

 on a presheaf category 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

.
 This data generates a multi-sorted Lawvere theory by taking the opposite
 of the Kleisli category restricted to finite coproducts of representable
 presheaves.
 First-order unification correspond to discrete categories 
\begin_inset Formula ${\cal A}$
\end_inset

 is discrete and free monads 
\begin_inset Formula $T$
\end_inset

: in this case, the Lawvere theory is freely generated by operations.
\end_layout

\begin_layout Plain Layout
One way to generate a Lawvere theory consists in considering a monad 
\begin_inset Formula $T$
\end_inset

 on a presheaf category 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In higher-order unification, metavariables are functional in the sense that
 they take arguments:
\end_layout

\end_inset

Miller originally introduced pattern unification for 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

-equations.
 It was categorically interpreted by 
\begin_inset CommandInset citation
LatexCommand citet
key "vezzosi2014categorical"
literal "false"

\end_inset

 as computing certain coequalisers in a category of metavariable contexts
 and substitutions.
 In their presentation, they get rid of the 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

-equations by working on the syntax of normalised 
\begin_inset Formula $\lambda$
\end_inset

-terms (which is notably equation free).
 In their conclusion they sketched a track to extend their work for a suitable
 class of languages:
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Instead of [the category of patterns] we can consider a generic category
 
\begin_inset Formula $Ctx$
\end_inset

 having all the pullbacks and equalisers and whose arrows are monomorphisms.
 And instead of the grammar of [normal forms of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus] we can use an arbitrary one defined by a family of operators
 [...] as long as they are functorial with respect to 
\begin_inset Formula $Ctx$
\end_inset

.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
In this work, we focus on 
\emph on
pattern unification
\emph default

\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:journals/logcom/Miller91"
literal "true"

\end_inset


\emph on
, 
\emph default
a decidable fragment of higher-order unification.
 Let us detail how this works for simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

-equations, which was Miller's original setting, following Vezzosi-Abel's
 presentation
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "vezzosi2014categorical"
literal "false"

\end_inset

.
 we can restrict to the equation-free syntax of 
\begin_inset Formula $\beta$
\end_inset

-short 
\begin_inset Formula $\eta$
\end_inset

-long normal forms.
 Adopting the De Bruijn convention to label variables, a base context is
 just a list of simple types, which are inductively constructed construction
 
\begin_inset Formula $\vec{\sigma}\Rightarrow\tau$
\end_inset

 where is a list of simple types, and 
\begin_inset Formula $\tau$
\end_inset

 is a base type.
 The base syntax is then generated by the two following rules.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\sigma_{i}=(\vec{\tau}'\Rightarrow\tau)\quad\vec{\sigma}\vdash\vec{t}:\vec{\tau'}}{\vec{\sigma}\vdash\underline{i}\vec{t}:\tau}\quad\dfrac{\Delta,\tau_{1}\vdash t:\Delta'\Rightarrow\tau_{2}}{\Delta\vdash\lambda t:\tau_{1},\Delta'\Rightarrow\tau_{2}}
\]

\end_inset

Note that the first rule cannot be specified by a 
\emph on
binding arit
\emph default
y, even in the multi-sorted version
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "FioreHur"
literal "false"

\end_inset

 .
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
since variables cannot be syntactically replaced with terms (it could create
 redexes).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us describe the enriched syntax that pattern unification deals with.
 Now, terms can involve metavariables, whose 
\emph on
metatypes 
\emph default
are just types, tracked in a metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

.
 The two previous rules becomes valid in any metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

 and we have a new additional rule to generate metavariables, which can
 only be applied to distinct list of variables
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{M:\Delta\Rightarrow\tau\in\Gamma\qquad\Delta'\vdash\overbrace{\vec{x}}^{\text{distinct variables}}:\Delta}{\Gamma;\Delta'\vdash M(\vec{x}):\tau}
\]

\end_inset

In a term, what can a metavariable apply to depends on its metatype and
 where it occurs exactly.
 
\end_layout

\begin_layout Plain Layout
Unification consists in finding the most general unifier of two terms.
 What does it mean in this setting? First, let us explain what a metasubstitutio
n between two metacontexts 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Gamma'$
\end_inset

 is: it assigns to each metavariable declaration 
\begin_inset Formula $M:\Delta_{M}\Rightarrow\tau_{M}$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

 a term 
\begin_inset Formula $\Gamma';\Delta_{M}\vdash\sigma_{M}:\tau_{M}$
\end_inset

 .
 Then, given 
\begin_inset Formula $\Gamma;\Delta\vdash t$
\end_inset

, the substituted term 
\begin_inset Formula $\Gamma';\Delta\vdash t[\sigma]$
\end_inset

 is defined by recursion on the structure of 
\begin_inset Formula $t$
\end_inset

.
 A unifier of two terms 
\begin_inset Formula $\Gamma;\Delta\vdash t,u$
\end_inset

 is a metasubstitution 
\begin_inset Formula $\sigma$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

.
 A most general unifier (abbreviated as mgu) is a unifier 
\begin_inset Formula $\sigma$
\end_inset

 such that any other unifier 
\begin_inset Formula $\delta$
\end_inset

 uniquely factors as 
\begin_inset Formula $\delta'\circ\sigma$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is especially useful for languages with variable binding, so that metavaria
bles can depend on bound variables.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Consider for example a syntax with object variables and a unary operation
 symbol 
\begin_inset Formula $f$
\end_inset

.
 One may ask if there is an instantiation of the metavariable 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

 that makes the two following terms equal.
\begin_inset Formula 
\[
f(M(x,y))\stackrel{?}{=}f(N(x))
\]

\end_inset

And indeed, if we instantiate 
\begin_inset Formula $M$
\end_inset

 by 
\begin_inset Formula $\lambda xy.N(x)$
\end_inset

 the two handsides become equal.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In other words, unification consists in finding a metasubstitution 
\begin_inset Formula $\sigma$
\end_inset

 such that the substituted terms 
\begin_inset Formula $t[\sigma]$
\end_inset

 and 
\begin_inset Formula $u[\sigma]$
\end_inset

 are equal.
 Moreover, this 
\emph on
unifier
\emph default
 should be the most general one: given any other unifier 
\begin_inset Formula $\delta$
\end_inset

, there exists a unique 
\begin_inset Formula $\delta'$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma[\delta']$
\end_inset

.
\end_layout

\begin_layout Plain Layout
In higher-order unification, metavariables can take a list of arguments,
 which are other terms.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the latter situation, higher-order unification is of utmost importance:
 terms can involve 
\emph on
function variables
\emph default
 applied to a list of other terms.
 We call those function variables 
\emph on
metavariables
\emph default
, to distinguish them from the ordinary (constant) variables that may come
 from some binding 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, for example.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The data required to substitute a metavariable 
\begin_inset Formula $M$
\end_inset

 taking 
\begin_inset Formula $n$
\end_inset

 arguments consists of a term involving 
\begin_inset Formula $n$
\end_inset

 free variables, which we think as placeholders for each of the arguments.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Then, a 
\emph on
unifier 
\emph default
of two terms 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 is a substitution 
\begin_inset Formula $\sigma$
\end_inset

 assigning such a term for each involved metavariable, such that the substituted
 terms 
\begin_inset Formula $t[\sigma]$
\end_inset

 and 
\begin_inset Formula $u[\sigma]$
\end_inset

 are equal.
 Typically we look for the most general one, in the sense that that every
 other unifier for these two terms factors through it.
 That is, given any other unifier 
\begin_inset Formula $\delta$
\end_inset

, there exists a unique 
\begin_inset Formula $\delta'$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma[\delta']$
\end_inset

.
\end_layout

\end_inset

 Pattern unification was introduced by 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

 for simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

 described an algorithm that either returns the most general unifier of
 two given terms, or detects that the two terms are not unifiable.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Higher-order unification is undecidable
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "unifundecidable"
literal "false"

\end_inset

.
 However, identified a decidable fragment for simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

: each list of arguments given to a metavariable must be a 
\emph on
pattern
\emph default
, that is, a list of distinct object variables.
\end_layout

\end_inset

It was categorically interpreted by 
\begin_inset CommandInset citation
LatexCommand citet
key "vezzosi2014categorical"
literal "false"

\end_inset

 as computing certain coequalisers in a category of metavariable contexts
 and substitutions.
 Their starting point is that patterns correspond to injective renamings
 can be seen as morphisms in a suitable category of contexts.
 Like Miller, they get rid of the 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

-equations by working on the syntax of normalised 
\begin_inset Formula $\lambda$
\end_inset

-terms (which is notably equation free).
 In their conclusion they sketched a track to extend their work for a suitable
 class of languages:
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Instead of [the category of patterns] we can consider a generic category
 
\begin_inset Formula $Ctx$
\end_inset

 having all the pullbacks and equalisers and whose arrows are monomorphisms.
 And instead of the grammar of [normal forms of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus] we can use an arbitrary one defined by a family of operators
 [...] as long as they are functorial with respect to 
\begin_inset Formula $Ctx$
\end_inset

.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Let us clarify what is meant by 
\begin_inset Quotes eld
\end_inset

inversion of the functorial action
\begin_inset Quotes erd
\end_inset

.
 A variable is a nullary operation available in a context 
\begin_inset Formula $\Delta$
\end_inset

; applying a renaming to another context 
\begin_inset Formula $\Delta'$
\end_inset

 yields another variable in 
\begin_inset Formula $\Delta'$
\end_inset

: this is the functorial action of renamings on variables.
 The unification algorithm sometimes needs the partial converse: given a
 renaming from 
\begin_inset Formula $\Delta$
\end_inset

 to 
\begin_inset Formula $\Delta'$
\end_inset

, and a variable 
\begin_inset Formula $x$
\end_inset

 in 
\begin_inset Formula $\Delta'$
\end_inset

, what is the variable in 
\begin_inset Formula $\Delta$
\end_inset

, if any, which is renamed to 
\begin_inset Formula $x$
\end_inset

?
\end_layout

\begin_layout Plain Layout
In their work, inversion of the functorial action is indeed crucially involved
 in unification problems of the shape 
\begin_inset Formula $M(\dots)\stackrel{?}{=}x$
\end_inset

, where 
\begin_inset Formula $x$
\end_inset

 is a variable: here we need to know whether 
\begin_inset Formula $x$
\end_inset

 occurs in the pattern given as argument to 
\begin_inset Formula $M$
\end_inset

, and if so, at which position.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The present work proposes a generalisation as envisioned by Vezzosi-Abel
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
by abstracting away from the specificity of their case study
\end_layout

\end_inset

: we define a class of languages (which obviously includes the normalised
 simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus) for which unification problems can be stated and solved by a
 recursive procedure much similar to Miller's original pattern unification
 algorithm.
 Each language is specified by the following data, from which we can generate
 the base syntax and the enriched syntax with associated notion of metatype,
 metavariable contexts and substitutions.
\end_layout

\begin_layout Itemize
a small category 
\begin_inset Formula ${\cal A}$
\end_inset

 with equalisers and pullbacks, whose objects are called 
\shape italic
scopes
\emph on
,
\shape default
\emph default
 and whose morphisms, called 
\emph on
patterns
\emph default
, are all monomorphic;
\end_layout

\begin_layout Itemize
for each natural number 
\begin_inset Formula $n$
\end_inset

,
\end_layout

\begin_deeper
\begin_layout Itemize
a functorial assignment 
\begin_inset Formula $\Oop n-$
\end_inset

 mapping a scope 
\begin_inset Formula $a$
\end_inset

 to the set of operation symbols available in the context 
\begin_inset Formula $a$
\end_inset

;
\end_layout

\begin_layout Itemize
a functorial assignment 
\begin_inset Formula $\alpha$
\end_inset

 mapping
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:GB-signature"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for a formal definition, involving the construction of a category of elements.
\end_layout

\end_inset

 a scope 
\begin_inset Formula $a$
\end_inset

 and an operation symbol 
\begin_inset Formula $o\in\Oop na$
\end_inset

 to a the list of 
\emph on
input scopes
\emph default
 
\begin_inset Formula $\ntharvec o=(\nthar o1,\dots,\nthar on)$
\end_inset

;
\end_layout

\begin_layout Itemize
such that 
\begin_inset Formula $\Oop n-$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

 preserve equalisers and pullbacks.
\end_layout

\end_deeper
\begin_layout Plain Layout
As we shall see, in practice, types are specified through the notion of
 scopes (first item), while terms are specified through the operation symbols
 and their arities (second item).
\end_layout

\begin_layout Paragraph
Syntax generated by a specification
\end_layout

\begin_layout Plain Layout
The base syntax is generated by the following single rule, where 
\begin_inset Formula $a\vdash t$
\end_inset

 means that the term 
\begin_inset Formula $t$
\end_inset

 is well-formed in the scope 
\begin_inset Formula $a$
\end_inset

.
\begin_inset Formula 
\[
\forall o\in\Oop na\dfrac{\nthar o1\vdash t_{1}\quad\dots\quad\nthar on\vdash t_{n}}{a\vdash o(t_{1},\dots,t_{n})}
\]

\end_inset

The syntax is functorial in the sense that given any pattern 
\begin_inset Formula $f\in\hom(a,b)$
\end_inset

 and term 
\begin_inset Formula $a\vdash t$
\end_inset

, we define by recursion on the structure of 
\begin_inset Formula $t$
\end_inset

 a term 
\begin_inset Formula $b\vdash t\{f\}$
\end_inset

, such that 
\begin_inset Formula $t\{f\}\{g\}=t\{g\circ f\}$
\end_inset

 and 
\begin_inset Formula $t\{id_{a}\}=t$
\end_inset

.
\end_layout

\begin_layout Plain Layout
The enriched syntax with metavariables involves a well-formed judgement
 of the shape 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, where 
\begin_inset Formula $\Gamma$
\end_inset

 is a 
\emph on
metavariable context
\emph default
 that keeps track of the 
\emph on
metatypes 
\emph default
of metavariables, which are just scopes.
 A metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

 is a list of metavariable symbols with their associated metatypes.
 The enriched syntax is generated by two rules, one for operations, and
 one for metavariables.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\forall\Gamma\forall o\in\Oop na\dfrac{\Gamma;\nthar o1\vdash t_{1}\quad\dots\quad\Gamma;\nthar on\vdash t_{n}}{\Gamma;a\vdash o(t_{1},\dots,t_{n})}\qquad\dfrac{M:m\in\Gamma\quad x\in\hom(m,n)}{\Gamma;n\vdash M(x)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Note that contrary to the traditional definition of the pattern fragment,
 where the notion of pattern is derived from the notion of variable, in
 our setting, patterns are built-in (they are morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

) and there is no built-in notion of 
\begin_inset Quotes eld
\end_inset

variables
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout
The enriched syntax is functorial with respect to the category of renamings
 – we define 
\begin_inset Formula $M(x)\{f\}$
\end_inset

 as 
\begin_inset Formula $M(f\circ x)$
\end_inset

 – and is moreover functorial with respect to metasubstitutions.
 Here, a metasubstitution 
\begin_inset Formula $\sigma$
\end_inset

 between two metavariable contexts 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Gamma'$
\end_inset

 assigns to each metavariable declaration 
\begin_inset Formula $M:m$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

 a term 
\begin_inset Formula $\Delta;m\vdash\sigma_{M}$
\end_inset

 .
 Then, given 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, the substituted term 
\begin_inset Formula $\Delta;a\vdash t[\sigma]$
\end_inset

 is defined by recursion on the structure of 
\begin_inset Formula $t$
\end_inset

.
 metasubstitutions compose and are morphisms in a category whose objects
 are scopes.
\end_layout

\begin_layout Paragraph
Typed languages
\end_layout

\begin_layout Plain Layout
Let us explain how typed languages are accounted, although our notion of
 specification does not incorporate any explicit notion of types.
 In Vezzosi-Abel's work, a typing judgement has 4 entities: a metacontext
 
\begin_inset Formula $\Gamma$
\end_inset

, an object context 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 which is a list of simple types (one for each available free variable),
 a term 
\begin_inset Formula $t$
\end_inset

 and its type 
\begin_inset Formula $\tau$
\end_inset

.
 We can handle this type system by merging the context 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and the type 
\begin_inset Formula $\tau$
\end_inset

 into a single entity 
\begin_inset Formula $\vec{\sigma}\rightarrow\tau$
\end_inset

, which we call a scope.
 In other words, in our setting, 
\begin_inset Formula $\Gamma;\vec{\sigma}\vdash t:\tau$
\end_inset

 would be denoted by 
\begin_inset Formula $\Gamma;\vec{\sigma}\rightarrow\tau\vdash t$
\end_inset

, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for more details.
\end_layout

\begin_layout Paragraph
Stating unification
\end_layout

\begin_layout Plain Layout
Let us explain how unification is stated in our setting.
 First, a unifier of two terms 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 in the same metacontext 
\begin_inset Formula $\Gamma$
\end_inset

 and scope 
\begin_inset Formula $a$
\end_inset

 is a metavariable context 
\begin_inset Formula $\Delta$
\end_inset

 and a metasubstitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

.
 It is the most general unifier (abbreviated mgu) if any other unifier 
\begin_inset Formula $\delta$
\end_inset

 uniquely factors through 
\begin_inset Formula $\sigma$
\end_inset

.
 The main feature of pattern unification (that holds for any of our languages)
 is that either the mgu exists, or there is no unifier.
 Moreover, there is a recursive procedure which computes the mgu or detects
 the impossibility of unification.
 
\end_layout

\begin_layout Plain Layout
We use a small trick to avoid this traditional way of presenting unification
 as a partial algorithm computings mgus.
 We add a formal error metavariable context 
\begin_inset Formula $\bot$
\end_inset

 and a single formal term 
\begin_inset Formula $\bot;a\vdash!$
\end_inset

 for all scopes 
\begin_inset Formula $a$
\end_inset

, so that we get a unique metasubstitution 
\begin_inset Formula $!_{\Gamma}$
\end_inset

 from any metacontext 
\begin_inset Formula $\Gamma$
\end_inset

 to 
\begin_inset Formula $\bot$
\end_inset

.
 This substitution obviously unifies any pair of terms.
 If two terms are not unifiable in the traditional sense, 
\begin_inset Formula $!$
\end_inset

 is the mgu.
 If 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 is the mgu in the traditional sense, then it is still the mgu in this extended
 setting, because 
\begin_inset Formula $!_{\Gamma}$
\end_inset

 uniquely factors as 
\begin_inset Formula $\bang_{\Delta}\circ\sigma$
\end_inset

.
 In this way, unification can then be seen as a total algorithm that always
 computes the mgu.
\end_layout

\begin_layout Paragraph
Comparison with Vezzosi-Abel's vision
\end_layout

\begin_layout Plain Layout
We mentioned above our implicit treatment of types and failure that makes
 our abstract setting simpler.
 On top of that, the key additional ingredient that we introduce is the
 preservation of equalisers and pullbacks.
 This is crucial to ensure that given two terms, either there is a mgu,
 either there is no unifier.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
(see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:counter-example"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for a counter-example).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
, which allows us to work with a simple well-formed judgement.
 We also handle partiality in a different manner.
 Indeed, unification is traditionally presented as a partial algorithm that
 computes the mgu, and fails when this is not possible, that is, when there
 is no unifier.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
More specifically, we assume
\end_layout

\begin_layout Plain Layout
With this in mind, an abstract notion of 
\end_layout

\begin_layout Plain Layout
Note that the opposite category of any of these categories of metacontexts
 and substitutions yield a (multi-sorted) Lawvere theory.
 Conversely, given a multi-sorted Lawvere theory, we can recover the syntax
 with a well-formed judgement 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

 as follows: a scope 
\begin_inset Formula $a$
\end_inset

 is a sort, an
\end_layout

\begin_layout Plain Layout
Each ofThese three categories of metacontexts and substitutions yield multi-sort
ed
\end_layout

\begin_layout Plain Layout
This motivates an abstract setting for unification: it is
\end_layout

\begin_layout Plain Layout
Finally we can define composition of metavariables substitutions and consider
 the opposite category of metavariable contexts and substitutions.
 This induces
\begin_inset Foot
status open

\begin_layout Plain Layout
We should rigorously identify metavariable contexts that are the same, as
 multisets of metatypes.
\end_layout

\end_inset

 three different multi-sorted Lawvere theories, one for each variant.
 Note that in these categories, a term 
\begin_inset Formula $\Gamma;n\vdash t$
\end_inset

 is equivalently given by a morphism from 
\begin_inset Formula $\Gamma$
\end_inset

 to the singleton metacontext 
\begin_inset Formula $N:n$
\end_inset

.
 Unification of two terms 
\begin_inset Formula $\Gamma;n\vdash t,u$
\end_inset

 consists in computing their equaliser if it exists.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Conversely, given a Lawvere theory, we can reconstruct the enriched syntax.
 First, we take as scopes the set of sorts.
 terms in the total context 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

 are defined to be morphisms from 
\begin_inset Formula $\{m_{1},\dots,m_{p}\}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Lawvere theories provide an abstract account of unification: a term in the
 enriched syntax corresponds to a morphism, and unifying a pair of them
 consists in computing their equaliser.
 There can be multiple ways to organise a syntax as a (multi-sorted) Lawvere
 theory: depending on which flavour of unification we want, we may choose
 different notion of morphisms.
 Let us illustrate this with the above example of syntax.
 We take the set of sorts to be the set of natural numbers.
 In this way, an object of the Lawvere theory is a multi-set of natural
 numbers, which we think of as a metavariable context.
 Morphisms from a metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

 to the singleton multiset 
\begin_inset Formula $[n]$
\end_inset

 are in one-to-one correspondance with terms in the context 
\begin_inset Formula $\Gamma;n$
\end_inset

, which depend on the variant of the unification.
 Note that the base syntax is recovered as morphisms from the empty metavariable
 context.
\end_layout

\begin_layout Plain Layout
To generate a Lawvere theory, we can use a presheaf account of syntax, as
 a monad 
\begin_inset Formula $T$
\end_inset

 on a presheaf category 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

.
 The generated Lawvere theory has objects of 
\begin_inset Formula ${\cal A}$
\end_inset

 as sorts, and a morphism between 
\begin_inset Formula $\{a_{1},\dots,a_{n}\}$
\end_inset

 and 
\begin_inset Formula $\{b\}$
\end_inset

 is a Kleisli morphism 
\begin_inset Formula $yb\rightarrow T(ya_{1}+\dots+ya_{n})$
\end_inset

, where 
\begin_inset Formula $y:\op{{\cal A}}\rightarrow[{\cal A},\Set]$
\end_inset

 denotes the Yoneda embedding.
 Let us see how it works for the example of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 For first-order unification
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
More generally, first-order unification corresponds to discrete categories
 
\begin_inset Formula ${\cal A}$
\end_inset

 and free monads on 
\begin_inset Formula $[{\cal A},\Set$
\end_inset

].
\end_layout

\end_inset

, we take 
\begin_inset Formula ${\cal A}$
\end_inset

 to be the discrete category 
\begin_inset Formula $\mathbb{N}$
\end_inset

 whose objects are natural numbers, and 
\begin_inset Formula $T$
\end_inset

 is the monad freely generated by the endofunctor on 
\begin_inset Formula $\Set^{\mathbb{N}}$
\end_inset

 mapping 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $n\mapsto\{1,\dots n\}+X_{n}\times X_{n}+X_{n+1}$
\end_inset

.
 Let us show how terms in context 
\begin_inset Formula $\Gamma;n$
\end_inset

 corresponds to morphisms 
\begin_inset Formula $yn\rightarrow T(ym_{1}+\dots+ym_{p})$
\end_inset

, assuming 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{p}:M_{p})$
\end_inset

.
 By definition of the free monad, 
\begin_inset Formula $TX$
\end_inset

 satisfies the fixpoint equation 
\begin_inset Formula $TX_{n}\cong\{1,\dots n\}+TX_{n}\times TX_{n}+TX_{n+1}+X_{n}$
\end_inset

.
 It follows that a morphism from 
\begin_inset Formula $yn$
\end_inset

 to 
\begin_inset Formula $T(ym_{1}+\dots+ym_{p})$
\end_inset

 is given by an element of 
\begin_inset Formula $T(ym_{1}+\dots ym_{p})_{n}$
\end_inset

.
 Due to the fixpoint equation, it is either a variable, an appli
\end_layout

\begin_layout Plain Layout
Second-order unification can be accounted similarly by Hamana's 
\begin_inset Formula $\Sigma$
\end_inset

-monoid monad.
 As for pattern unification, our key insight is that it is quite similar
 to the first-order case, we take the same endofunctor on 
\begin_inset Formula $\Set^{\mathbb{N}}$
\end_inset

, lift it to an endofunctor on the category 
\begin_inset Formula $[\mathbb{F}_{m},\Set]$
\end_inset

, where 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 has natural numbers as objects and a morphism from 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $m$
\end_inset

 is an injective renaming, and finally take its free monad thre.
\end_layout

\begin_layout Plain Layout
QUESTCE QUE J'ECRIS aPRES?
\end_layout

\begin_layout Plain Layout
the notion of
\emph on
 generalised binding signature
\emph default
 (abbreviated as GB-signatures) which abstracts the key properties and structure
 of the category of contexts described by 
\begin_inset CommandInset citation
LatexCommand citet
key "vezzosi2014categorical"
literal "false"

\end_inset

 that are used in the pattern unification algorithm.
 
\end_layout

\begin_layout Plain Layout
Pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus (without 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

 equation) fits into this scheme: using De Bruijn encoding, a scope is a
 natural number indicating the number of available free variables, and a
 variable is then just an index.
\begin_inset Formula 
\[
\dfrac{}{n\vdash\underline{1}^{n}}\dots\dfrac{}{n\vdash\underline{n}^{n}}\quad\dfrac{n\vdash t\quad n\vdash u}{n\vdash app_{n}(t,u)}\quad\dfrac{n+1\vdash t}{n\vdash abs_{n}(t)}
\]

\end_inset

Note that there is one application and abstraction symbol per variable context
 
\begin_inset Formula $n$
\end_inset

, and variable symbols are similarly duplicated.
\end_layout

\begin_layout Plain Layout
Variable contexts can account for more sophisticated type systems.
 
\end_layout

\begin_layout Plain Layout
The syntax of normalised 
\begin_inset Formula $\lambda$
\end_inset

-terms can also be described in this way (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

), as well as polymorphic syntaxes such as system F (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Fully dependently typed languages, where types can depend on terms, are
 however not supported.
 Indeed, intuitively, in a GB-signature, types are specified through the
 set of variable contexts, which must be given independantly and prior to
 the set of operation symbols with their formation rules: this sequential
 splitting is not possible with dependent types.
\end_layout

\begin_layout Plain Layout
Let us now explain how we include metavariables in the picture.
 For this, we need to keep track of the metavariable arities in a separate
 metavariable context.
 Therefore, the well-formed judgement is now of the shape 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, where 
\begin_inset Formula $\Gamma$
\end_inset

 is a metavariable context (we will introduce them below).
 The formation rule 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:formation-rule-op"
plural "false"
caps "true"
noprefix "false"

\end_inset

 of an operation symbol 
\begin_inset Formula $o$
\end_inset

 are generalised to any metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

:
\begin_inset Formula 
\[
\dfrac{\Gamma;\nthar o1\vdash t_{1}\quad\dots\quad\Gamma;\nthar on\vdash t_{n}}{\Gamma;a\vdash o(t_{1},\dots,t_{n})}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Of course, we need a specific set of rules to generate metavariable applications.
 In the case of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, we expect a metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

 to be a list of metavariable symbols with their arities, which are just
 natural numbers – the number of arguments.
 A valid 
\emph on
pattern 
\emph default
for the metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $m$
\end_inset

 in a scope 
\begin_inset Formula $n$
\end_inset

 consists of 
\begin_inset Formula $m$
\end_inset

 distinct variables in the scope 
\begin_inset Formula $n$
\end_inset

, or equivalently, an injective map from 
\begin_inset Formula $\{1,\dots,m\}$
\end_inset

 to 
\begin_inset Formula $\{1,\dots n\}$
\end_inset

.
 Injective maps compose, so that we get a category of variables contexts.
 In this respect, the formation rule for metavariable application can be
 written as follows.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{M:m\in\Gamma\quad x\in\hom(m,n)}{\Gamma;n\vdash M(x)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Let us come back to the general case: given any GB-signature, we define
 a metavariable context to be a list of metavariables symbols with their
 associated arities, which are just variable contexts.
 A GB-signature provides a set of morphisms between variable contexts that
 we call 
\emph on
patterns
\emph default
 or 
\emph on
renamings
\emph default
, so that we get a category of variable contexts and renamings.
 Then, we have the same formation rule for metavariable application as above
 (except that 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 are variable contexts instead of natural numbers).
\end_layout

\begin_layout Plain Layout
A GB-signature also includes additional data necessary to define the action
 of metasubstitutions on terms.
 Here, a metasubstitution 
\begin_inset Formula $\sigma$
\end_inset

 between two metavariable contexts 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Delta$
\end_inset

 assigns to each metavariable declaration 
\begin_inset Formula $M:m$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

 a term 
\begin_inset Formula $\sigma_{m}$
\end_inset

 in the context 
\begin_inset Formula $\Delta;m$
\end_inset

.
 Then, given 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, the substituted term 
\begin_inset Formula $\Delta;a\vdash t[\sigma]$
\end_inset

 is defined by recursion on the structure of 
\begin_inset Formula $t$
\end_inset

.
 If 
\begin_inset Formula $t$
\end_inset

 is an operation 
\begin_inset Formula $o(t_{1},\dots,t_{n})$
\end_inset

, then 
\begin_inset Formula $t[\sigma]$
\end_inset

 is simply 
\begin_inset Formula $o(t_{1}[\sigma],\dots,t_{n}[\sigma])$
\end_inset

.
 The metavariable case requires additional structure; to see, let us look
 at the pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus case: we want to apply the substitution to the term 
\begin_inset Formula $M(x)$
\end_inset

 where 
\begin_inset Formula $x=(x_{1},\dots,x_{m})$
\end_inset

 is a list of distinct variables.
 The resulting term should be 
\begin_inset Formula $\sigma_{M}$
\end_inset

, but where the free variables 
\begin_inset Formula $1,..,m$
\end_inset

 have been renamed with 
\begin_inset Formula $x_{1},\dots,x_{m}$
\end_inset

.
 This means that we first need to define how an injective renaming 
\begin_inset Formula $x\in\hom(m,n)$
\end_inset

 acts on a given term 
\begin_inset Formula $\Gamma;m\vdash t$
\end_inset

 resulting in a new term 
\begin_inset Formula $\Gamma;n\vdash t\{x\}$
\end_inset

: again this is defined by recursion.
 The base case is the metavariable application 
\begin_inset Formula $P(p)$
\end_inset

: this is given by composition of renaming, i.e., 
\begin_inset Formula $P(p)\{x\}$
\end_inset

 is just 
\begin_inset Formula $P(p\circ x)$
\end_inset

.
 The others cases involve changing the operation symbols:
\begin_inset Formula 
\[
\underline{i}^{m}\{x\}=\underline{x}_{i}^{n}\quad app_{m}(t,u)\{x\}=app_{n}(t\{x\},u\{x\})\quad abs_{m}(t)\{x\}=abs_{n}(t\{x\uparrow\})
\]

\end_inset

where 
\begin_inset Formula $x\uparrow$
\end_inset

 is the renaming between 
\begin_inset Formula $n+1$
\end_inset

 and 
\begin_inset Formula $m+1$
\end_inset

 which coincides with 
\begin_inset Formula $x$
\end_inset

 on the first 
\begin_inset Formula $n^{th}$
\end_inset

 elements, and maps
\begin_inset Foot
status open

\begin_layout Plain Layout
Here we adopt the De Bruijn level convention where the variable bound by
 a 
\begin_inset Formula $\lambda$
\end_inset

-abstraction is not 0 but the biggest free variable in the scope.
\end_layout

\end_inset

 
\begin_inset Formula $n+1$
\end_inset

 to 
\begin_inset Formula $m+1$
\end_inset

.
 Accordingly, a GB-signature provides a functorial action of the renamings
 on the set of operation symbols.
 This allows us to define actions of renamings on the generated syntax,
 and then, action of metasubstitutions, so as to provide a meaningful setting
 for unification.
\end_layout

\begin_layout Plain Layout
We are now ready to sum up what a GB-signature is: it consists of 
\end_layout

\begin_layout Itemize
a small category 
\begin_inset Formula ${\cal A}$
\end_inset

 whose objects are called 
\emph on
arities
\shape italic
\emph default
 
\emph on
or
\emph default
 variable contexts
\emph on
,
\shape default
\emph default
 and whose morphisms are called 
\shape italic
renamings
\shape default
;
\end_layout

\begin_layout Itemize
for each variable context 
\begin_inset Formula $a$
\end_inset

, a set of operation symbols 
\begin_inset Formula $O(a)$
\end_inset

;
\end_layout

\begin_layout Itemize
for each operation symbol 
\begin_inset Formula $o\in O(a)$
\end_inset

, a list of variable contexts 
\begin_inset Formula $\ntharvec o=(\nthar o1,\dots,\nthar on)$
\end_inset

;
\end_layout

\begin_layout Plain Layout
such that 
\begin_inset Formula $O$
\end_inset

 and 
\begin_inset Formula $\ntharvecfunct$
\end_inset

 are functorial in a suitable sense.
\end_layout

\begin_layout Plain Layout
This provides enough structure to state unification problems.
 However, to define a unification algorithm, we need additional properties,
 namely:
\end_layout

\begin_layout Itemize
\begin_inset Formula ${\cal A}$
\end_inset

 must have equalisers and pullbacks, preserved by 
\begin_inset Formula $O$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

;
\end_layout

\begin_layout Itemize
all morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 are monomorphisms.
\end_layout

\begin_layout Plain Layout
A GB-signature is said 
\emph on
pattern-friendly 
\emph default
if it satisfies those additional properties, which we will explain in detail.
 Then, we can essentially straightforwardly generalise Miller's unification
 algorithm: given two terms in the same context 
\begin_inset Formula $\Gamma;a$
\end_inset

, we can decide whether or not there exists a unifier, and if so, compute
 the most general one.
 In some sense, this fullfils 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "vezzosi2014categorical"
literal "false"

\end_inset

's prediction in their conclusion: 
\end_layout

\begin_layout Plain Layout
Let us detail this latter example.
 a scope is of the shape 
\begin_inset Formula $n|\Delta\rightarrow\tau$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of available type variables, 
\begin_inset Formula $\Delta$
\end_inset

 is a list of types (one for each term variable) that may involve some of
 the available type variables, and 
\begin_inset Formula $\tau$
\end_inset

 is the output type.
 A pattern, as a morphism between 
\begin_inset Formula $n|\Delta\rightarrow\tau$
\end_inset

 and 
\begin_inset Formula $n'|\Delta'\rightarrow\tau'$
\end_inset

, consists of an injective renaming 
\begin_inset Formula $f$
\end_inset

 from 
\begin_inset Formula $\{1,\dots n\}$
\end_inset

 to 
\begin_inset Formula $\{1,\dots n'\}$
\end_inset

 such that 
\begin_inset Formula $\tau$
\end_inset

 becomes equal to 
\begin_inset Formula $\tau'$
\end_inset

 after renaming its type variables according to 
\begin_inset Formula $f$
\end_inset

, and an injective assignment mapping each position in 
\begin_inset Formula $\Delta$
\end_inset

 to a position in 
\begin_inset Formula $\Delta'$
\end_inset

 such that the types at those respective positions are equal (up to renaming
 according to 
\begin_inset Formula $f$
\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
However, in their conclusion, they give some hints about a possible generalisati
on:
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
However, while recent results in type inference, such as 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/DunfieldK19"
literal "false"

\end_inset

, or 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/ZhaoOS19"
literal "false"

\end_inset

, make heavy use of unification in their algorithms, they do not do so in
 a well-abstracted way.
 They present a set of rules (i.e., a first-order functional program) which
 explicitly re-implement unification, and as a result their correctness
 proofs have to re-establish many of the fundamental results of unification
 theory individually.
 Almost no lemmas in the proof of the one algorithm can be re-used in the
 other, which is particularly problematic given the sizes of the proofs
 involved: 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/DunfieldK19"
literal "false"

\end_inset

 comes with a 190 page appendix, and Zhao et al's Coq proof is many thousands
 of lines long.
\end_layout

\begin_layout Plain Layout
Worse still, if any modifications to the unification algorithm were needed,
 then the entire metatheory would need to be redone.
 For example, both of these systems make use of first-order unification
 (i.e., for types without binders in them), by retaining the ML-style monotype/pol
ytype distinction.
 Something as innocuous as the addition of a monomorphic type with a binder
 (for example, a recursive type 
\begin_inset Formula $\mu a.A[a]$
\end_inset

) would require moving from first-order unification to something like Miller
 pattern unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:journals/logcom/Miller91"
literal "true"

\end_inset

, where metavariables are no longer constant but may be applied to distinct
 variables.
 This would in turn require completely redoing all of the proofs in the
 two systems.
 Type inference for dependent types also uses Miller patterns, of course,
 but the example of recursive types shows that this issue arises long before
 we reach the most sophisticated type theories.
\end_layout

\begin_layout Plain Layout
Fixing this problem would require doing two things.
 First, these type inference algorithms need to be rephrased in such a way
 that they invoke unification as a subroutine, which would enable us to
 make use of generic results about unification theory.
 Second, the unification algorithm needs to be formulated generically enough
 that it can be plugged into multiple contexts without needing substantial
 modifications to the guts of the proof.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(old intro)Unification consists in finding a 
\emph on
unifier 
\emph default
of two terms 
\begin_inset Formula $t,u$
\end_inset

, that is a (metavariable) substitution 
\begin_inset Formula $\sigma$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

.
 Unification algorithms try to compute a most general unifier 
\begin_inset Formula $\sigma$
\end_inset

, in the sense that given any other unifier 
\begin_inset Formula $\delta$
\end_inset

, there exists a unique 
\begin_inset Formula $\delta'$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma[\delta']$
\end_inset

.
 First-order unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "robinsonunif"
literal "false"

\end_inset

 is used in ML-style type inference systems and logic programming languages
 such as Prolog.
 More advanced type systems, where variable binding is crucially involved,
 requires second-order unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "huetunif"
literal "false"

\end_inset

, which is undecidable
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "unifundecidable"
literal "false"

\end_inset

.
 However, Miller
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

 identified a decidable fragment: in so-called 
\emph on
pattern unification
\emph default
,
\emph on
 
\emph default
metavariables are allowed to take distinct variables as arguments.
 In this situation, we can write an algorithm that either fails in case
 there is no unifier, or computes the most general unifier.
\end_layout

\begin_layout Plain Layout
Recent results in type inference, Dunfield-Krishnaswami
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/DunfieldK19"
literal "false"

\end_inset

, or Jinxu et.
 al
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/ZhaoOS19"
literal "false"

\end_inset

, include very large proofs: the former comes with a 190 page appendix,
 and the latter comes with a Coq proof many thousands of lines long -- and
 both of these results are for tiny kernel calculi.
 If we ever hope to extend this kind of result to full programming languages
 like Haskell or OCaml, we must raise the abstraction level of these proofs,
 so that they are no longer linear (with a large constant) in the size of
 the calculus.
 A close examination of these proofs shows that a large part of the problem
 is that the type inference algorithms make use of unification, and the
 correctness proofs for type inference end up essentially re-establishing
 the entire theory of unification for each algorithm.
 The reason they do this is because algorithmic typing rules essentially
 give a first-order functional program with no abstractions over (for example)
 a signature for the unification algorithm to be defined over, or any axiomatic
 statement of the invariants the algorithmic typing rules had to maintain.
\end_layout

\begin_layout Plain Layout
The present work is a first step towards a general solution to this problem.
 Our generic unification algorithm implemented in Agda is parameterised
 by a new notion of signature for syntax with metavariables, whose scope
 goes beyond the standard binding signatures.
 One important feature is that the notion of contexts is customisable, making
 it possible to cover simply-typed second-order syntax, ordered syntax,
 or (intrinsic) polymorphic syntax such as System F.
 We focused on Miller's pattern unification, as this is already a step beyond
 the above-cited works
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/ZhaoOS19,DBLP:journals/pacmpl/DunfieldK19"
literal "false"

\end_inset

 that use plain first-order unification.
 Moreover, this is necessary for types with binders (e.g., fixed-point operators
 like 
\begin_inset Formula $\mu a.A[a]$
\end_inset

) as well as for rich type systems like dependent types.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Subsection*
Related work
\end_layout

\begin_layout Plain Layout
First-order unification, where all metavariables are constant, was categorically
 rephrased in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

.
 Pattern unification was introduced in 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

, as a particular case of higher-order unification for the simply-typed
 lambda-calculus, where metavariables are applied to distinct variables.
 It was categorically rephrased in 
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
, with concluding hints about how to generalise their work.
\end_layout

\end_inset

The present paper can be thought of as a generalisation of their work.
\end_layout

\begin_layout Personal Question

\lang french
\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

 propose une generalisation intéressante, avec le lemme sur les epis.
 (Theorem 10).
 Est-ce qu'on pourrait encore generaliser encore notre business?
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
As an introduction, we start by presenting pattern unification in the case
 of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

, before The goal of this paper is to generalise it, by parameterising the
 algorithm by a signature specifying a syntax.
 Then, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we motivate our general setting and provide categorical semantics of the
 algorithm, by revisiting pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\end_inset

 Our paper generalises those previous work in the following ways:
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In type inference, unification offers a convenient way of handling the instantia
tion of quantifiers: whenever a polymorphic type of the form 
\begin_inset Formula $\forall a.$
\end_inset

 is eliminated, a fresh metavariable can be substituted for the quantified
 variable 
\begin_inset Formula $a$
\end_inset

, and then unification can be used to incrementally deduce what the instantiatio
n should have been, thereby sparing the programmer from having to instantiate
 quantifiers manually.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
First-order unification applies to first-order syntaxes, where metavariables
 do not take any argument, as opposed to higher-order unification, which
 .
 There,
\end_layout

\begin_layout Enumerate
We define the notion of 
\emph on
pattern-friendly generalised binding signature
\emph default
 (later called pattern-friendly GB-signature) which abstracts the key properties
 and structure of the category of contexts described by 
\begin_inset CommandInset citation
LatexCommand citet
key "vezzosi2014categorical"
literal "false"

\end_inset

 that are used in the pattern unification algorithm.
 As a consequence, the unification algorithm now applies uniformly to various
 syntaxes.
\end_layout

\begin_layout Enumerate
We adapt the initial-algebra approach taken by 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

 to GB-signatures.
 The category of metavariable contexts and substitutions (in which most
 general unifiers are computed as coequalisers) is then retrieved as a full
 subcategory of the Kleisli category for a free monad on some presheaf category
 (rather than on a power of the category of sets, as in the first-order
 case).
 We thus get semantics for pattern unification, which enable use to prove
 soundness and completeness of the unification algorithm.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The Agda code is much simpler than an earlier, less-strongly typed, version
 written in OCaml.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
In this paper, we take one further step towards addressing the modularity
 problem in the theory of type inference, by showing how to formulate Miller
 pattern unification in a generic, abstract style.
 Like prior developments
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "10.1007/978-3-540-45220-1_41"
literal "false"

\end_inset

, we parameterise the algorithm over a notion of binding signature which
 is very general: it has a customisable notion of context, which makes it
 possible to handle examples such as simply-typed second-order syntax, ordered
 lambda calculi, and intrinsic polymorphic syntax (such as System F).
 This lets us derive several new unification algorithms simply as instantiations
 of our framework.
\end_layout

\begin_layout Plain Layout
Furthermore, our notion of signature can be axiomatised in a categorical
 style, which leads to an almost purely categorical proof of the correctness
 of our algorithm -- each of the rules of our pattern unification algorithm
 ends up corresponding to some standard categorical construction, and each
 part of our proof essentially just shows that the construction actually
 has the expected properties.
 This is similar to Rydeheard and Burstall's similar reconstruction of first-ord
er unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

, and serves as evidence that we have correctly factored the unification
 algorithm.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Presentation of the algorithm
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:summary-algo"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout

\series bold
Judgments
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta\quad\Longleftrightarrow & \quad\text{\ensuremath{\sigma:\Gamma\rightarrow\Delta}\text{ is the most general unifier of \ensuremath{\vec{t}} and \ensuremath{\vec{u}}}}\\
\Gamma\prune{\vec{u}}{\ensuremath{\overrightarrow{M(\vec{x})}}}{\sigma}{\vec{w}}\dashv\Delta\quad\Longleftrightarrow & \quad\ensuremath{\sigma:\Gamma\rightarrow\Delta}\text{ extended with \ensuremath{M_{i}\mapsto w_{i}} is the most \text{general unifier of \ensuremath{\Gamma\vdash\vec{u}} and \ensuremath{\overrightarrow{M(\vec{x})}}}}\\
\highlighted{m\vdash\vec{x}=\vec{y}\Rightarrow\vec{z}\dashv p}\quad\Longleftrightarrow & \quad(z_{1},\dots,z_{p})\text{ are the common positions of \ensuremath{(x_{1},\dots,x_{m})} and \ensuremath{(y_{1},\dots,y_{m})}}\\
\highlighted{\highlighted{n\prunecat{\vec{x}}{\vec{y}}{\vec{r}\dashv p}{\vec{l}}{}}}\quad\Longleftrightarrow & \quad(l_{1},\dots,l_{p})\text{ and \ensuremath{(r_{1},\dots,r_{p})} are the common value positions of \ensuremath{(x_{1},\dots,x_{n})} and \ensuremath{\vec{y}}}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Unification Phase
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Formula 
\[
\labelULrule{\unificationempty}{Empty}\quad\labelULrule{\unificationtop}{ExFalso}
\]

\end_inset


\begin_inset Formula 
\[
\labelULrule{\unificationstepwisenolabel{}}{Split}{}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid-rigid (
\begin_inset Formula $o,o'$
\end_inset

 are applications, 
\begin_inset Formula $\lambda$
\end_inset

-abstractions, or variables)
\begin_inset Formula 
\[
\labelULrule{\unificationrigrignolabel}{RigRig}\qquad\labelULrule{\unificationrigrigneqo}{Clash}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-*, no cycle 
\begin_inset Formula 
\[
\labelULrule{\dfrac{M\notin u\qquad\Gamma\prune u{\maybold M(\vec{x})}{\sigma}w\dashv\Delta}{\Gamma,M:m\vdash M(\vec{x})=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}}{NoCycle}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Flex, same
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labelULrule{\dfrac{\highlighted{m\vdash\vec{x}=\vec{y}\Rightarrow\vec{z}\dashv p}}{\Gamma,M:m\vdash M(\vec{x})=M(\vec{y})\Rightarrow M\mapsto M'(\vec{z})\dashv\Gamma,M':p}}{Flex}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Rigid, cyclic
\begin_inset Formula 
\[
\labelULrule{\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(\vec{x})=u\Rightarrow\bang\dashv\bot}}{Cyclic}{}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
pruning phase
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Formula 
\[
\pruningempty\quad\dfrac{}{\bot\prune{\vec{t}}{\overrightarrow{M(\vec{x})}}{\bang}{\bang}\dashv\bot}
\]

\end_inset


\begin_inset Formula 
\[
\labelPLrule{\inferruletwo{\Gamma\prune{t_{1}}{M(\vec{x}_{1})}{\sigma_{1}}{u_{1}}\dashv\Delta_{1}}{\Delta_{1}\prune{\vec{t_{2}}[\sigma_{1}]}{\overrightarrow{M(\vec{x}_{2})}}{\sigma_{2}\dashv\Delta_{2}}{\vec{u_{2}}}}{\Gamma\prune{t_{1},\vec{t_{2}}}{M_{1}(\vec{x}_{1}),\overrightarrow{M(\vec{x}_{2})}}{\sigma_{1}[\sigma_{2}]}{u_{1}[\sigma_{2}],\vec{u}_{2}}\dashv\Delta_{2}}}{Split}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid
\end_layout

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\labelPLrule{\dfrac{\Gamma\prune t{\maybold M'(\vec{x},\overbrace{\var{n+1}}^{\mathclap{\text{bound variable}}})}{\sigma}w\dashv\Delta}{\Gamma\prune{\lambda t}{\maybold M(\vec{x})}{\sigma}{\lambda w}\dashv\Delta}}{Lam}{}\quad\labelPLrule{\dfrac{\Gamma\prune{t,u}{\maybold M_{1}(\vec{x}),\maybold M_{2}(\vec{x})}{\sigma}{w_{1},w_{2}}\dashv\Delta}{\Gamma\prune{t\ u}{\maybold M(\vec{x})}{\sigma}{w_{1}\ w_{2}}\dashv\Delta}}{\textsc{App}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labelPLrule{\dfrac{y=x_{i}}{\Gamma\prune y{\maybold M(\vec{x})}{1_{\Gamma}}{\var i}\dashv\Gamma}}{VarOk}\qquad\labelPLrule{\dfrac{y\notin\vec{x}}{\Gamma\prune y{\maybold M(\vec{x})}{\bang}{\bang}\dashv\bot}}{VarFail}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex
\begin_inset Formula 
\[
\labelPLrule{\dfrac{\highlighted{n\prunecat{\vec{x}}{\vec{y}}{\vec{r}\dashv p}{\vec{l}}{}}}{\Gamma,N:n\prune{N(\vec{x})}{\maybold M(\vec{y})}{N\mapsto P(\vec{r})}{P(\vec{l})}\dashv\Gamma,P:p}}{Flex}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unification for pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:algo-pure-lambda"

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout

\series bold
Judgments
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5em}
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta\quad\Longleftrightarrow & \quad\text{\ensuremath{\sigma:\Gamma\rightarrow\Delta}\text{ is the most general unifier of \ensuremath{\vec{t}} and \ensuremath{\vec{u}}}}\\
\Gamma\prune{\vec{u}}{\ensuremath{\overrightarrow{M(x)}}}{\sigma}{\vec{w}}\dashv\Delta\quad\Longleftrightarrow & \quad\ensuremath{\sigma:\Gamma\rightarrow\Delta}\text{ extended with \ensuremath{M_{i}\mapsto w_{i}} is the most \text{general unifier of \ensuremath{\Gamma\vdash\vec{u}} and \ensuremath{\overrightarrow{M(\vec{x})}}}}\\
\highlighted{m\vdash x=y\Rightarrow z\dashv p}\quad\Longleftrightarrow & \quad\xymatrix{p\ar[r]^{z} & m\coeqr{x}{y} & \dots}
\text{ is an equaliser in \ensuremath{{\cal A}}}\\
\highlighted{\highlighted{n\prunecat xy{r\dashv p}l{}}}\quad\Longleftrightarrow & \quad\begin{array}{c}
\xymatrix{p\ar[r]^{l}\ar[d]_{r} & n\ar[d]^{x}\\
\dots\ar[r]_{y} & \dots
}
\end{array}\text{ is a pullback in \ensuremath{{\cal A}}}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Unification Phase
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Formula 
\[
\unificationempty\quad\unificationtop
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\unificationstepwisenolabel x}{U-Split}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid-rigid
\begin_inset Formula 
\[
\labellabelrule{\unificationrigrignolabel}{U-RigRig}\qquad\labellabelrule{\unificationrigrigneqo}{U-Clash}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-*, no cycle 
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\notin u\qquad\Gamma\prune u{\maybold M(x)}{\sigma}w\dashv\Delta}{\Gamma,M:m\vdash M(x)=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}}{U-NoCycle}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Flex, same
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\Gamma,M:m\vdash M(x)=M(y)\Rightarrow M\mapsto M'(z)\dashv\Gamma,M':p}}{U-Flex}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Rigid, cyclic
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang\dashv\bot}}{U-Cyclic}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
pruning phase
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Formula 
\[
\pruningempty\quad\dfrac{}{\bot\prune{\vec{t}}{\overrightarrow{M(x)}}{\bang}{\bang}\dashv\bot}
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\inferruletwo{\Gamma\prune{t_{1}}{M_{1}(x_{1})}{\sigma_{1}}{u_{1}}\dashv\Delta_{1}}{\Delta_{1}\prune{\vec{t_{2}}[\sigma_{1}]}{\overrightarrow{M_{2}(x_{2})}}{\sigma_{2}\dashv\Delta_{2}}{\vec{u_{2}}}}{\Gamma\prune{t_{1},\vec{t_{2}}}{M_{1}(x_{1}),\overrightarrow{M(x_{2})}}{\sigma_{1}[\sigma_{2}]}{u_{1}[\sigma_{2}],\vec{u}_{2}}\dashv\Delta_{2}}}{\textsc{P-Split}}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\Gamma\prune{\vec{t}}{M_{1}(\ntharvecaction{o'}x1),\dots,M_{n}(\ntharvecaction{o'}xn)}{\sigma}{\vec{u}}\dashv\Delta\quad o=\rename{o'}x}{\Gamma\prune{o(\vec{t})}{M(\arg x)}{\sigma}{o'(\vec{u})}\dashv\Delta}}{P-Rig}\quad\labellabelrule{\dfrac{o\neq\rename{\dots}x}{\Gamma\prune{o(\vec{t})}{M(\arg x)}{\bang}{\bang}\dashv\bot}}{P-Fail}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{n\prunecat xy{r\dashv p}l{}}}{\Gamma,N:n\prune{N(x)}{\maybold M(y)}{N\mapsto P(r)}{P(l)}\dashv\Gamma,P:p}}{P-Flex}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Generic pattern unification algorithm (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generic"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:generic-algo"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we start by describing a pattern unification algorithm for pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, summarised in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We claim no originality here; minor variants of the algorithm can be found
 in the literature: it serves mainly as an introduction to the generic algorithm
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generic"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and summarised in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-gen"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The type signatures of the implemented functions are listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:type-signatures"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and will be explained in the following subsections.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-prune-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\highlighted{m\prunecat xy{r\dashv p}l{}}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x):>y\Rightarrow\qquad\\
P(l);M\mapsto P(r)\dashv\Gamma[P:p]
\end{array}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\prune t{x\uparrow}{\sigma}{t'}\dashv\Delta}{\Gamma\prune{\lambda t}x{\sigma}{\lambda t'}\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{i=x_{j}}{\Gamma\prune{\lcvar i}x{1_{\Gamma}}{\lcvar j}\dashv\Gamma}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{i\notin x}{\Gamma\prune{\lcvar i}x{\bang_{s}}{\bang}\dashv\bot}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\Gamma\prune tx{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{u[\sigma_{1}]}x{\sigma}{u'}_{2}\dashv\Delta_{2}
\end{array}}{\Gamma\prune{t\ u}x{\sigma}{t'[\sigma_{2}]\ u'}_{1}[\sigma_{2}]\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
Failure propagation (
\begin_inset Formula $\AgdaKeyword{do}$
\end_inset

 notation)
\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\bot\prune tx{\bang_{s}}{\bang}\dashv\bot
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pruning for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

) 
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-no-cycle-lam"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash t=t'\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash\lambda t=\lambda t'\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\Gamma\vdash t=t'\Rightarrow\sigma_{1}\dashv\Delta_{1}\\
\Gamma\vdash u[\sigma_{1}]=u'[\sigma_{2}]\Rightarrow\sigma_{2}\dashv\Delta_{2}
\end{array}}{\Gamma\vdash t\ u=t'\ u'\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{i\neq j}{\Gamma\vdash\lcvar i=\lcvar j\Rightarrow\bang_{s}\dashv\bot}\qquad\dfrac{}{\Gamma\vdash\lcvar i=\lcvar i\Rightarrow1_{\Gamma}\dashv\Gamma}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-last}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{o\neq o'\ \text{(\emph{rigid} term constructors)}}{\Gamma\vdash o(\vec{t})=o'(\vec{t'})\Rightarrow\bang_{s}\dashv\bot}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
Failure propagation (
\begin_inset Formula $\AgdaKeyword{do}$
\end_inset

 notation)
\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\bot\vdash t=u\Rightarrow\bang_{s}\dashv\bot
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unification for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-lam-same-shape"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\prunecat xy{r\dashv p}l{}}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x):>y\Rightarrow\qquad\\
P(l);M\mapsto P(r)\dashv\Gamma[P:p]
\end{array}}}{P-Flex}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-rigid}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{o\neq\rename{\dots}x}{\Gamma\prune{o(\delta)}{\arg x}{\bang_{s}}{\bang}\dashv\bot}}{P-Fail}
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\inferruletwo{\Gamma\prune{\delta}{x^{o'}}{\sigma}{\delta'}\dashv\Delta}{o=\rename{o'}x}{\Gamma\prune{o(\delta)}{\arg x}{\sigma}{o'(\delta')}\dashv\Delta}}{P-Rig}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\pruningemptyconcl
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
\Gamma\prune t{x_{0}}{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{\delta[\sigma_{1}]}x{\sigma_{2}\dashv\Delta_{2}}{\delta'}
\end{array}}{\begin{array}{r}
\Gamma\vdash t,\delta:>x_{0},x\Rightarrow\quad\\
t'[\sigma_{2}],\delta';\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}
\end{array}}}{\textsc{P-Split}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\inferruletwo{\Gamma\prune t{M_{0}(x_{0})}{\sigma_{1}}{t'}\dashv\Delta_{1}}{\Delta_{1}\prune{\delta[\sigma_{1}]}{\overrightarrow{M(x)}}{\sigma_{2}\dashv\Delta_{2}}{\delta'}}{\begin{array}{c}
\Gamma\vdash t,\delta:>M_{0}(x_{0}),\overrightarrow{M(x)}\Rightarrow\\
t'[\sigma_{2}],\delta';\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}
\end{array}}
\]

\end_inset


\begin_inset Formula $\Gamma\prune{t,\delta}{M_{0}(x_{0}),\overrightarrow{M(x)}}{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}],\delta'}\dashv\Delta_{2}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
Failure propagation (
\begin_inset Formula $\AgdaKeyword{do}$
\end_inset

 notation)
\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\bot\prune{\delta}x{\bang}{\bang}\dashv\bot
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Generic pruning 
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-no-cycle-gen"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-rigid}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{o\neq o'\ \text{(\emph{rigid} term constructors)}}{\Gamma\vdash o(\delta)=o'(\delta')\Rightarrow\bang\dashv\bot}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{\Gamma\vdash\delta=\delta'\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash o(\delta)=o(\delta')\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\unificationempty
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\unificationstepwisenovec}{U-Split}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
Failure propagation (
\begin_inset Formula $\AgdaKeyword{do}$
\end_inset

 notation)
\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\bot\vdash\delta=\delta'\Rightarrow\bang\dashv\bot
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Generic unification 
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-gen"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
An example: pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:example-lambda"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{membership}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Formula 
\[
\dfrac{}{a\in(a,\dots)}\quad\dfrac{a\in\ell}{a\in(x,\ell)}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Syntax of 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:syntax-lam"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "32text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-decl}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-metacontext}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-renamings}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-decl}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-ind}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Formula 
\[
\dfrac{1\leq i\leq n}{\dotmcontext{\Gamma};n\vdash\lcvar i}\quad\dfrac{\dotmcontext{\Gamma};n\vdash t\quad\dotmcontext{\Gamma};n\vdash u}{\dotmcontext{\Gamma};n\vdash t\ u}\quad\dfrac{\dotmcontext{\Gamma};n+1\vdash t}{\dotmcontext{\Gamma};n\vdash\lambda t}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{M:m\in\dotmcontext{\Gamma}\quad\overbrace{x\in\hom(m,n)}^{x_{1},\mydots,x_{m}\in\{1,\mydots,n\}\text{ distinct}}}{\dotmcontext{\Gamma};n\vdash M(\var{x_{1}},\mydots,\var{x_{m}})}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{}{\bot;a\vdash\bang}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "35text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaNoSpaceAroundCode{}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-app-decl}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-app-def}
\end_layout

\begin_layout Plain Layout


\backslash
AgdaSpaceAroundCode{}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaNoSpaceAroundCode{}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-lam-decl}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-lam-def}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaSpaceAroundCode{}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "33text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaNoSpaceAroundCode{}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-var-decl}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-var-def}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaSpaceAroundCode{}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "53text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-lam-decl}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-lam-def}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "53text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-var-decl}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-syntax-var-def}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider the syntax of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with pattern metavariables.
 We list the Agda code in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:syntax-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

, together with a corresponding presentation as inductive rules generating
 the syntax.
 We write 
\begin_inset Formula $\Gamma;n\vdash t$
\end_inset

 to mean 
\begin_inset Formula $t$
\end_inset

 is a well-formed 
\begin_inset Formula $\lambda$
\end_inset

-term in the context 
\begin_inset Formula $\Gamma;n$
\end_inset

, consisting of two parts:
\end_layout

\begin_layout Enumerate
a metavariable context (or 
\emph on
metacontext
\emph default
) 
\begin_inset Formula $\Gamma$
\end_inset

, which is either a formal error context 
\begin_inset Formula $\bot$
\end_inset

, or a 
\emph on
proper 
\emph default
context, as a list 
\begin_inset Formula $(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

, of metavariable declarations specifying metavariable symbols 
\begin_inset Formula $M_{i}$
\end_inset

 together with their arities, i.e, their number of arguments 
\begin_inset Formula $m_{i}$
\end_inset

;
\end_layout

\begin_layout Enumerate
a scope, which is a mere natural number indicating the highest possible
 free variable.
\end_layout

\begin_layout Standard
Free variables are indexed from 
\begin_inset Formula $1$
\end_inset

 and we use the De Bruijn level convention: the variable bound in 
\begin_inset Formula $\dotmcontext{\Gamma};n\vdash\lambda t$
\end_inset

 is 
\begin_inset Formula $\var n+1$
\end_inset

, not 
\begin_inset Formula $0$
\end_inset

, as it would be using De Bruijn indices
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DB"
literal "false"

\end_inset

.
 In Agda, variables in the scope 
\begin_inset Formula $n$
\end_inset

 consist of elements of 
\begin_inset Formula $\AgdaDatatype{Fin}\ n$
\end_inset

, the type of natural numbers between
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Formula $\AgdaDatatype{Fin}\ n$
\end_inset

 is actually defined in the standard library as an inductive type designed
 to be (canonically) isomorphic with 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The error metacontext 
\begin_inset Formula $\bot$
\end_inset

 will prove useful to handle failure in the unification algorithm.
 Traditionally, unification is presented as a partial algorithm, since unifiers
 may not exist.
 Instead of modelling partiality with some kind of error monad, we instead
 make our unification algorithm total by adding a formal error, so that
 a metacontext is either a proper metacontext or a formal error metacontext,
 and the unification algorithm either returns a proper substitution or an
 error substitution.
 Our approach to failure actually arises from the categorical semantics
 (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the inductive rules, we use the bold face 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 for any proper metacontext.
 In the Agda code, we adopt a nameless encoding of proper metacontexts:
 they are mere lists of metavariable arities, and metavariables are referred
 to by their index in the list.
 The type of metacontexts 
\begin_inset Formula $\AgdaFunction{MetaContext}$
\end_inset

 is formally defined as 
\begin_inset Formula $\AgdaDatatype{Maybe}\ (\AgdaDatatype{List}\ \mathbb{N})$
\end_inset

, where 
\begin_inset Formula $\AgdaDatatype{Maybe}\ X$
\end_inset

 is an inductive type with an error constructor 
\begin_inset Formula $\bot$
\end_inset

 and a 
\emph on
proper
\emph default
 constructor 
\begin_inset Formula $\lfloor-\rfloor$
\end_inset

 taking as argument an element of type 
\begin_inset Formula $X$
\end_inset

.
 Therefore, 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 typically translates into 
\begin_inset Formula $\lfloor\Gamma\rfloor$
\end_inset

 in the implementation.
 To alleviate notations, we also adopt a dotted convention in Agda to mean
 that a proper metacontext is involved.
 For example, 
\begin_inset Formula $\AgdaFunction{MetaContext\ensuremath{\cdot}}$
\end_inset

 and 
\begin_inset Formula $\AgdaFunction{Tm\ensuremath{\cdot}}\ \Gamma\ n$
\end_inset

 are respectively defined as 
\begin_inset Formula $\AgdaDatatype{List}\ \mathbb{N}$
\end_inset

 and 
\begin_inset Formula $\AgdaDatatype{Tm}\ \lfloor\Gamma\rfloor\ n$
\end_inset

.
 
\end_layout

\begin_layout Standard
The last term constructor 
\begin_inset Formula $\bang$
\end_inset

 builds a well-formed term in any error context 
\begin_inset Formula $\bot;n$
\end_inset

.
 We call it an 
\emph on
error
\emph default
 term: it is the only one available in such contexts.

\emph on
 Proper 
\emph default
terms, i.e., terms well-formed in a proper metacontext, are built from application
, 
\begin_inset Formula $\lambda$
\end_inset

-abstraction and variables: they generate the (proper) syntax of 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 Note that 
\begin_inset Formula $\bang$
\end_inset

 cannot occur as a sub-term of a proper term.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:non-dotted-version"

\end_inset

 The names of constructors of 
\begin_inset Formula $\lambda$
\end_inset

-calculus for application, 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, and variables, are dotted to indicate that they are only available
 in a proper metacontext.
 
\begin_inset Quotes eld
\end_inset

Improper
\begin_inset Quotes erd
\end_inset

 versions of those, defined in any metacontext, are also implemented in
 the obvious way, coinciding with the constructors in a proper context,
 or returning 
\begin_inset Formula $\bang$
\end_inset

 in the error context.
\end_layout

\begin_layout Standard
Let us focus on the penultimate constructor, building a metavariable application
 in the context 
\begin_inset Formula $\dotmcontext{\Gamma};n$
\end_inset

.
 The argument of type 
\begin_inset Formula $m\in\dotmcontext{\Gamma}$
\end_inset

 is an index of any element 
\begin_inset Formula $m$
\end_inset

 in the list 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

.
 In the pattern fragment, a metavariable of arity 
\begin_inset Formula $m$
\end_inset

 can be applied to a list of size 
\begin_inset Formula $m$
\end_inset

 consisting of distinct variables in the scope 
\begin_inset Formula $n$
\end_inset

, that is, natural numbers between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

.
 We denote by 
\begin_inset Formula $\hom(m,n)$
\end_inset

 this set of lists.
 To make the Agda implementation easier, we did not enforce the uniqueness
 restriction in the definition of 
\begin_inset Formula $\AgdaFunction{hom}\ m\ n$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
which unfolds as 
\begin_inset Formula $\AgdaDatatype{Vec}\ \AgdaSymbol{(}\AgdaDatatype{Fin}\ \AgdaBound{n}\AgdaSymbol{)}\ \AgdaBound{m}$
\end_inset

: this is the type of lists of size 
\begin_inset Formula $m$
\end_inset

 consisting of elements of 
\begin_inset Formula $\AgdaFunction{Fin}\ n$
\end_inset

, that is, natural numbers between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

.
 Note this does not fully enforce the pattern restriction: metavariable
 arguments are not required to be distinct.
\end_layout

\end_inset

 However, our unification algorithm is guaranteed to produce correct outputs
 only if this constraint is satisfied in the inputs.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{M:m\in\Gamma\quad1\leq i_{1},\dots,i_{m}\leq n\quad i_{1},\dots i_{m}\text{ distinct}}{\Gamma;n\vdash M(v_{i_{1}},\dots,v_{i_{m}})}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
To alleviate notations, a metavariable application is denoted by 
\begin_inset Formula $M(i_{1},\dots,i_{m})$
\end_inset

 instead of 
\begin_inset Formula $M(v_{i_{1}},\dots,v_{i_{m}})$
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The benefit is that there is no need to shift free variables under a 
\begin_inset Formula $\lambda$
\end_inset

, making substitution simpler.
 Whether a variable is bound or not depends on the scope.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Agda implementation of metavariable substitutions for 
\begin_inset Formula $\lambda$
\end_inset

-calculus is listed in the first box of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:subst-code"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We call a substitution 
\emph on
successful
\emph default
 if it targets a proper metacontext, 
\emph on
proper
\emph default
 if the domain is proper.
 Note that any successful substitution is proper because there is only one
 metavariable substitution 
\begin_inset Formula $1_{\bot}$
\end_inset

 from the error context: it is a formal identity substitution, targeting
 itself.
 A 
\emph on
metavariable substitution
\emph default
 
\begin_inset Formula $\sigma:\dotmcontext{\Gamma}\rightarrow\Delta$
\end_inset

 from a proper context assigns to each metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $m$
\end_inset

 in 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 a term 
\begin_inset Formula $\Delta;m\vdash\sigma_{M}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{id-renaming}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\underbrace{id}_{(1,2,\dots,n)}:n\Rightarrow n
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{compose-renamings}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{x:q\Rightarrow r\qquad y:p\Rightarrow q}{\underbrace{x\circ y}_{{\displaystyle (x_{y_{1}},\dots,x_{y_{p}})}}:p\Rightarrow r}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{wk-renamings}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{x:p\Rightarrow q}{\underbrace{\lamrenaming x}_{(x_{1},\dots,x_{p},q+1)}:p+1\Rightarrow q+1}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-renaming}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\dfrac{\Gamma;n\vdash t\qquad x:n\Rightarrow p}{\Gamma;p\vdash\rename tx}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Renaming for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:ren-lambda"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Metavariable substitution 
\begin_inset CommandInset label
LatexCommand label
name "fig:subst-code"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{dotted-substitution}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{successful-substitution}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{substitution-def}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-substitution}%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.3em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma;n\vdash t\qquad\sigma:\Gamma\rightarrow\Delta}{\Delta;n\vdash t[\sigma]}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaNoSpaceAroundCode{}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{compose-substitution-proto}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{compose-substitution-def}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaSpaceAroundCode{}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.3em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\delta:\Gamma\rightarrow\Delta\quad\sigma:\Delta\rightarrow E}{\underbrace{\delta[\sigma]}_{M\mapsto\delta_{M}[\sigma]}:\Gamma\rightarrow E}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
Generic syntax (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generic"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaNoSpaceAroundCode{}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{gen-substitution-proto}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{compose-substitution-proto}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaSpaceAroundCode{}%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{gen-substitution-def}%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma;a\vdash t\qquad\sigma:\Gamma\rightarrow\Delta}{\Delta;a\vdash t[\sigma]}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
agdacode{compose-substitution-def}%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\delta:\Gamma\rightarrow\Delta\quad\sigma:\Delta\rightarrow E}{\underbrace{\delta[\sigma]}_{M\mapsto\delta_{M}[\sigma]}:\Gamma\rightarrow E}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lift-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\xrightarrow{\sigma}\Delta}{M:m,\Gamma\xrightarrow{\lamsubst{\sigma}{M:m}}M:m,\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{composesubst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\sigma:\Gamma_{1}\rightarrow\Gamma_{2}\quad\delta:\Gamma_{2}\rightarrow\Gamma_{3}}{\underbrace{\sigma[\delta]}_{M\mapsto\sigma_{M}[\delta]}:\Gamma_{1}\rightarrow\Gamma_{3}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{wk-substitution}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\xrightarrow{\sigma}\Delta}{\Gamma\xrightarrow{\wk{\sigma}}M:m,\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{id-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\underbrace{1_{\Gamma}}_{M\mapsto M(id)}:\Gamma\rightarrow\Gamma
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{extend-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\frac{\begin{array}{c}
M:m\in\Gamma\quad\Delta;m\vdash t\\
\Gamma\backslash M\xrightarrow{\sigma}\Delta
\end{array}}{\Gamma\xrightarrow{M\mapsto t,\sigma}\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{replace-mvar}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\frac{M:m\in\Gamma\quad x:p\Rightarrow m}{\Gamma\xrightarrow{M\mapsto M(x)}\Gamma[M:p]}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lift-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\xrightarrow{\sigma}\Delta}{M:m,\Gamma\xrightarrow{\lamsubst{\sigma}{M:m}}M:m,\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Main building blocks for metavariable substitutions 
\begin_inset CommandInset label
LatexCommand label
name "fig:building-blocks-subst"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This assignment extends (through a recursive definition) to any term 
\begin_inset Formula $\dotmcontext{\Gamma};n\vdash t$
\end_inset

, yielding a term 
\begin_inset Formula $\Delta;n\vdash t[\sigma]$
\end_inset

.
 Note that the congruence cases involve improper versions of the operations
 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:non-dotted-version"
plural "false"
caps "true"
noprefix "false"

\end_inset

), as the target metacontext may not be proper.
 The base case is 
\begin_inset Formula $M(x_{1},\dots,x_{m})[\sigma]=\rename{\sigma_{M}}x,$
\end_inset

 where 
\begin_inset Formula $\rename -x$
\end_inset

 is variable renaming, defined by recursion.
 Renaming a 
\begin_inset Formula $\lambda$
\end_inset

-abstraction requires extending the renaming 
\begin_inset Formula $x:\AgdaFunction{hom}\ p\ q$
\end_inset

 to 
\begin_inset Formula $x\uparrow\ :\AgdaFunction{hom}\ (p+1)\ (q+1)$
\end_inset

 to take into account the additional bound variable 
\begin_inset Formula $\lcvar{p+1}$
\end_inset

, which is renamed to 
\begin_inset Formula $\lcvar{q+1}$
\end_inset

.
 Then, 
\begin_inset Formula $(\lambda t)\{x\}$
\end_inset

 is defined as 
\begin_inset Formula $\lambda(t\{x\uparrow\})$
\end_inset

.
 While metavariable substitutions change the metacontext of the substituted
 term, renamings change the scope.
\end_layout

\begin_layout Standard
The identity substitution 
\begin_inset Formula $1_{\dotmcontext{\Gamma}}:\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Gamma}$
\end_inset

 is defined by the term 
\begin_inset Formula $M(1,\dots,m)$
\end_inset

 for each metavariable declaration 
\begin_inset Formula $M:m\in\dotmcontext{\Gamma}$
\end_inset

.
 The composition 
\begin_inset Formula $\delta[\sigma]:\dotmcontext{\Gamma_{1}}\rightarrow\Gamma_{3}$
\end_inset

 of two substitutions 
\begin_inset Formula $\delta:\dotmcontext{\Gamma_{1}}\rightarrow\Gamma_{2}$
\end_inset

 and 
\begin_inset Formula $\sigma:\Gamma_{2}\rightarrow\Gamma_{3}$
\end_inset

 is defined as 
\begin_inset Formula $M\mapsto\delta_{M}[\sigma]$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:building-blocks-subst"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we then define the main building blocks of substitution that the algorithm
 relies on.
 We use the following notations.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
unifier
\emph default
 of two terms 
\begin_inset Formula $\Gamma;n\vdash t,u$
\end_inset

 is a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

.
 It is called successful if the underlying substitution is.
 A 
\emph on
most general unifier 
\emph default
(mgu) of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 is a unifier 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 that uniquely factors any other unifier 
\begin_inset Formula $\delta:\Gamma\rightarrow\Delta'$
\end_inset

, in the sense that there exists a unique 
\begin_inset Formula $\delta':\Delta\rightarrow\Delta'$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma[\delta']$
\end_inset

.
 The main property of pattern unification is that any pair of terms has
 a mgu (although not necessarily successful, as explained in the introduction).
 Accordingly and as it can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:type-signatures"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the 
\begin_inset Formula $\AgdaFunction{unify}$
\end_inset

 function takes two terms 
\begin_inset Formula $\Gamma;n\vdash t,u$
\end_inset

 as input and returns a record with two fields: a context 
\begin_inset Formula $\Delta$
\end_inset

, which is 
\begin_inset Formula $\bot$
\end_inset

 in case there is no successful unifier, and a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

, which is the mgu of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 (the latter property is however not explicitly enforced by the type signature).
 We denote such a situation by 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

, leaving the scope 
\begin_inset Formula $n$
\end_inset

 implicit to alleviate the notation: the symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 separates the input and the output of the unification algorithm.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:terminal-unifier"

\end_inset

Given a metacontext 
\begin_inset Formula $\Gamma$
\end_inset

, there is a single 
\emph on
terminal
\emph default
 substitution 
\begin_inset Formula $\bang_{s}:\Gamma\rightarrow\bot$
\end_inset

, which maps any metavariable to the only available term 
\begin_inset Formula $\bang$
\end_inset

 if 
\begin_inset Formula $\Gamma$
\end_inset

 is proper, or is the identity substitution 
\begin_inset Formula $1_{\bot}$
\end_inset

 otherwise.
 Any term substituted by 
\begin_inset Formula $\bang_{s}$
\end_inset

 yields the error term 
\begin_inset Formula $\bang$
\end_inset

, since it is the only one in the metacontext 
\begin_inset Formula $\bot$
\end_inset

.
 As a consequence,
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\bang_{s}:\Gamma\rightarrow\bot$
\end_inset

 is uniquely factored by any other substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 as the composition of 
\begin_inset Formula $\sigma$
\end_inset

 with 
\begin_inset Formula $\bang_{s}:\Delta\rightarrow\bot$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\bang_{s}$
\end_inset

 unifies any pair of terms.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "rem:mgus-standard"

\end_inset

Because of the additional error context, our notion of unification differs
 from the standard presentation, which is recovered by focusing only on
 successful substitutions.
 However, it follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:terminal-unifier"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that mgus in the standard setting are still mgus in our setting.
 Moreover, when there is no successful unifier, the terminal substitution
 is a mgu.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:mgus-standard"
plural "false"
caps "true"
noprefix "false"

\end_inset

 shows that we can actually get rid of the latter condition: the non-existence
 of unifiers (for example, when unifying 
\begin_inset Formula $t_{1}\ t_{2}$
\end_inset

 with 
\begin_inset Formula $\lambda u$
\end_inset

) is restated as 
\begin_inset Formula $\bang_{s}$
\end_inset

 being the mgu
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Accordingly, our implementation does not explicitly fail.
 
\end_layout

\end_inset


\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Type signatures of the functions implemented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-gen"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:type-signatures"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{substfrom}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "33text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-type}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "33text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
agdacode{prune-sigma-return-type}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AgdaNoSpaceAroundCode{}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-proto}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-sigma-proto}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaSpaceAroundCode{}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.5em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AgdaNoSpaceAroundCode{}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-flex-prototype}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unifyprototype}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-sigma-prototype}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaSpaceAroundCode{}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Let us now describe the type signature of our algorithm (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:type-signatures"
plural "false"
caps "true"
noprefix "false"

\end_inset

), which computes this mgu.
 Given two terms 
\begin_inset Formula $\Gamma;n\vdash t,u$
\end_inset

 as input, the return type 
\begin_inset Formula $\AgdaFunction{unify}$
\end_inset

 is 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{substfrom}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
agdacode{lc-unifyprototype}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

This unification function recursively inspects the structure of the given
 terms until reaching a metavariable at the top-level, as seen in the second
 box of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The last two cases handle unification of two error terms, and unification
 of two different 
\emph on
rigid
\emph default
 term constructors (application, 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, or variables), resulting in failure.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Otherwise it continues with the success return values 
\begin_inset Formula $\Delta_{1}\blacktriangleleft\sigma_{1}$
\end_inset

.
 From a mathematical point of view, we will argue that it is more convenient
 to handle failure by considering a formal error metacontext
\begin_inset Foot
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we interpret 
\begin_inset Formula $\bot$
\end_inset

 as a terminal object freely added to the category of metacontexts and substitut
ions between them.
\end_layout

\end_inset

 
\begin_inset Formula $\bot$
\end_inset

 in which the only term (in any variable context) is a formal error term
 
\begin_inset Formula $\bang$
\end_inset

, inducing a unique substitution 
\begin_inset Formula $\bang_{s}:\Gamma\rightarrow\bot$
\end_inset

, satisfying 
\begin_inset Formula $t[\bang_{s}]=\bang$
\end_inset

 for any term 
\begin_inset Formula $t$
\end_inset

, as demonstrated in the last case when unifying two different 
\emph on
rigid
\emph default
 term constructors (application, 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, or variables).
 With this extended meaning, the inductive rule for application remains
 sound, in a sense that will be clarified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Formally, failure propagation is modelled by the rule 
\begin_inset Formula $\bot\vdash t=u\Rightarrow\bang_{s}\dashv\bot$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unification of two metavariables for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-flex-flex"

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Decomposing the rules
\begin_inset Formula 
\[
\dfrac{M:m\in\Gamma\qquad\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto P(z)\dashv P:p,\Gamma\backslash M}\quad\dfrac{\begin{array}{c}
M:m,M':m'\in\Gamma\quad M\neq M'\\
\highlighted{m\prunecat xy{r\dashv p}l{}}
\end{array}}{\Gamma\vdash M(x)=M'(y)\Rightarrow M\mapsto P(l),M'\mapsto P(r)\dashv P:p,\Gamma\backslash M\backslash M'}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-unify-flex-flex-proto}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-unify-flex-flex-same}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "57col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{M:m,\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto P(z)\dashv P:p,\Gamma}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{M,M'\in\Gamma\qquad\Gamma\vdash M(x)=M'(y)\Rightarrow\sigma\dashv\Delta}{P:p,\Gamma\vdash M(x)=M'(y)\Rightarrow\lamsubst{\sigma}{P:p}\ \dashv P:p,\Delta}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{M'\in\Gamma\qquad\highlighted{m\prunecat xy{r\dashv p}l{}}}{M:m,\Gamma\vdash M(x)=M'(y)\Rightarrow\lamsubst{\sigma}{P:p}\ \dashv P:p,\Delta}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{M:m\in\Gamma\qquad\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto P(z)\dashv P:p,\Gamma\backslash M}}{Flex-eq}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-unify-flex-flex-diff}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "57col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{M:m,\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto P(z)\dashv P:p,\Gamma}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{M,M'\in\Gamma\qquad\Gamma\vdash M(x)=M'(y)\Rightarrow\sigma\dashv\Delta}{P:p,\Gamma\vdash M(x)=M'(y)\Rightarrow\lamsubst{\sigma}{P:p}\ \dashv P:p,\Delta}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{M'\in\Gamma\qquad\highlighted{m\prunecat xy{r\dashv p}l{}}}{M:m,\Gamma\vdash M(x)=M'(y)\Rightarrow\lamsubst{\sigma}{P:p}\ \dashv P:p,\Delta}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
M:m,M':m'\in\Gamma\quad M\neq M'\\
\highlighted{m\prunecat xy{r\dashv p}l{}}
\end{array}}{\begin{array}{l}
\Gamma\vdash M(x)=M'(y)\Rightarrow\\
\quad\left(\begin{array}{c}
M\mapsto P(l)\\
M'\mapsto P(r)
\end{array}\right)\dashv P:p,\Gamma\backslash M\backslash M'
\end{array}}}{Flex-neq}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
For the generic case (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generic"
plural "false"
caps "true"
noprefix "false"

\end_inset

), replace 
\begin_inset Formula $\AgdaFunction{commonPositions}$
\end_inset

 with 
\begin_inset Formula $\AgdaFunction{equalisers}$
\end_inset

 and 
\begin_inset Formula $\AgdaFunction{commonValues}$
\end_inset

 with 
\begin_inset Formula $\AgdaFunction{pullbacks}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When reaching a metavariable application 
\begin_inset Formula $M(x)$
\end_inset

 at the top-level of either term in a metacontext 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

, denoting by 
\begin_inset Formula $t$
\end_inset

 the other term, three situations must be considered:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $t$
\end_inset

 is a metavariable application 
\begin_inset Formula $M(y)$
\end_inset

;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $t$
\end_inset

 is not a metavariable application and 
\begin_inset Formula $M$
\end_inset

 occurs deeply in 
\begin_inset Formula $t$
\end_inset

;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $M$
\end_inset

 does not occur in 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\AgdaFunction{occur-check}$
\end_inset

 function returns 
\begin_inset Formula $\AgdaInductiveConstructor{Same-MVar}\ y$
\end_inset

 in the first case, 
\begin_inset Formula $\AgdaInductiveConstructor{Cycle}$
\end_inset

 in the second case, and 
\begin_inset Formula $\AgdaInductiveConstructor{No-Cycle}\ t'$
\end_inset

 in the last case, where 
\begin_inset Formula $t'$
\end_inset

 is 
\begin_inset Formula $t$
\end_inset

 but considered in the context 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 without 
\begin_inset Formula $M$
\end_inset

, denoted by 
\begin_inset Formula $\dotmcontext{\Gamma}\backslash M$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Unification of two metavariables applications 
\begin_inset Formula $M(x_{1},\dots,x_{m})$
\end_inset

 and 
\begin_inset Formula $M'(y_{1},\dots,y_{m'})$
\end_inset

 is detailed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The algorithm starts by testing whether 
\begin_inset Formula $M'$
\end_inset

 is in 
\begin_inset Formula $\Gamma\backslash M$
\end_inset

, which denotes the context 
\begin_inset Formula $\Gamma$
\end_inset

 without 
\begin_inset Formula $M$
\end_inset

.
 Note that this doesn't hold precisely when 
\begin_inset Formula $M=M'$
\end_inset

.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
We rely on the following notations.
\end_layout

\begin_layout Notation
Assume that 
\begin_inset Formula $M:m\in\Gamma$
\end_inset

.
 Then,
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\Gamma\backslash M$
\end_inset

 denotes the metacontext 
\begin_inset Formula $\Gamma$
\end_inset

 without 
\begin_inset Formula $M$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma[M:p]$
\end_inset

 replaces 
\begin_inset Formula $M:m$
\end_inset

 with is assigned 
\begin_inset Formula $M:p$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

.
\end_layout

\end_deeper
\end_inset

 
\end_layout

\begin_layout Standard
In the first case, the line 
\begin_inset Formula $\AgdaKeyword{let}\ p,z=\AgdaFunction{commonPositions}\ m\ x\ y$
\end_inset

 computes the 
\emph on
vector of common positions 
\emph default
of 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, that is, the maximal vector of (distinct) positions 
\begin_inset Formula $(z_{1},\dots,z_{p})$
\end_inset

 such that 
\begin_inset Formula $x_{\vec{z}}=y_{\vec{z}}$
\end_inset

.
 We denote
\begin_inset Foot
status open

\begin_layout Plain Layout
The similarity with the above introduced notation is no coincidence: as
 we will see (
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:equaliser-notation"
plural "false"
caps "true"
noprefix "false"

\end_inset

), both are (co)equalisers.
\end_layout

\end_inset

 such a situation by 
\begin_inset Formula $\highlighted{m\vdash x=y\Rightarrow z\dashv p}$
\end_inset

.
 The most general unifier 
\begin_inset Formula $\sigma$
\end_inset

 coincides with the identity substitution except that 
\begin_inset Formula $M:m$
\end_inset

 is replaced by a fresh metavariable 
\begin_inset Formula $P:p$
\end_inset

 in the context 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

, and 
\begin_inset Formula $\sigma$
\end_inset

 maps 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $P(z)$
\end_inset

.
 
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $x,y,z$
\end_inset

 be three distinct variables, and let us consider unification of 
\begin_inset Formula $M(x,y)$
\end_inset

 and 
\begin_inset Formula $M(z,x)$
\end_inset

.
 Given a unifier 
\begin_inset Formula $\sigma$
\end_inset

, since 
\begin_inset Formula $M(x,y)[\sigma]=\rename{\sigma_{M}}{\lcvar 1\mapsto x,\lcvar 2\mapsto y}$
\end_inset

 and 
\begin_inset Formula $M(z,x)[\sigma]=\rename{\sigma_{M}}{\lcvar 1\mapsto z,\lcvar 2\mapsto x}$
\end_inset

 must be equal, 
\begin_inset Formula $\sigma_{M}$
\end_inset

 cannot depend on the variables 
\begin_inset Formula $\lcvar 1$
\end_inset

 and 
\begin_inset Formula $\lcvar 2$
\end_inset

.
 It follows that the most general unifier is 
\begin_inset Formula $M\mapsto P$
\end_inset

, replacing 
\begin_inset Formula $M$
\end_inset

 with a fresh constant metavariable 
\begin_inset Formula $P$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This matches the recipe given above: the vector of common positions of 
\begin_inset Formula $(x,y)$
\end_inset

 and 
\begin_inset Formula $(z,x)$
\end_inset

 is indeed empty.
\end_layout

\end_inset

A similar argument shows that the most general unifier of 
\begin_inset Formula $M(x,y)$
\end_inset

 and 
\begin_inset Formula $M(z,y)$
\end_inset

 is 
\begin_inset Formula $M\mapsto P(\lcvar 2)$
\end_inset

.
\end_layout

\begin_layout Standard
The corresponding rule 
\begin_inset Formula $\refrule{Same-MVar}$
\end_inset

 does not stipulate how to generate the fresh metavariable symbol 
\begin_inset Formula $P$
\end_inset

, although there is an obvious choice, consisting in taking 
\begin_inset Formula $M$
\end_inset

 which has just been removed from the context 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

.
 Accordingly, the implementation keeps 
\begin_inset Formula $M$
\end_inset

 but changes its arity to 
\begin_inset Formula $p$
\end_inset

, resulting in a context denoted by 
\begin_inset Formula $\dotmcontext{\Gamma}[M:p]$
\end_inset

.
 
\end_layout

\begin_layout Standard
The second case tackles unification of a metavariable application with a
 term in which the metavariable occurs deeply.
 It is handled by the failing rule 
\begin_inset Formula $\refrule{Cycle}$
\end_inset

: there is no (sucessful) unifier because the size of both hand sides can
 never match after substitution.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following rule is thus more faithful with the Agda code:, and can be
 thought of as a possible implementation of 
\begin_inset Formula $\refrule{Flex-neq}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
M:m,M':m'\in\Gamma\quad M\neq M'\\
\highlighted{m\prunecat xy{r\dashv p}l{}}
\end{array}}{\Gamma\vdash M(x)=M'(y)\Rightarrow\left(\begin{array}{c}
M\mapsto M'(l)\\
M'\mapsto M'(r)
\end{array}\right)\dashv\Gamma\backslash M[M':p]}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unification with a metavariable application for 
\begin_inset Formula $\lambda$
\end_inset

-calculus 
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-flex"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-unify-flex-proto}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-unify-flex-def}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x)=M(y)\Rightarrow\qquad\\
M\mapsto P(z)\dashv\Gamma[P:p]
\end{array}}}{Same-MVar}
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang_{s}\dashv\bot}}{Cycle}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
M\notin u\quad u\neq M(\dots)\\
\Gamma\backslash M\prune ux{\sigma}w\dashv\Delta
\end{array}}{\Gamma\vdash M(x)=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}}{No-cycle}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-unify-flex-star-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "30col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "34col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-flex-no-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "65col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang_{s}\dashv\bot}}{Cycle}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
M\notin u\quad u\neq M(\dots)\\
\Gamma\backslash M\prune ux{\sigma}w\dashv\Delta
\end{array}}{\Gamma\vdash M(x)=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}}{No-cycle}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
For the generic algorithm, replace 
\begin_inset Formula $\AgdaFunction{commonPositions}$
\end_inset

 with 
\begin_inset Formula $\AgdaFunction{equaliser}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Unification of a metavariable application 
\begin_inset Formula $M(x_{1},\dots,x_{m})$
\end_inset

 with a term 
\begin_inset Formula $u$
\end_inset

 is detailed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We have just discussed the case when 
\begin_inset Formula $u$
\end_inset

 is a metavariable.
 Let us detail the other case.
 The algorithm starts by checking whether 
\begin_inset Formula $M$
\end_inset

 can be removed from the metacontext in which 
\begin_inset Formula $u$
\end_inset

 is typed.
 If not, then 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AgdaBound{u}
\backslash
AgdaSpace{}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaOperator{
\backslash
AgdaFunction{⑊?ₜ}}
\backslash
AgdaSpace{}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaBound{M}
\end_layout

\end_inset


\end_layout

\end_inset

 fails and the 
\emph on
do 
\emph default
notation propagates the error.
 This situation described by the failing rule 
\begin_inset Formula $\refrule{Cycle}$
\end_inset

 happens precisely when 
\begin_inset Formula $M$
\end_inset

 occurs in 
\begin_inset Formula $u$
\end_inset

.
 Since 
\begin_inset Formula $u$
\end_inset

 is not a metavariable, there is no unifier because the size of both hand
 sides can never match after substitution.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pattern unification for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

) 
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-full-lam"

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-prune-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}}{\begin{array}{r}
\dotmcontext{\Gamma}[M:m]\vdash M(x):>y\Rightarrow\qquad\\
P(y');M\mapsto P(x')\dashv\dotmcontext{\Gamma}[P:p]
\end{array}}}{P-Flex}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\highlighted{m\prunecat xy{r\dashv p}l{}}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x):>y\Rightarrow\qquad\\
P(l);M\mapsto P(r)\dashv\Gamma[P:p]
\end{array}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{u[\sigma_{1}]}x{\sigma_{2}}{u'}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}]\ u'}\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{u[\sigma_{1}]}x{\sigma_{2}}{u'}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}]\ u'}\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\dotmcontext{\Gamma}\prune t{x\uparrow\ }{\sigma}{t'}\dashv\Delta}{\dotmcontext{\Gamma}\prune{\lambda t}x{\sigma}{\lambda t'}\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{i\notin x}{\dotmcontext{\Gamma}\prune{\lcvar i}x{\bang_{s}}{\bang}\dashv\bot}\quad\dfrac{i=x_{j}}{\dotmcontext{\Gamma}\prune{\lcvar i}x{1_{\dotmcontext{\Gamma}}}{\lcvar j}\dashv\dotmcontext{\Gamma}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-fail}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{}{\bot\prune{\bang}x{\bang_{s}}{\bang}\dashv\bot}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-unify-flex-def}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
vspace{-1.5em}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x)=M(y)\Rightarrow\qquad\\
M\mapsto P(z)\dashv\Gamma[P:p]
\end{array}}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang_{s}\dashv\bot}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
M\notin u\quad\Gamma\backslash M\prune ux{\sigma}w\dashv\Delta\end{array}}{\Gamma\vdash M(x)=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\begin{array}{r}
\dotmcontext{\Gamma}[M:m]\vdash M(x)=M(y)\Rightarrow\qquad\\
M\mapsto P(z)\dashv\dotmcontext{\Gamma}[P:p]
\end{array}}}{Same-MVar}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\in t\qquad t\neq M(\dots)}{\dotmcontext{\Gamma},M:m\vdash M(x)=t\Rightarrow\bang_{s}\dashv\bot}}{Cycle}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.2em}
\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
M\notin t\quad\dotmcontext{\Gamma}\backslash M\prune tx{\sigma}{t'}\dashv\Delta\end{array}}{\dotmcontext{\Gamma}\vdash M(x)=t\Rightarrow M\mapsto t',\sigma\dashv\Delta}}{No-cycle}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset

(+ symmetric rules)
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x)=M(y)\Rightarrow\qquad\\
M\mapsto P(z)\dashv\Gamma[P:p]
\end{array}}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang_{s}\dashv\bot}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
M\notin u\quad\Gamma\backslash M\prune ux{\sigma}w\dashv\Delta\end{array}}{\Gamma\vdash M(x)=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
+ symmetric rules
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1.5em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma_{1}\dashv\Delta_{1}\\
\dotmcontext{\Gamma}\vdash u[\sigma_{1}]=u'[\sigma_{2}]\Rightarrow\sigma_{2}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\vdash t\ u=t'\ u'\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma\dashv\Delta}{\dotmcontext{\Gamma}\vdash\lambda t=\lambda t'\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{i\neq j}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar j\Rightarrow\bang_{s}\dashv\bot}\qquad\dfrac{}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar i\Rightarrow1_{\Gamma}\dashv\dotmcontext{\Gamma}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-last}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Formula $\dfrac{}{\bot\vdash\bang=\bang\Rightarrow\bang_{s}\dashv\bot}\quad\dfrac{o\neq o'\ \text{(\emph{rigid} term constructors)}}{\dotmcontext{\Gamma}\vdash o(\vec{t})=o'(\vec{t'})\Rightarrow\bang_{s}\dashv\bot}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "54text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-prune-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula $\labellabelrule{\dfrac{\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}}{\begin{array}{r}
\dotmcontext{\Gamma}[M:m]\vdash M(x):>y\Rightarrow\qquad\\
P(y');M\mapsto P(x')\dashv\dotmcontext{\Gamma}[P:p]
\end{array}}}{P-Flex}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-fail}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{}{\bot\prune{\bang}x{\bang_{s}}{\bang}\dashv\bot}}{P-Fail}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "30col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}}{\begin{array}{r}
\dotmcontext{\Gamma}[M:m]\vdash M(x):>y\Rightarrow\qquad\\
P(y');M\mapsto P(x')\dashv\dotmcontext{\Gamma}[P:p]
\end{array}}}{P-Flex}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\highlighted{m\prunecat xy{r\dashv p}l{}}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x):>y\Rightarrow\qquad\\
P(l);M\mapsto P(r)\dashv\Gamma[P:p]
\end{array}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{u[\sigma_{1}]}x{\sigma_{2}}{u'}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}]\ u'}\dashv\Delta_{2}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\dotmcontext{\Gamma}\prune t{x\uparrow\ }{\sigma}{t'}\dashv\Delta}{\dotmcontext{\Gamma}\prune{\lambda t}x{\sigma}{\lambda t'}\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{i\notin x}{\dotmcontext{\Gamma}\prune{\lcvar i}x{\bang_{s}}{\bang}\dashv\bot}\quad\dfrac{i=x_{j}}{\dotmcontext{\Gamma}\prune{\lcvar i}x{1_{\dotmcontext{\Gamma}}}{\lcvar j}\dashv\dotmcontext{\Gamma}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "30col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-app}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{u[\sigma_{1}]}x{\sigma_{2}}{u'}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}]\ u'}\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "28col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\dfrac{\dotmcontext{\Gamma}\prune t{x\uparrow\ }{\sigma}{t'}\dashv\Delta}{\dotmcontext{\Gamma}\prune{\lambda t}x{\sigma}{\lambda t'}\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "25col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-var}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\dfrac{i\notin x}{\dotmcontext{\Gamma}\prune{\lcvar i}x{\bang_{s}}{\bang}\dashv\bot}\quad\dfrac{i=x_{j}}{\dotmcontext{\Gamma}\prune{\lcvar i}x{1_{\dotmcontext{\Gamma}}}{\lcvar j}\dashv\dotmcontext{\Gamma}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "43text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-flex}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{lc-unify-flex-def}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "55text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x)=M(y)\Rightarrow\qquad\\
M\mapsto P(z)\dashv\Gamma[P:p]
\end{array}}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang_{s}\dashv\bot}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
M\notin u\quad\Gamma\backslash M\prune ux{\sigma}w\dashv\Delta\end{array}}{\Gamma\vdash M(x)=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\begin{array}{r}
\dotmcontext{\Gamma}[M:m]\vdash M(x)=M(y)\Rightarrow\qquad\\
M\mapsto P(z)\dashv\dotmcontext{\Gamma}[P:p]
\end{array}}}{Same-MVar}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\in t\qquad t\neq M(\dots)}{\dotmcontext{\Gamma},M:m\vdash M(x)=t\Rightarrow\bang_{s}\dashv\bot}}{Cycle}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.2em}
\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
M\notin t\quad\dotmcontext{\Gamma}\backslash M\prune tx{\sigma}{t'}\dashv\Delta\end{array}}{\dotmcontext{\Gamma}\vdash M(x)=t\Rightarrow M\mapsto t',\sigma\dashv\Delta}}{No-cycle}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset

(+ symmetric rules)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-2em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "51text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma_{1}\dashv\Delta_{1}\\
\Delta_{1}\vdash u[\sigma_{1}]=u'[\sigma_{2}]\Rightarrow\sigma_{2}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\vdash t\ u=t'\ u'\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Formula $\dfrac{\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma\dashv\Delta}{\dotmcontext{\Gamma}\vdash\lambda t=\lambda t'\Rightarrow\sigma\dashv\Delta}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{i\neq j}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar j\Rightarrow\bang_{s}\dashv\bot}\qquad\dfrac{}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar i\Rightarrow1_{\Gamma}\dashv\dotmcontext{\Gamma}}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "28col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "30col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma_{1}\dashv\Delta_{1}\\
\Delta_{1}\vdash u[\sigma_{1}]=u'[\sigma_{2}]\Rightarrow\sigma_{2}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\vdash t\ u=t'\ u'\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma\dashv\Delta}{\dotmcontext{\Gamma}\vdash\lambda t=\lambda t'\Rightarrow\sigma\dashv\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{i\neq j}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar j\Rightarrow\bang_{s}\dashv\bot}\qquad\dfrac{}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar i\Rightarrow1_{\Gamma}\dashv\dotmcontext{\Gamma}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "33col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-app}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma_{1}\dashv\Delta_{1}\\
\dotmcontext{\Gamma}\vdash u[\sigma_{1}]=u'[\sigma_{2}]\Rightarrow\sigma_{2}\dashv\Delta_{2}
\end{array}}{\dotmcontext{\Gamma}\vdash t\ u=t'\ u'\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "28col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\dfrac{\dotmcontext{\Gamma}\vdash t=t'\Rightarrow\sigma\dashv\Delta}{\dotmcontext{\Gamma}\vdash\lambda t=\lambda t'\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "30col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-var}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\dfrac{i\neq j}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar j\Rightarrow\bang_{s}\dashv\bot}\qquad\dfrac{}{\dotmcontext{\Gamma}\vdash\lcvar i=\lcvar i\Rightarrow1_{\Gamma}\dashv\dotmcontext{\Gamma}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-3.3em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "20col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-bot}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "20col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-last}%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{\ensuremath{\labellabelrule{\dfrac{}{\bot\vdash\bang=\bang\Rightarrow\bang_{s}\dashv\bot}}{U-Fail}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{\ensuremath{\dfrac{o\neq o'\ \text{(\emph{rigid} term constructors)}}{\dotmcontext{\Gamma}\vdash o(\vec{t})=o'(\vec{t'})\Rightarrow\bang_{s}\dashv\bot}}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-bot}%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1.2em}
\end_layout

\end_inset


\begin_inset Formula 
\[
\text{\ensuremath{\labellabelrule{\dfrac{}{\bot\vdash\bang=\bang\Rightarrow\bang_{s}\dashv\bot}}{U-Fail}}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.3em}
\end_layout

\begin_layout Plain Layout

%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-last}%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Formula $\text{\dfrac{o\neq o'\ \text{(\emph{rigid} term constructors)}}{\dotmcontext{\Gamma}\vdash o(\vec{t})=o'(\vec{t'})\Rightarrow\bang_{s}\dashv\bot}}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
Failure propagation (
\begin_inset Formula $\AgdaKeyword{do}$
\end_inset

 notation)
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\bot\prune tx{\bang}{\bang}\dashv\bot\quad\bot\vdash t=u\Rightarrow\bang\dashv\bot$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Our generic pattern unification algorithm 
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-full-gen"

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
Same as the rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hspace{-0.6em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "53col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0em}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "47col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-fail}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Same as the rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Same as the rule 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-rigid}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{o\neq\rename{\dots}x}{\dotmcontext{\Gamma}\prune{o(\delta)}{\arg x}{\bang_{s}}{\bang}\dashv\bot}}{P-Rig-Fail}
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\inferruletwo{\dotmcontext{\Gamma}\prune{\delta}{x^{o'}}{\sigma}{\delta'}\dashv\Delta}{o=\rename{o'}x}{\dotmcontext{\Gamma}\prune{o(\delta)}{\arg x}{\sigma}{o'(\delta')}\dashv\Delta}}{P-Rig}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-fail}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{}{\bot\prune{\bang}x{\bang_{s}}{\bang}\dashv\bot}}{P-Fail}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{}{\pruningemptyconcl}}{P-Empty}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
\Gamma\prune t{x_{0}}{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{\delta[\sigma_{1}]}x{\sigma_{2}\dashv\Delta_{2}}{\delta'}
\end{array}}{\begin{array}{r}
\Gamma\vdash t,\delta:>x_{0},x\Rightarrow\quad\\
t'[\sigma_{2}],\delta';\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}
\end{array}}}{\textsc{P-Split}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\inferruletwo{\Gamma\prune t{M_{0}(x_{0})}{\sigma_{1}}{t'}\dashv\Delta_{1}}{\Delta_{1}\prune{\delta[\sigma_{1}]}{\overrightarrow{M(x)}}{\sigma_{2}\dashv\Delta_{2}}{\delta'}}{\begin{array}{c}
\Gamma\vdash t,\delta:>M_{0}(x_{0}),\overrightarrow{M(x)}\Rightarrow\\
t'[\sigma_{2}],\delta';\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}
\end{array}}
\]

\end_inset


\begin_inset Formula $\Gamma\prune{t,\delta}{M_{0}(x_{0}),\overrightarrow{M(x)}}{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}],\delta'}\dashv\Delta_{2}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula $\AgdaFunction{unify-flex-*}$
\end_inset

 is defined as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

, replacing 
\begin_inset Formula $\AgdaFunction{commonPositions}$
\end_inset

 with 
\begin_inset Formula $\AgdaFunction{equaliser}$
\end_inset

, but note that it now calls the above 
\begin_inset Formula $\AgdaFunction{prune}$
\end_inset

 function instead of the one for 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout

%
\backslash
agdacode{unify-flex-def}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0em}
\end_layout

\end_inset

See the rules 
\begin_inset Formula $\refrule{Same-MVar}$
\end_inset

, 
\begin_inset Formula $\refrule{Cycle}$
\end_inset

, and 
\begin_inset Formula $\refrule{No-Cycle}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\align left
\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\begin{array}{r}
\Gamma[M:m]\vdash M(x)=M(y)\Rightarrow\qquad\\
M\mapsto P(z)\dashv\Gamma[P:p]
\end{array}}}{Same-MVar}
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang_{s}\dashv\bot}}{Cycle}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
M\notin u\quad u\neq M(\dots)\\
\Gamma\backslash M\prune ux{\sigma}w\dashv\Delta
\end{array}}{\Gamma\vdash M(x)=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}}{No-cycle}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5em}
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "49text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-rigid}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{o\neq o'}{\dotmcontext{\Gamma}\vdash o(\delta)=o'(\delta')\Rightarrow\bang_{s}\dashv\bot}}{Clash}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\dotmcontext{\Gamma}\vdash\delta=\delta'\Rightarrow\sigma\dashv\Delta}{\dotmcontext{\Gamma}\vdash o(\delta)=o(\delta')\Rightarrow\sigma\dashv\Delta}}{U-Rig}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40text%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-fail}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
Same as the rule 
\begin_inset Formula $\refrule{U-Fail}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "51col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
vspace{-0.5em}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{unify-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\unificationempty}{U-Empty}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\unificationstepwisenovec}{U-Split}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1em}
\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{}{\bot\vdash1_{\bot}=1_{\bot}\Rightarrow\bang_{s}\dashv\bot}}{U-Id-Fail}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
Failure propagation (
\begin_inset Formula $\AgdaKeyword{do}$
\end_inset

 notation)
\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\labellabelrule{\dfrac{}{\bot\prune{\delta}x{\bang}{\bang}\dashv\bot}}{U-Fail}$
\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{}{\bot\vdash\delta=\delta'\Rightarrow\bang\dashv\bot}}{P-Fail}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The last case described by the rule 
\begin_inset Formula $\refrule{No-cycle}$
\end_inset

 is unification of 
\begin_inset Formula $M(x)$
\end_inset

 with a term 
\begin_inset Formula $t$
\end_inset

 in which 
\begin_inset Formula $M$
\end_inset

 does not occur.
 This kind of unification problem is handled specifically by a previously
 defined function 
\begin_inset Formula $\AgdaFunction{prune}$
\end_inset

, which we now describe.
 The intuition is that 
\begin_inset Formula $M(x)$
\end_inset

 and 
\begin_inset Formula $t$
\end_inset

 should be unified by replacing 
\begin_inset Formula $M$
\end_inset

 with 
\begin_inset Formula $t[x_{i}\mapsto\var i]$
\end_inset

.
 However, this only makes sense if the free variables of 
\begin_inset Formula $t$
\end_inset

 are in 
\begin_inset Formula $x$
\end_inset

.
 For example, if 
\begin_inset Formula $t$
\end_inset

 is a variable that does not occur in 
\begin_inset Formula $x$
\end_inset

, then obviously there is no unifier.
 Nonetheless, it is possible to prune the 
\emph on
outbound
\emph default
 variables in 
\begin_inset Formula $t$
\end_inset

 as long as they only occur in metavariable arguments, by restricting the
 arities of those metavariables.
 As an example, if 
\begin_inset Formula $t$
\end_inset

 is a metavariable application 
\begin_inset Formula $N(x,y)$
\end_inset

, then although the free variables are not all included in 
\begin_inset Formula $x$
\end_inset

, the most general unifier still exists, essentially replacing 
\begin_inset Formula $N$
\end_inset

 with 
\begin_inset Formula $M$
\end_inset

, discarding the outbound variable 
\begin_inset Formula $y$
\end_inset

.
 
\end_layout

\begin_layout Standard
The pruning phase runs in the metacontext with 
\begin_inset Formula $M$
\end_inset

 removed.
 We use the notation 
\begin_inset Formula $\Gamma\prune tx{\sigma\dashv\Delta}{t'}$
\end_inset

, where 
\begin_inset Formula $t$
\end_inset

 is a term in the metacontext 
\begin_inset Formula $\Gamma$
\end_inset

, while 
\begin_inset Formula $x$
\end_inset

 is the argument of the metavariable whose arity 
\begin_inset Formula $m$
\end_inset

 is left implicit, as well as its (irrelevant) name.
 The output is a metacontext 
\begin_inset Formula $\Delta$
\end_inset

, together with a term 
\begin_inset Formula $t'$
\end_inset

 in context 
\begin_inset Formula $\Delta;m$
\end_inset

, and a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

.
 If 
\begin_inset Formula $\Gamma$
\end_inset

 is proper, this is precisely the data for the most general unifier of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $M(x)$
\end_inset

, considered in the extended metacontext 
\begin_inset Formula $M:m,\Gamma$
\end_inset

.
 Following the above pruning intuition, 
\begin_inset Formula $t'$
\end_inset

 is the term 
\begin_inset Formula $t$
\end_inset

 where the outbound variables have been pruned, in case of success.
\begin_inset Note Note
status open

\begin_layout Plain Layout
A priori, this only make sense if 
\begin_inset Formula $\Gamma$
\end_inset

 is dotted, but we can easily extend the meaning by defining
\begin_inset Foot
status open

\begin_layout Plain Layout
This is motivated by the fact that context extensions are characterised
 as coproducts with singleton contexts in the category of metacontexts and
 substitutions between them.
\end_layout

\end_inset

 
\begin_inset Formula $M:m,\bot$
\end_inset

 as 
\begin_inset Formula $\bot$
\end_inset

, and this metavariable application 
\begin_inset Formula $M(x)$
\end_inset

 can still be defined in 
\begin_inset Formula $M:m,\bot$
\end_inset

 as 
\begin_inset Formula $\bang$
\end_inset

.
 Even if 
\begin_inset Formula $\Gamma=\bot$
\end_inset

, the data for a substitution from 
\begin_inset Formula $M:m,\Gamma$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

 is equivalently given by a term 
\begin_inset Formula $\Delta;m\vdash t'$
\end_inset

 for substituting 
\begin_inset Formula $M$
\end_inset

, and a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

.
\end_layout

\end_inset

 This justifies the type signature of the 
\begin_inset Formula $\AgdaFunction{prune}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:type-signatures"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 This function recursively inspects its argument.
 The base metavariable case corresponds to unification of 
\begin_inset Formula $M(x)$
\end_inset

 and 
\begin_inset Formula $M'(y)$
\end_inset

 where 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $M'$
\end_inset

 are distinct metavariables.
 In this case, the line 
\begin_inset Formula $\AgdaKeyword{let}\ p,x',y'=\AgdaFunction{commonValues}\ m\ x\ y$
\end_inset

 computes the vectors of 
\emph on
common value positions 
\emph default

\begin_inset Formula $(x_{1}',\dots,x_{p}')$
\end_inset

 and 
\begin_inset Formula $(y_{1}',\dots,y'_{p})$
\end_inset

 between 
\begin_inset Formula $x_{1},\dots,x_{m}$
\end_inset

 and 
\begin_inset Formula $y_{1},\dots,y_{m'}$
\end_inset

, i.e., the pair of maximal lists 
\begin_inset Formula $(\vec{x'},\vec{y'})$
\end_inset

 of distinct positions such that 
\begin_inset Formula $x_{\vec{x'}}=y_{\vec{y'}}$
\end_inset

.
 We denote
\begin_inset Foot
status open

\begin_layout Plain Layout
The similarity with the notation for the pruning phase is no coincidence:
 both can be interpreted as pullbacks (or pushouts), as we will see in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:pushout-notation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 such a situation by 
\begin_inset Formula $\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}$
\end_inset

.
 The most general unifier 
\begin_inset Formula $\sigma$
\end_inset

 coincides with the identity substitution except that the metavariables
 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $M'$
\end_inset

 are removed from the context and replaced by a single metavariable declaration
 
\begin_inset Formula $P:p$
\end_inset

.
 Then, 
\begin_inset Formula $\sigma$
\end_inset

 maps 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $P(x')$
\end_inset

 and 
\begin_inset Formula $M'$
\end_inset

 to 
\begin_inset Formula $P(y')$
\end_inset

.
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $x,y,z$
\end_inset

 be three distinct variables.
 The most general unifier of 
\begin_inset Formula $M(x,y)$
\end_inset

 and 
\begin_inset Formula $N(z,x)$
\end_inset

 is 
\begin_inset Formula $M\mapsto N'(\var 1),N\mapsto N'(\var 2)$
\end_inset

.
 The most general unifier of 
\begin_inset Formula $M(x,y)$
\end_inset

 and 
\begin_inset Formula $N(z)$
\end_inset

 is 
\begin_inset Formula $M\mapsto N',N\mapsto N'$
\end_inset

.
\end_layout

\begin_layout Standard
As for the rule 
\begin_inset Formula $\refrule{Same-Var}$
\end_inset

, the corresponding rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 does not stipulate how to generate the fresh metavariable symbol 
\begin_inset Formula $P$
\end_inset

, although the implementation makes an obvious choice, reusing the name
 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
The intuition for the application case is that if we want to unify 
\begin_inset Formula $M(x)$
\end_inset

 with 
\begin_inset Formula $t\ u$
\end_inset

, we can refine 
\begin_inset Formula $M(x)$
\end_inset

 to be 
\begin_inset Formula $M_{1}(x)\ M_{2}(x)$
\end_inset

, where 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 are two fresh metavariables to be unified with 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

.
 Assume that those two unification problems yield 
\begin_inset Formula $t'$
\end_inset

 and 
\begin_inset Formula $u'$
\end_inset

 as replacements for 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

, as well as substitution 
\begin_inset Formula $\sigma_{1}$
\end_inset

 and 
\begin_inset Formula $\sigma_{2}$
\end_inset

, then 
\begin_inset Formula $M$
\end_inset

 should be replaced accordingly with 
\begin_inset Formula $t'[\sigma_{2}]\ u'$
\end_inset

.
 Note that this really involves improper application, taking into account
 the following three subcases at once.
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\dotmcontext{\Delta_{1}}\\
\dotmcontext{\Delta_{1}}\prune{u[\sigma_{1}]}x{\sigma_{2}}{u'}\dashv\dotmcontext{\Delta_{2}}
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\sigma_{1}[\sigma_{2}]}{t'[\sigma_{2}]\ u'}\dashv\dotmcontext{\Delta_{2}}}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\sigma_{1}}{t'}\dashv\dotmcontext{\Delta_{1}}\\
\dotmcontext{\Delta_{1}}\prune{u[\sigma_{1}]}x{\bang_{s}}{\bang}\dashv\bot
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\bang_{s}}{\bang}\dashv\bot}\quad\dfrac{\begin{array}{c}
\dotmcontext{\Gamma}\prune tx{\bang_{s}}{\bang}\dashv\bot\\
\bot\prune{\bang}x{\bang_{s}}{\bang}\dashv\bot
\end{array}}{\dotmcontext{\Gamma}\prune{t\ u}x{\bang_{s}}{\bang}\dashv\bot}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Generalised binding signatures in Agda
\begin_inset CommandInset label
LatexCommand label
name "fig:sig-agda"

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "65col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
begin{AgdaAlign}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{signature-core}
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{signature-functoriality}
\end_layout

\begin_layout Plain Layout


\backslash
end{AgdaAlign}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "34col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{renaming-vectors}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The same intuition applies for 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, but here we apply the fresh metavariable corresponding to
 the body of the 
\begin_inset Formula $\lambda$
\end_inset

-abstraction to the bound variable 
\begin_inset Formula $\var{n+1}$
\end_inset

, which needs not be pruned.
 In the variable case, 
\begin_inset Formula $i\{x\}^{-1}$
\end_inset

 returns the index 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $i=x_{j}$
\end_inset

, or fails if no such 
\begin_inset Formula $j$
\end_inset

 exist.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
This ends our description of the unification algorithm, in the specific
 case of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The purpose of this work is to present a generalisation, parameterising
 the algorithm by a signature specifying a syntax.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Assume 
\begin_inset Formula $M$
\end_inset

 indeed appears at the top level in 
\begin_inset Formula $u$
\end_inset

, then the most general unifier replaces 
\begin_inset Formula $M$
\end_inset

 with a new metavariable whose arity is the number of common variables positions
 in both hand sides.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generalisation
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:intro-generic"

\end_inset

In this section, we show how to abstract over 
\begin_inset Formula $\lambda$
\end_inset

-calculus to get a generic algorithm for pattern unification, parameterised
 by our new notion of specification to account for syntax with metavariables.
 We split this notion in two parts: 
\end_layout

\begin_layout Enumerate
a notion of generalised binding signature, or GB-signature (formally introduced
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:GB-signature"
plural "false"
caps "true"
noprefix "false"

\end_inset

), specifying a syntax with metavariables, for which unification problems
 can be stated; 
\end_layout

\begin_layout Enumerate
some additional structures used in the algorithm to solve those unification
 problems, as well as properties ensuring its correctness, making the GB-signatu
re 
\emph on
pattern-friendly
\emph default
 (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:pattern-friendly"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Syntax generated by a GB-signature
\begin_inset CommandInset label
LatexCommand label
name "fig:sig-syntax"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{metacontext}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{syntax-decl}%
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "65col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{syntax-def}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{o\in O(a)\quad\overbrace{\dotmcontext{\Gamma};\nthar o1\vdash t_{1}\quad\dots\quad\Gamma;\nthar on\vdash t_{n}}^{"\alpha_{o}\xrightarrow{\vec{t}}\Gamma"}}{\dotmcontext{\Gamma};a\vdash o(t_{1},\dots,t_{n})}}{Rig}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M:m\in\dotmcontext{\Gamma}\quad x\in\hom_{{\cal A}}(m,a)}{\dotmcontext{\Gamma};a\vdash M(x)}}{Flex}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{}{\bot;n\vdash\bang}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{metacontext}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{syntax-decl}%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{syntax-def}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{o\in O(a)\quad\overbrace{\dotmcontext{\Gamma};\nthar o1\vdash t_{1}\quad\dots\quad\Gamma;\nthar on\vdash t_{n}}^{"\alpha_{o}\xrightarrow{\vec{t}}\Gamma"}}{\dotmcontext{\Gamma};a\vdash o(t_{1},\dots,t_{n})}}{Rig}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M:m\in\dotmcontext{\Gamma}\quad x\in\hom_{{\cal A}}(m,a)}{\dotmcontext{\Gamma};a\vdash M(x)}}{Flex}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{}{\bot;n\vdash\bang}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

This separation is motivated by the fact that in the case of 
\begin_inset Formula $\lambda$
\end_inset

-calculus, the vectors of common (value) positions 
\begin_inset Note Note
status open

\begin_layout Plain Layout
as well as inverse renaming 
\begin_inset Formula $-\{-\}^{-1}$
\end_inset

 of variables 
\end_layout

\end_inset

are involved in the algorithm, but not in the definition of the syntax and
 associated operations (renaming, metavariable substitution).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Let us first focus on the notion of GB-signature, starting from binding
 signatures
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "aczel2016general"
literal "false"

\end_inset

: the latter consist in a set of operation symbols, and for each 
\begin_inset Formula $o\in O$
\end_inset

, an arity 
\begin_inset Formula $\ntharvec o=(\nthar o1,\dots,\nthar on)$
\end_inset

, i.e., a list of natural numbers specifying how many variables are bound
 in each argument.
 For example, pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus is specified by 
\begin_inset Formula $O=\{abs,app\}$
\end_inset

, with 
\begin_inset Formula $\ntharvec{app}=(0,0)$
\end_inset

, 
\begin_inset Formula $\ntharvec{abs}=(1)$
\end_inset

.
 Now, 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A GB-signature consists in a tuple 
\begin_inset Formula $({\cal A},O,\ntharvecfunct)$
\end_inset

 consisting of 
\end_layout

\begin_layout Itemize
a small category 
\begin_inset Formula ${\cal A}$
\end_inset

 whose objects are called 
\emph on
arities
\shape italic
\emph default
 
\emph on
or
\emph default
 scopes
\emph on
,
\shape default
\emph default
 and whose morphisms are called 
\shape italic
patterns 
\emph on
or
\emph default
 renamings
\shape default
;
\end_layout

\begin_layout Itemize
for each variable context 
\begin_inset Formula $a$
\end_inset

, a set of operation symbols 
\begin_inset Formula $O(a)$
\end_inset

;
\end_layout

\begin_layout Itemize
for each operation symbol 
\begin_inset Formula $o\in O(a)$
\end_inset

, a list of scopes 
\begin_inset Formula $\ntharvec o=(\nthar o1,\dots,\nthar on)$
\end_inset

.
\end_layout

\begin_layout Standard
such that 
\begin_inset Formula $O$
\end_inset

 and 
\begin_inset Formula $\ntharvecfunct$
\end_inset

 are functorial in a suitable sense (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:bgsig-functorial"
plural "false"
caps "true"
noprefix "false"

\end_inset

 below).
 
\end_layout

\begin_layout Remark
This definition of GB-signatures superficially differs from the notion of
 specification that we mention in the introduction, in the sense that here
 the endofunctor is implicit.
 Moreover, the set of operation symbols 
\begin_inset Formula $O(a)$
\end_inset

 in a scope 
\begin_inset Formula $a$
\end_inset

 is not indexed by natural numbers.
 The two descriptions are equivalent: 
\begin_inset Formula $\Oop na$
\end_inset

 is recovered as the subset of 
\begin_inset Formula $n$
\end_inset

-ary operation symbols in 
\begin_inset Formula $O(a)$
\end_inset

, and conversely, 
\begin_inset Formula $O(a)$
\end_inset

 is recovered as the union of all the 
\begin_inset Formula $\Oop na$
\end_inset

 for every natural number 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Example
We give the signature for pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 As explained in the introduction, we take 
\begin_inset Formula ${\cal A}=\mathbb{F}_{m}$
\end_inset

.
 In the scope 
\begin_inset Formula $n$
\end_inset

 we have 
\begin_inset Formula $n$
\end_inset

 nullary available operation symbols (one for each variable), one unary
 operation 
\begin_inset Formula $abs^{n}$
\end_inset

, and one binary operation 
\begin_inset Formula $app^{n}$
\end_inset

, so that 
\begin_inset Formula $O(n)=\{1,\dots n,abs^{n},app^{n}\}$
\end_inset

, with associated arities 
\begin_inset Formula $\alpha_{i}=()$
\end_inset

, 
\begin_inset Formula $\alpha_{abs^{n}}=(n+1)$
\end_inset

 and 
\begin_inset Formula $\alpha_{app^{n}}=(n,n)$
\end_inset

.
 The corresponding Agda implementation can be found in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:lc-sig-implem"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:lc-sig-implem"

\end_inset

Implementation of the signature of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
agdacode{lc-sig}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Note Note
status open

\begin_layout Plain Layout
and take as endofunctor In the scope 
\begin_inset Formula $n$
\end_inset

, we have 
\begin_inset Formula $n$
\end_inset

 nullary available operation symbols – one for each variable – so that 
\begin_inset Formula $\Oop 0n=\{1,\dots,n\}$
\end_inset

, one unary operation 
\begin_inset Formula $O_{1}(n)=\{\lambda^{n}\}$
\end_inset

 and one binary operation 
\begin_inset Formula $O_{2}(n)=\{a^{n}\}$
\end_inset

 with associated arities 
\begin_inset Formula $\nthar{\lambda_{1}^{n}}{}=n+1$
\end_inset

 and 
\begin_inset Formula $\nthar{a_{1}^{n}}{}=\nthar{a_{2}^{n}}{}=n$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Intuitively, 
\begin_inset Formula $O(a)$
\end_inset

 is the set of operation symbols available in the scope 
\begin_inset Formula $a$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Agda implementation in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:sig-agda"
plural "false"
caps "true"
noprefix "false"

\end_inset

 does not include properties such as associativity of morphism composition,
 although they are assumed in the proof of correctness.
 For example, the latter associativity property ensures that composition
 of metavariable substitutions is associative.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:gbsig-bsig"

\end_inset

Binding signatures can be compiled into GB-signatures.
 More specifically, a syntax specified by a binding signature 
\begin_inset Formula $(O,\alpha)$
\end_inset

 is also generated by the GB-signature 
\begin_inset Formula $(\mathbb{F}_{m},O',\nthaarvecfunct$
\end_inset

), where
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 is the category of finite cardinals and injections between them;
\end_layout

\begin_layout Itemize
\begin_inset Formula $O'(p)=\{\lcvar 1,\dots,\lcvar p\}\sqcup\{o_{p}|o\in O\}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\nthaarvec{\lcvar i}=()$
\end_inset

 and 
\begin_inset Formula $\nthaarvec{o_{p}}=(p+\nthar o1,\dots,p+\nthar on)$
\end_inset

 for any 
\begin_inset Formula $i,p\in\mathbb{N}$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

-ary operation symbol 
\begin_inset Formula $o\in O$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Note that, contrary to binding signatures, variables 
\begin_inset Formula $\lcvar i$
\end_inset

 are explicitly specified as nullary operations
\begin_inset Note Note
status open

\begin_layout Plain Layout
and thus do not require a dedicated generating rule, contrary to what happens
 with binding signatures
\end_layout

\end_inset

.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The choice of renamings (i.e., morphisms in the category of arities) is motivated
 by the 
\begin_inset Formula $\refrule{Flex}$
\end_inset

 rule.
 Indeed, if 
\begin_inset Formula $M$
\end_inset

 has arity 
\begin_inset Formula $m\in\mathbb{N}$
\end_inset

, then a choice of arguments in the scope 
\begin_inset Formula $a\in\mathbb{N}$
\end_inset

 consists of a list of distinct variables in the scope 
\begin_inset Formula $a$
\end_inset

, or equivalently, an injection between the cardinal sets 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $a$
\end_inset

, that is, a morphism in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 between 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We will call an element of 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

 an 
\emph on

\begin_inset Formula $o$
\end_inset

-index.

\emph default
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax specified by a GB-signature 
\begin_inset Formula $({\cal A},O,\ntharvecfunct)$
\end_inset

 is inductively defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:sig-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

, where a context 
\begin_inset Formula $\Gamma;a$
\end_inset

 is defined as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for 
\begin_inset Formula $\lambda$
\end_inset

-calculus, except that scopes and metavariable types are objects of 
\begin_inset Formula ${\cal A}$
\end_inset

 instead of natural numbers.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We indeed recover the syntax of 
\begin_inset Formula $\lambda$
\end_inset

-calculus of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:syntax-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

 by considering the GB-signature generated by the binding signature of 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "ex:gbsig-bsig"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We call a term 
\emph on
rigid 
\emph default
if it is of the shape 
\begin_inset Formula $o(\dots)$
\end_inset

, 
\emph on
flexible
\emph default
 if it is some metavariable application 
\begin_inset Formula $M(\dots)$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:arg-op-subst"

\end_inset

Recall that the Agda code uses a nameless convention for metacontexts: they
 are just lists of scopes.
 Therefore, the arity 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\alpha_{o}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 of an operation 
\begin_inset Formula $o$
\end_inset

 can be considered as a metacontext.
 It follows that the argument of an operation 
\begin_inset Formula $o$
\end_inset

 in the context 
\begin_inset Formula $\dotmcontext{\Gamma};a$
\end_inset

 can be specified either as a metavariable substitution (defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:subst-code"
plural "false"
caps "true"
noprefix "false"

\end_inset

) from 
\begin_inset Formula $\alpha_{o}=(\nthar o1,\dots,\nthar on)$
\end_inset

 to 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

, as in the Agda code, or explicitly as a list of terms 
\begin_inset Formula $(t_{1},\dots,t_{n})$
\end_inset

 such that 
\begin_inset Formula $\dotmcontext{\Gamma};\nthar oi\vdash t_{i}$
\end_inset

, as in the rule 
\begin_inset Formula $\refrule{Rig}$
\end_inset

.
 In the following, we will use either interpretation.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
The syntax in the empty metacontext does not depend on the morphisms in
 
\begin_inset Formula ${\cal A}$
\end_inset

.
 In fact, by restricting the morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 to identity morphisms, any GB-signature induces an indexed container
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:conf/lics/AltenkirchM09"
literal "false"

\end_inset

 generating the same syntax without metavariables.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
GB-signatures capture multi-sorted binding signatures such as simply-typed
 
\begin_inset Formula $\lambda$
\end_inset

-calculus, or polymorphic syntax such as System F (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:applications"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 Although equations are not explicitly supported, simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

- and 
\begin_inset Formula $\eta$
\end_inset

- equations can be handled by working on the normalised syntax (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:bgsig-functorial"

\end_inset

In the notion of GB-signature, functoriality ensures that the generated
 syntax supports renaming: given a morphism 
\begin_inset Formula $x:a\rightarrow b$
\end_inset

 in 
\begin_inset Formula ${\cal A}$
\end_inset

 and a term 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, we can recursively define a term 
\begin_inset Formula $\Gamma;b\vdash\rename tx$
\end_inset

.
 The metavariable base case is the same as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

: 
\begin_inset Formula $\rename{M(y)}x=M(x\circ y)$
\end_inset

.
 For an operation 
\begin_inset Formula $o(t_{1},\dots,t_{n})$
\end_inset

, functoriality provides the following components:
\end_layout

\begin_deeper
\begin_layout Enumerate
a 
\begin_inset Formula $n$
\end_inset

-ary operation symbol 
\begin_inset Formula $\rename ox\in O(b)$
\end_inset

;
\end_layout

\begin_layout Enumerate
a list of morphisms 
\begin_inset Formula $(x_{1}^{o},\dots,x_{n}^{o})$
\end_inset

 in 
\begin_inset Formula ${\cal A}$
\end_inset

 such that 
\begin_inset Formula $\ntharvecaction oxi:\nthar oi\rightarrow\nthar{\rename ox}i$
\end_inset

 for each 
\begin_inset Formula $i\in\{1,\dots,n\}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Then, 
\begin_inset Formula $\rename{o(t_{1},\mydots,t_{n})}x$
\end_inset

 is defined as 
\begin_inset Formula $\rename ox(\rename{t_{1}}{\ntharvecaction ox1},\mydots,\rename{t_{n}}{\ntharvecaction oxn})$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Notation
\begin_inset CommandInset label
LatexCommand label
name "not:vector-renamings"

\end_inset

If 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 and 
\begin_inset Formula $\dotmcontext{\Delta}$
\end_inset

 are two metacontexts 
\begin_inset Formula $M_{1}:m_{1},\dots,M_{p}:m_{p}$
\end_inset

 and 
\begin_inset Formula $N_{1}:n_{1},\dots,N_{p}:n_{p}$
\end_inset

 of the same length, we write 
\begin_inset Formula $\delta:\dotmcontext{\Gamma}\Longrightarrow\dotmcontext{\Delta}$
\end_inset

 to mean that 
\begin_inset Formula $\delta$
\end_inset

 is a 
\emph on
vector of renamings
\emph default
 
\begin_inset Formula $(\delta_{1},\dots,\delta_{n})$
\end_inset

 between 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 and 
\begin_inset Formula $\dotmcontext{\Delta}$
\end_inset

, in the sense that each 
\begin_inset Formula $\delta_{i}$
\end_inset

 is a morphism between 
\begin_inset Formula $m_{i}$
\end_inset

 and 
\series bold

\begin_inset Formula $n_{i}$
\end_inset


\series default
.
 The second functoriality component in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:bgsig-functorial"
plural "false"
caps "true"
noprefix "false"

\end_inset

 is accordingly specified as a vector of renamings 
\begin_inset Formula $x^{o}:\alpha_{o}\Longrightarrow\alpha_{\rename of}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:sig-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

, considering operation arities as nameless metacontexts (
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:arg-op-subst"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 We extend the renaming notation to substitutions: given 
\begin_inset Formula $\delta:\Gamma\rightarrow\dotmcontext{\Delta}$
\end_inset

 and 
\begin_inset Formula $x:\dotmcontext{\Delta'}\Longrightarrow\dotmcontext{\Delta}$
\end_inset

, we define 
\begin_inset Formula $\rename{\delta}x:\Gamma\rightarrow\dotmcontext{\Delta'}$
\end_inset

 as 
\begin_inset Formula $(\rename{\delta_{1}}{x_{1}},\dots,\rename{\delta_{n}}{x_{n}})$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the length of 
\begin_inset Formula $\Delta$
\end_inset

, so that 
\begin_inset Formula $\rename{o(\delta)}x$
\end_inset

 can be equivalently defined as 
\begin_inset Formula $\rename ox(\rename{\delta}{x^{o}})$
\end_inset

.
 Note that a vector of renamings 
\begin_inset Formula $\delta:\dotmcontext{\Gamma}\Longrightarrow\dotmcontext{\Delta}$
\end_inset

 canonically induces a metavariable substitution 
\begin_inset Formula $\substofrenamings{\delta}:\dotmcontext{\Delta}\rightarrow\dotmcontext{\Gamma}$
\end_inset

, mapping 
\begin_inset Formula $N_{i}$
\end_inset

 to 
\begin_inset Formula $M_{i}(\delta_{i})$
\end_inset

.
\end_layout

\begin_layout Standard
The Agda code adapting the definitions of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

 to a syntax generated by a generic signature is usually shorter because
 the application, 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, and variable cases are replaced with a single rigid case.
 Because of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:arg-op-subst"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is more convenient to define operations on terms mutually with the
 corresponding operations on substitutions.
 For example, composition of substitutions is defined mutually with substitution
 of terms in the second box of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:subst-code"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The same applies for renaming of terms and substitution as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "not:vector-renamings"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
, whose code can be found in the supplemental material.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are similarly led to generalise unification of terms to unification of
 proper substitutions, and we extend accordingly the notation.
 Given two substitutions 
\begin_inset Formula $\delta_{1},\delta_{2}:\dotmcontext{\Gamma'}\rightarrow\Gamma$
\end_inset

, we write 
\begin_inset Formula $\Gamma\vdash\delta_{1}=\delta_{2}\Rightarrow\sigma\dashv\Delta$
\end_inset

 to mean that 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 unifies 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

, in the sense that 
\begin_inset Formula $\delta_{1}[\sigma]=\delta_{2}[\sigma]$
\end_inset

, and is the most general one, i.e., it uniquely factors any other unifier
 of 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

.
 The main unification function is thus split in two functions, 
\begin_inset Formula $\AgdaFunction{unify}$
\end_inset

 for single terms, and 
\begin_inset Formula $\AgdaFunction{unify-\ensuremath{\sigma}}$
\end_inset

 for substitutions.
 Similarly, we define pruning of terms mutually with pruning of proper substitut
ions.
 We thus also extend the pruning notation: given a substitution 
\begin_inset Formula $\delta:\dotmcontext{\Gamma'}\rightarrow\Gamma$
\end_inset

 and a vector 
\begin_inset Formula $x:\dotmcontext{\Gamma''}\Longrightarrow\dotmcontext{\Gamma'}$
\end_inset

 of renamings, the judgement 
\begin_inset Formula $\Gamma\prune{\delta}x{\sigma}{\delta'}\dashv\Delta$
\end_inset

 means that the substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 extended with 
\begin_inset Formula $\delta':\dotmcontext{\Gamma''}\rightarrow\Delta$
\end_inset

 is the most general unifier of 
\begin_inset Formula $\delta$
\end_inset

 and 
\begin_inset Formula $\substofrenamings x$
\end_inset

 as substitutions from 
\begin_inset Formula $\Gamma,\dotmcontext{\Gamma'}$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

.
 The outputs of 
\begin_inset Formula $\AgdaFunction{unify}$
\end_inset

 and 
\begin_inset Formula $\AgdaFunction{unify-\ensuremath{\sigma}}$
\end_inset

 are gathered as fields of record types (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:type-signatures"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\align left
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{prune-sigma-return-type}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the 
\begin_inset Formula $\lambda$
\end_inset

-calculus implementation (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

), unification of two metavariable applications requires computing the vector
 of common positions or value positions of their arguments, depending on
 whether the involved metavariables are identical.
 Both vectors are characterised as equalisers or pullbacks in the category
 of natural numbers and injective renamings between them
\begin_inset Note Note
status open

\begin_layout Plain Layout
defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "ex:gbsig-bsig"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset

, thus providing a canonical replacement in the generic algorithm, along
 with new interpretations of the notations 
\begin_inset Formula $\highlighted{m\vdash x=y\Rightarrow z\dashv p}$
\end_inset

 and 
\begin_inset Formula $\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}$
\end_inset

 as equalisers and pullbacks.
\end_layout

\begin_layout Notation
\begin_inset CommandInset label
LatexCommand label
name "not:highlighted-cat-notations"

\end_inset

We denote an equaliser 
\begin_inset Formula $\xymatrix{p\ar[r]^{z} & m\coeqr{x}{y} & \dots}
$
\end_inset

 in 
\begin_inset Formula ${\cal A}$
\end_inset

 by 
\begin_inset Formula $\highlighted{m\vdash x=y\Rightarrow z\dashv p}$
\end_inset

.
 Similarly, 
\begin_inset Formula $\highlighted{m\prunecat xy{x'\dashv p}{y'}{}}$
\end_inset

 denotes a pullback in 
\begin_inset Formula ${\cal A}$
\end_inset

 of the shape 
\begin_inset Formula $\begin{array}{c}
\xymatrix{p\ar[r]^{x'}\ar[d]_{y'} & m\ar[d]^{x}\\
\dots\ar[r]_{y} & \dots
}
\end{array}.$
\end_inset


\end_layout

\begin_layout Standard
Let us now comment on pruning rigid terms, when we want to unify an operation
 
\begin_inset Formula $o(\delta)$
\end_inset

 with a fresh metavariable application 
\begin_inset Formula $M(x)$
\end_inset

.
 Any unifier must replace 
\begin_inset Formula $M$
\end_inset

 with an operation 
\begin_inset Formula $o'(\delta')$
\end_inset

, such that 
\begin_inset Formula $\rename{o'}x(\rename{\delta'}{x^{o'}})=o(\delta)$
\end_inset

, so that, in particular, 
\begin_inset Formula $\rename{o'}x=o$
\end_inset

.
 In other words, 
\begin_inset Formula $o$
\end_inset

 must have a preimage 
\begin_inset Formula $o'$
\end_inset

 for renaming by 
\begin_inset Formula $x$
\end_inset

.
 This is precisely the point of the inverse renaming 
\begin_inset Formula $\rename ox^{-1}$
\end_inset

 in the Agda code: it returns a preimage 
\begin_inset Formula $o'$
\end_inset

 if it exists, or fails.
 In the 
\begin_inset Formula $\lambda$
\end_inset

-calculus case, this check is only explicit for variables, since there is
 a single version of application and 
\begin_inset Formula $\lambda$
\end_inset

-abstraction symbols in any variable context.
 Uniqueness of the preimage is guaranted for 
\emph on
pattern-friendly 
\emph default
GB-signatures, which are GB-signatures with additional components listed
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:friendly-gb-agda"
plural "false"
caps "true"
noprefix "false"

\end_inset

 on which the algorithm relies.
 To sum up, 
\end_layout

\begin_layout Itemize
equalisers and pullbacks are used when unifying two metavariable applications;
\end_layout

\begin_layout Itemize
equality of operation symbols is used when unifying two rigid terms;
\end_layout

\begin_layout Itemize
inverse renaming is used when pruning a rigid term.
\end_layout

\begin_layout Standard
The formal notion of pattern-friendly signatures (
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:pattern-friendly"
plural "false"
caps "true"
noprefix "false"

\end_inset

) includes additional properties ensuring correctness of the algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Friendly GB-signatures in Agda
\begin_inset CommandInset label
LatexCommand label
name "fig:friendly-gb-agda"

\end_inset


\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
agdacode{friendlysignature}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Categorical semantics
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:cat-settings"

\end_inset

To prove that the algorithm is correct, we show in the next sections that
 the inductive rules describing the implementation are sound.
 For instance, the rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 is sound on the condition that the output of the conclusion is a most general
 unifier whenever the output of the premises are most general unifiers.
 We rely on the categorical semantics of pattern unification that we introduce
 in this section.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we relate pattern unification to a coequaliser construction, and in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:GB-sig"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we provide a formal definition of GB-signatures with Initial Algebra Semantics
 for the generated syntax.
 
\end_layout

\begin_layout Subsection
Pattern unification as a coequaliser construction
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:categorification"

\end_inset


\end_layout

\begin_layout Standard
In this section, we assume given a GB-signature 
\begin_inset Formula $S$
\end_inset

 and explain how most general unifiers can be thought of as equalisers in
 a multi-sorted Lawvere theory, as is well-known in the first-order case
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:books/daglib/0068768,10.5555/92134"
literal "false"

\end_inset

.
 We furthermore provide a formal justification for the error metacontext
 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Lemma
Proper metacontexts and substitutions (with their composition) between them
 define a category 
\begin_inset Formula $\Th S$
\end_inset

.
\end_layout

\begin_layout Standard
This relies on functoriality of GB-signatures that we will spell out formally
 in the next section.
 There, we will see in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:mcon-kleisli"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that this category fully faithfully embeds in a Kleisli category for a
 monad generated by 
\begin_inset Formula $S$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

.
\end_layout

\begin_layout Remark
The opposite category of 
\begin_inset Formula $\Th S$
\end_inset

 is equivalent to a multi-sorted Lawvere theory whose sorts are the objects
 of 
\begin_inset Formula ${\cal A}$
\end_inset

.
 In general, this theory is not freely generated by operations unless 
\begin_inset Formula ${\cal A}$
\end_inset

 is discrete, in which case we recover (multi-sorted) first-order unification.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that even the GB-signature induced (as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "ex:gbsig-bsig"
plural "false"
caps "true"
noprefix "false"

\end_inset

) by an empty binding signature is not 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

 in this sense.
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
The most general unifier of two parallel substitutions 
\begin_inset Formula $\xymatrix{\dotmcontext{\Gamma'}\coeqr{\delta_{1}}{\delta_{2}} & \dotmcontext{\Gamma}}
$
\end_inset

 is characterised as their coequaliser.
\end_layout

\begin_layout Standard
This motivates a new interpretation of the unification notation, that we
 introduce later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "not:cat-coeq"
plural "false"
caps "true"
noprefix "false"

\end_inset

, after explaining how failure is categorically handled.
 Indeed, pattern unification is typically stated as the existence of a coequalis
er on the condition that there is a unifier in this category 
\begin_inset Formula $\Th S$
\end_inset

.
 But we can get rid of this condition by considering the category 
\begin_inset Formula $\Th S$
\end_inset

 freely extended with a terminal object 
\begin_inset Formula $\bot$
\end_inset

, resulting in the full category of metacontexts and substitutions.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Thus, a unification problem can be stated as a pair of parallel Kleisli
 morphisms 
\begin_inset Formula $\xymatrix{ya\coeqr{t}{u} & T\Gamma}
$
\end_inset

,
\end_layout

\begin_layout Plain Layout
corresponding (by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:free-alg-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and the Yoneda Lemma) to selecting a pair of elements in 
\begin_inset Formula $T\Gamma_{a}$
\end_inset

, or equivalently, a pair of terms 
\begin_inset Formula $\Gamma;a\vdash t,u$
\end_inset

.
 A unifier is nothing but a Kleisli morphism coequalising this pair.
 The property required by the most general unifier means that it is the
 coequaliser in the full subcategory spanned by objects of the shape 
\begin_inset Formula $\underline{\Gamma}$
\end_inset

, that we denote by 
\begin_inset Formula $\Th S$
\end_inset

, as it is (up to equivalence) the opposite category of a multi-sorted Lawvere
 theory.
 With this in mind, we can now interpret the notation 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 as a coequaliser.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it either takes place in 
\begin_inset Formula $\op{{\cal A}}$
\end_inset

 or in the category 
\begin_inset Formula $\Th S$
\end_inset

 freely extended with a terminal object 
\begin_inset Formula $\bot$
\end_inset

.
 This trick allows us to state pattern unification as a coequaliser even
 when there is no unifier, as we now explain.
 Thus, a unification problem can be stated as a pair of parallel Kleisli
 morphisms 
\begin_inset Formula $\xymatrix{ya\coeqr{t}{u} & T\Gamma}
$
\end_inset

,
\end_layout

\begin_layout Plain Layout
corresponding (by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:free-alg-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and the Yoneda Lemma) to selecting a pair of elements in 
\begin_inset Formula $T\Gamma_{a}$
\end_inset

, or equivalently, a pair of terms 
\begin_inset Formula $\Gamma;a\vdash t,u$
\end_inset

.
 A unifier is nothing but a Kleisli morphism coequalising this pair.
 The property required by the most general unifier means that it is the
 coequaliser in the full subcategory spanned by objects of the shape 
\begin_inset Formula $\underline{\Gamma}$
\end_inset

, that we denote by 
\begin_inset Formula $\Th S$
\end_inset

, as it is (up to equivalence) the opposite category of a multi-sorted Lawvere
 theory.
 With this in mind, we can now interpret the notation 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 as a coequaliser.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it either takes place in 
\begin_inset Formula $\op{{\cal A}}$
\end_inset

 or in the category 
\begin_inset Formula $\Th S$
\end_inset

 freely extended with a terminal object 
\begin_inset Formula $\bot$
\end_inset

.
 This trick allows us to state pattern unification as a coequaliser even
 when there is no unifier, as we now explain.
 
\end_layout

\end_inset


\end_layout

\begin_layout Definition
Given a category 
\begin_inset Formula $\mathscr{B}$
\end_inset

, let 
\begin_inset Formula $\catbot{\B}$
\end_inset

 denote the category 
\begin_inset Formula $\mathscr{B}$
\end_inset

 extended freely with a terminal object 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Notation
We denote by 
\begin_inset Formula $\bang_{s}$
\end_inset

 any terminal morphism to 
\begin_inset Formula $\bot$
\end_inset

 in 
\begin_inset Formula $\B_{\bot}$
\end_inset

.
\end_layout

\begin_layout Lemma
Metacontexts and substitutions between them define a category which is isomorphi
c to 
\begin_inset Formula $\Thbot S$
\end_inset

.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we already made sense of this extension.
 Let us rephrase our explanations from a categorical perspective.
 Adding a terminal object results in adding a terminal cocone to all diagrams.
 As a consequence, we have the following lemma.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $J$
\end_inset

 be a diagram in a category 
\begin_inset Formula $\mathscr{B}$
\end_inset

.
 The following are equivalent:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $J$
\end_inset

 has a colimit as long as there exists a cocone;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $J$
\end_inset

 has a colimit in 
\begin_inset Formula $\catbot{\B}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Long Proof
Straightforward, because a colimit is defined as an initial cocone.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The following results are also useful.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $\mathscr{B}$
\end_inset

 be a category.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
roman{enumi}), ref=
\backslash
thelemma.(
\backslash
roman{enumi})
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lem:bot-creates"

\end_inset

The canonical embedding functor 
\begin_inset Formula $\mathscr{B}\rightarrow\catbot{\mathscr{B}}$
\end_inset

 creates colimits.
 
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "lem:diag-bot"

\end_inset

Any diagram 
\begin_inset Formula $J$
\end_inset

 in 
\begin_inset Formula $\B_{\bot}$
\end_inset

 such that 
\begin_inset Formula $\bot$
\end_inset

 is in its image has a colimit given by the terminal cocone on 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
This ensures in particular that coproducts in 
\begin_inset Formula $\Th S$
\end_inset

, which are computed as union of metacontexts, are also coproducts in 
\begin_inset Formula $\Thbot S$
\end_inset

.
 It also justifies defining the union of a proper metacontext with 
\begin_inset Formula $\bot$
\end_inset

 as 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Standard
The main property of this extension for our purposes is the following corollary.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:completeness-algo"

\end_inset

Any coequaliser in 
\begin_inset Formula $\Th S$
\end_inset

 is also a coequaliser in 
\begin_inset Formula $\Thbot S$
\end_inset

.
 Moreover, whenever there is no unifier of two lists of terms, then the
 coequaliser of the corresponding parallel arrows in 
\begin_inset Formula $\Thbot S$
\end_inset

 exists: it is the terminal cocone on 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Standard
This justifies the following interpretation to the unification notation.
\end_layout

\begin_layout Notation
\begin_inset CommandInset label
LatexCommand label
name "not:cat-coeq"

\end_inset


\begin_inset Formula $\Gamma\vdash\delta_{1}=\delta_{2}\Rightarrow\sigma\dashv\Delta$
\end_inset

 denotes a coequaliser 
\begin_inset Formula $\xymatrix{\dots\coeqr{\delta_{1}}{\delta_{2}} & \Gamma\ar[r]^{\sigma} & \Delta}
$
\end_inset

 in 
\begin_inset Formula $\Thbot S$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:equaliser-notation"

\end_inset

This is the same interpretation as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "not:highlighted-cat-notations"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for equaliser, taking 
\begin_inset Formula ${\cal A}$
\end_inset

 to be the opposite category of 
\begin_inset Formula $\Thbot S$
\end_inset

.
\end_layout

\begin_layout Standard
Categorically speaking, our pattern-unification algorithm provides an explicit
 proof of the following statement, where the conditions for a signature
 to be 
\emph on
pattern-friendly 
\emph default
are introduced in the next section (
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:pattern-friendly"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Theorem
Given any pattern-friendly signature 
\begin_inset Formula $S$
\end_inset

, the category 
\begin_inset Formula $\Thbot S$
\end_inset

 has coequalisers.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:res-monad"

\end_inset

 The main property that justifies unification of two metavariables as an
 equaliser or a pullback in 
\begin_inset Formula ${\cal A}$
\end_inset

 is that given any metacontext 
\begin_inset Formula $\Gamma$
\end_inset

, the functor 
\begin_inset Formula $T\Gamma:{\cal A}\rightarrow\Set$
\end_inset

 preserves them, i.e., 
\begin_inset Formula $T\Gamma\in\C$
\end_inset

.
 In fact, the argument works not only in the category of metacontexts and
 substitutions, but also in the (larger) category of objects of 
\begin_inset Formula $\C$
\end_inset

 and Kleisli morphisms between them.
 However, counter-examples can be found in the total Kleisli category.
 Consider indeed the unification problem 
\begin_inset Formula $M(x,y)=M(y,x)$
\end_inset

, in the example of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 We can define
\begin_inset Foot
status open

\begin_layout Plain Layout
Define 
\begin_inset Formula $P_{n}$
\end_inset

 as the set of two-elements sets of 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
\end_layout

\end_inset

 a functor 
\begin_inset Formula $P$
\end_inset

 that does not preserve finite connected colimits such that 
\begin_inset Formula $T(P)$
\end_inset

 is the syntax extended with a binary commutative metavariable 
\begin_inset Formula $M'(-,-)$
\end_inset

.
 Then, the most general unifier, computed in the total Kleisli category,
 replaces 
\begin_inset Formula $M$
\end_inset


\color red
 
\color inherit
with 
\begin_inset Formula $P$
\end_inset

.
 But in the Kleisli category restricted to coproducts of representable functors,
 or more generally, to objects of 
\begin_inset Formula $\C$
\end_inset

, the coequaliser replaces 
\begin_inset Formula $M$
\end_inset

 with a constant metavariable, as expected.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Initial Algebra Semantics for GB-signatures
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:GB-sig"

\end_inset

The proofs of various statements presented in this section are detailed
 in the appendices found in the supplemental material.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:proof-statements"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:GB-signature"

\end_inset

A 
\emph on
generalised binding signature
\emph default
, or 
\emph on
GB-signature, 
\emph default
is a tuple 
\begin_inset Formula $({\cal A},\indexedO,\ntharvecfunct)$
\end_inset

 consisting of
\end_layout

\begin_deeper
\begin_layout Itemize
a small category 
\begin_inset Formula ${\cal A}$
\end_inset

 of arities and renamings between them;
\end_layout

\begin_layout Itemize
a functor 
\begin_inset Formula $\Oop --:\mathbb{N}\times{\cal A}\rightarrow\Set$
\end_inset

 of operation symbols;
\end_layout

\begin_layout Itemize
a family of functors 
\begin_inset Formula $(\alpha_{n,i}:\int\Oby n\rightarrow{\cal A})_{n,i\leq n}$
\end_inset

 indexed by natural numbers 
\begin_inset Formula $i,n$
\end_inset

 such that 
\begin_inset Formula $i\leq n$
\end_inset

,
\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\int\Oby n$
\end_inset

 denotes the category of elements of 
\begin_inset Formula $\Oby n:{\cal A}\rightarrow\Set$
\end_inset

, defined as follows:
\end_layout

\begin_layout Itemize
objects are pairs 
\begin_inset Formula $(a,o)$
\end_inset

 such that 
\begin_inset Formula $o\in\Oop na$
\end_inset


\end_layout

\begin_layout Itemize
a morphism between 
\begin_inset Formula $(a,o)$
\end_inset

 and 
\begin_inset Formula $(a',o')$
\end_inset

 is a morphism 
\begin_inset Formula $f:a\rightarrow a'$
\end_inset

 such that 
\begin_inset Formula $\rename of=o'$
\end_inset

 where 
\begin_inset Formula $o\{f\}$
\end_inset

 denotes the image of 
\begin_inset Formula $o$
\end_inset

 by the function 
\begin_inset Formula $\Oop nf:\Oop na\rightarrow\Oop n{a'}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Notation
Given a GB-signature 
\begin_inset Formula $({\cal A},\indexedO,\ntharvecfunct)$
\end_inset

 and 
\begin_inset Formula $o\in\Oby n(a)$
\end_inset

, we write 
\begin_inset Formula $\nthar oj$
\end_inset

 for 
\begin_inset Formula $\alpha_{n,j}(o)$
\end_inset

 and 
\begin_inset Formula $\alpha_{o}$
\end_inset

 for the tuple 
\begin_inset Formula $(\nthar o1,\dots,\nthar on)$
\end_inset

.
\end_layout

\begin_layout Standard
We now introduce our conditions for the generic unification algorithm to
 be correct.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:pattern-friendly"

\end_inset

A GB-signature 
\begin_inset Formula $S=({\cal A},\indexedO,\ntharvecfunct)$
\end_inset

 is said to be 
\emph on
pattern-friendly 
\emph default
if 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits (or equivalently, 
\begin_inset Formula ${\cal A}$
\end_inset

 has pullbacks and equalisers);
\end_layout

\begin_layout Enumerate
all morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 are monomorphic;
\end_layout

\begin_layout Enumerate
each 
\begin_inset Formula $\Oop n-:{\cal A}\rightarrow\Set$
\end_inset

 preserves finite connected limits;
\end_layout

\begin_layout Enumerate
each 
\begin_inset Formula $\alpha_{n,i}$
\end_inset

 preserves finite connected limits.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:counter-example"

\end_inset

As a counter-example, take 
\begin_inset Formula ${\cal A}$
\end_inset

 to be the category 
\begin_inset Formula $a\xrightarrow{f}b$
\end_inset

 consisting of two objects and one non-identity morphism between them, and
 consider the syntax generated by two nullary operations in environement
 
\begin_inset Formula $a$
\end_inset

 and one nullary operation 
\begin_inset Formula $*$
\end_inset

 in scope 
\begin_inset Formula $b$
\end_inset

.
 Then, 
\begin_inset Formula $M(f)\stackrel{?}{=}*$
\end_inset

 has two unifiers but no most general unifier.
\end_layout

\begin_layout Standard
These conditions ensure the following two properties.
\end_layout

\begin_layout Property
\begin_inset Argument 1
status open

\begin_layout Plain Layout
proved in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset Formula $\S$
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:proof-L-preserves"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "assu:main-properties"

\end_inset

The following properties hold for pattern-friendly signatures.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
roman{enumi}), ref=
\backslash
theproperty.(
\backslash
roman{enumi})
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "assu:O-mono"

\end_inset

The action of 
\begin_inset Formula $\Oby n:{\cal A}\rightarrow\Set$
\end_inset

 on any renaming is an injection: given any 
\begin_inset Formula $o\in\Oop nb$
\end_inset

 and renaming 
\begin_inset Formula $f:a\rightarrow b$
\end_inset

, there is at most one 
\begin_inset Formula $o'\in\Oop na$
\end_inset

 such that 
\begin_inset Formula $o=\rename{o'}f$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "assu:L-finite-conncted"

\end_inset

Let 
\begin_inset Formula ${\cal L}$
\end_inset

 be the functor 
\begin_inset Formula $\op{{\cal A}}\xrightarrow{}\Thbot S$
\end_inset

 mapping a morphism 
\begin_inset Formula $x\in\hom_{{\cal A}}(b,a)$
\end_inset

 to the substitution 
\begin_inset Formula $(X:a)\rightarrow(X:b)$
\end_inset

 selecting (by the Yoneda Lemma) the term 
\begin_inset Formula $X(x)$
\end_inset

.
 Then, 
\begin_inset Formula ${\cal L}$
\end_inset

 preserves finite connected colimits: it maps pullbacks and equalisers in
 
\begin_inset Formula ${\cal A}$
\end_inset

 to pushouts and coequalisers in 
\begin_inset Formula $\Thbot S$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
The first property is used for soundness of the rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Rig-Fail}$
\end_inset

.
 The second one is used to justify unification of two metavariables applications
 as pullbacks and equalisers in 
\begin_inset Formula ${\cal A}$
\end_inset

, in the rules 
\begin_inset Formula $\refrule{Same-MVar}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:functor-L-intuition"

\end_inset

A metavariable application 
\begin_inset Formula $\dotmcontext{\Gamma};a\vdash M(x)$
\end_inset

 corresponds to the composition 
\begin_inset Formula ${\cal L}x[in_{M}]$
\end_inset

 as a substitution from 
\begin_inset Formula $X:a$
\end_inset

 to 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

, where 
\begin_inset Formula $in_{M}$
\end_inset

 is the coproduct injection 
\begin_inset Formula $(X:m)\cong(M:m)\hookrightarrow\dotmcontext{\Gamma}$
\end_inset

 mapping 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $M(1_{m})$
\end_inset

.
\end_layout

\begin_layout Standard
In the rest of this section, we provide Initial Algebra Semantics for the
 generated syntax (this is used in the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
Any GB-signature 
\begin_inset Formula $S=({\cal A},\indexedO,\ntharvecfunct)$
\end_inset

, generates an endofunctor 
\begin_inset Formula $F_{S}$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

, that we denote by just 
\begin_inset Formula $F$
\end_inset

 when the context is clear, defined by
\begin_inset Formula 
\[
F_{S}(X)_{a}=\coprod_{n\in\mathbb{N}}\coprod_{o\in\Oop na}X_{\nthar o1}\times\dots\times X_{\nthar on}.
\]

\end_inset


\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Argument 1
status open

\begin_layout Plain Layout
proved in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset Formula $\S$
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:F-finitary"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lem:F-finitary"

\end_inset


\begin_inset Formula $F$
\end_inset

 is finitary and generates a free monad 
\begin_inset Formula $T$
\end_inset

.
 Moreover, 
\begin_inset Formula $TX$
\end_inset

 is the initial algebra of 
\begin_inset Formula $Z\mapsto X+FZ$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:free-alg-syntax"

\end_inset

The proper syntax generated by a GB-signature (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:sig-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

) is recovered as free algebras for 
\begin_inset Formula $F$
\end_inset

.
 More precisely, given a metacontext 
\begin_inset Formula $\dotmcontext{\Gamma}=(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

, 
\begin_inset Formula 
\[
T(\underline{\Gamma})_{a}\cong\{t\ |\ \Gamma;a\vdash t\}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where 
\begin_inset Formula $\underline{\dotmcontext{\Gamma}}:{\cal A}\rightarrow\Set$
\end_inset

 is defined as the coproduct of representable functors 
\begin_inset Formula $\coprod_{i}ym_{i}$
\end_inset

, mapping 
\begin_inset Formula $a$
\end_inset

 to 
\begin_inset Formula $\coprod_{i}\hom_{{\cal A}}(m_{i},a)$
\end_inset

.
 Moreover, the action of 
\begin_inset Formula $T(\underline{\dotmcontext{\Gamma}})$
\end_inset

 on morphisms of 
\begin_inset Formula ${\cal A}$
\end_inset

 correspond to renaming.
\end_layout

\end_deeper
\begin_layout Notation
Given a proper metacontext 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

.
 We sometimes denote 
\begin_inset Formula $\underline{\dotmcontext{\Gamma}}$
\end_inset

 just by 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\dotmcontext{\Gamma}=(M_{1}:m_{1},...,M_{p}:m_{p})$
\end_inset

 and 
\begin_inset Formula $\dotmcontext{\Delta}$
\end_inset

 are metacontexts, a Kleisli morphism 
\begin_inset Formula $\sigma:\dotmcontext{\Gamma}\rightarrow T\dotmcontext{\Delta}$
\end_inset

 is equivalently given (by combining the above lemma, the Yoneda Lemma,
 and the universal property of coproducts) by a metavariable substitution
 from 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 to 
\begin_inset Formula $\dotmcontext{\Delta}$
\end_inset

.
 Moreover, Kleisli composition corresponds to composition of substitutions.
 This provides a formal link between the category of metacontexts 
\begin_inset Formula $\Th S$
\end_inset

 and the Kleisli category of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "prop:mcon-kleisli"

\end_inset

The category 
\begin_inset Formula $\Th S$
\end_inset

 is equivalent to the full subcategory of 
\begin_inset Formula $\Kl T$
\end_inset

 spanned by coproducts of representable functors.
\end_layout

\begin_layout Remark
It follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "prop:mcon-kleisli"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citep
before "Exercise VI.5.1"
key "MacLane:cwm"
literal "false"

\end_inset

 that 
\begin_inset Formula $\Th S$
\end_inset

 fully faithfully embeds in the category of algebras of 
\begin_inset Formula $T$
\end_inset

, by mapping a metacontext 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 to the free algebra 
\begin_inset Formula $T\dotmcontext{\Gamma}$
\end_inset

.
 In fact, 
\begin_inset Formula $\Thbot S$
\end_inset

 also fully faithfully embeds in the category of algebras by mapping 
\begin_inset Formula $\bot$
\end_inset

 to the terminal algebra, whose underlying functor maps any object of 
\begin_inset Formula ${\cal A}$
\end_inset

 to a singleton set.
\end_layout

\begin_layout Standard
We exploit this characterisation to prove various properties of this category
 when the signature is 
\emph on
pattern-friendly
\emph default
.
\end_layout

\begin_layout Notation
Given a GB-signature 
\begin_inset Formula $S=({\cal A},\indexedO,\ntharvecfunct)$
\end_inset

, we denote the full subcategory of 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 consisting of functors preserving finite connected limits by 
\begin_inset Formula $\C_{S}$
\end_inset

, or sometimes by 
\begin_inset Formula $\C$
\end_inset

, leaving 
\begin_inset Formula $S$
\end_inset

 implicit.
\end_layout

\begin_layout Lemma
\begin_inset Argument 1
status open

\begin_layout Plain Layout
proved in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset Formula $\S$
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:resF-direct"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lem:res-F"

\end_inset

Given a GB-signature 
\begin_inset Formula $S=({\cal A},\indexedO,\ntharvecfunct)$
\end_inset

 such that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits, 
\begin_inset Formula $F_{S}$
\end_inset

 restricts as an endofunctor on 
\begin_inset Formula $\C_{S}$
\end_inset

 if and only if the last two conditions of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:pattern-friendly"
plural "false"
caps "true"
noprefix "false"

\end_inset

 hold.
\end_layout

\begin_layout Standard
We now assume given a pattern-friendly signature 
\begin_inset Formula $S=({\cal A},\indexedO,\ntharvecfunct)$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset Argument 1
status open

\begin_layout Plain Layout
proved in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset Formula $\S$
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:lims-coprod-pw"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lem:lims-coprod-pw"

\end_inset


\begin_inset Formula $\C$
\end_inset

 is closed under limits, coproducts, and filtered colimits.
 Moreover, it is cocomplete.
\end_layout

\begin_layout Corollary
\begin_inset Argument 1
status open

\begin_layout Plain Layout
proved in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset Formula $\S$
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:T-res"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "cor:-T-res"

\end_inset


\begin_inset Formula $T$
\end_inset

 restricts as a monad on 
\begin_inset Formula $\C$
\end_inset

 freely generated by the restriction of 
\begin_inset Formula $F$
\end_inset

 as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:res-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Proofs of statements in Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:GB-sig"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:proof-statements"

\end_inset


\end_layout

\begin_layout Subsubsection
Property
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "assu:main-properties"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:proof-L-preserves"

\end_inset


\end_layout

\begin_layout Standard
We use the notations and definitions of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:GB-sig"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Let us first prove the first item.
\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Proof of Property
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "assu:O-mono"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
We show that given any 
\begin_inset Formula $o\in\Oop nb$
\end_inset

 and renaming 
\begin_inset Formula $f:a\rightarrow b$
\end_inset

, there is at most one 
\begin_inset Formula $o'\in\Oop na$
\end_inset

 such that 
\begin_inset Formula $o=\rename{o'}f$
\end_inset

.
 
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $\Oby n$
\end_inset

 preserves finite connected limits, it preserves monomorphisms because a
 morphism 
\begin_inset Formula $f:a\rightarrow b$
\end_inset

 is monomorphic if and only if the following square is a pullback 
\begin_inset Note Note
status open

\begin_layout Plain Layout
the pullback of 
\begin_inset Formula $a\xrightarrow{f}b\xleftarrow{f}a$
\end_inset

 is the identity cone 
\begin_inset Formula $a\leftarrow a\rightarrow a$
\end_inset


\end_layout

\end_inset

(see 
\begin_inset CommandInset citation
LatexCommand citep
after "Exercise III.4.4"
key "MacLane:cwm"
literal "false"

\end_inset

).
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	A & A 
\backslash

\backslash
 	A & B 	
\backslash
arrow["f", from=1-2, to=2-2] 	
\backslash
arrow[equal, from=1-1, to=1-2] 	
\backslash
arrow["f"', from=2-1, to=2-2] 	
\backslash
arrow[Rightarrow, no head, from=1-1, to=2-1] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rest of this section is devoted to the proof of Property
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "assu:L-finite-conncted"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
By right continuity of the homset bifunctor, any representable functor is
 in 
\begin_inset Formula $\C$
\end_inset

 and thus the embedding 
\begin_inset Formula $\C\rightarrow[\mathcal{A},\Set]$
\end_inset

 factors the Yoneda embedding 
\begin_inset Formula $\op{\mathcal{A}}\rightarrow[\mathcal{A},\Set]$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:K-finite-connected"

\end_inset

Let 
\begin_inset Formula $\D$
\end_inset

 denote the opposite category of 
\begin_inset Formula ${\cal A}$
\end_inset

 and 
\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 the factorisation of 
\begin_inset Formula $\C\rightarrow[{\cal A},\Set]$
\end_inset

 by the Yoneda embedding.
 Then, 
\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 preserves finite connected colimits.
\end_layout

\begin_layout Proof
This essentially follows from the fact functors in 
\begin_inset Formula $\C$
\end_inset

 preserves finite connected limits.
 Let us detail the argument: let 
\begin_inset Formula $y:\op{\mathcal{A}}\rightarrow[\mathcal{A},\Set]$
\end_inset

 denote the Yoneda embedding and 
\begin_inset Formula $J:\C\rightarrow[\mathcal{A},\Set]$
\end_inset

 denote the canonical embedding, so that 
\begin_inset Formula 
\begin{equation}
y=J\circ K.\label{eq:def-y-1}
\end{equation}

\end_inset

Now consider a finite connected limit 
\begin_inset Formula $\lim F$
\end_inset

 in 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
 Then, 
\begin_inset Formula 
\begin{align*}
\C(K\lim F,X) & \cong[{\cal A},\Set](JK\lim F,JX)\tag{\ensuremath{J} is fully faithful}\\
 & \cong[\mathcal{A},\Set](y\lim F,JX)\tag{By Equation \prettyref{eq:def-y-1}}\\
 & \cong JX(\lim F)\tag{By the Yoneda Lemma.}\\
 & \cong\lim(JX\circ F)\tag{\ensuremath{X} preserves finite connected limits}\\
 & \cong\lim([\mathcal{A},\Set](yF-,JX)]\tag{By the Yoneda Lemma}\\
 & \cong\lim([\mathcal{A},\Set](JKF-,JX)]\tag{By Equation \prettyref{eq:def-y-1}}\\
 & \cong\lim\C(KF-,X)\tag{\ensuremath{J} is full and faithful}\\
 & \cong\C(\colim KF,X)\tag{By left continuity of the hom-set bifunctor}
\end{align*}

\end_inset

These isomorphisms are natural in 
\begin_inset Formula $X$
\end_inset

 and thus 
\begin_inset Formula $K\lim F\cong\colim KF$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Unification of two metavariables as pullbacks or equalisers in 
\begin_inset Formula ${\cal A}$
\end_inset

 crucially relies on 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

, which holds because we restrict to functors preserving finite connected
 limits.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As anticipated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:res-monad"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is crucial to consider the monad 
\begin_inset Formula $T$
\end_inset

 restricted to 
\begin_inset Formula $\C$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout

[Proof of 
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

 Note that 
\begin_inset Formula ${\cal L}$
\end_inset

 factors as 
\begin_inset Formula 
\[
\D\xrightarrow{{\cal L}^{\bullet}}\Th S\hookrightarrow\Thbot S,
\]

\end_inset

where the right embedding preserves colimits by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:bot-creates"
plural "false"
caps "true"
noprefix "false"

\end_inset

, so it is enough to show that 
\begin_inset Formula ${\cal L}^{\bullet}$
\end_inset

 preserves finite connected colimits.
 Let 
\begin_inset Formula $T_{|\C}$
\end_inset

 be the monad 
\begin_inset Formula $T$
\end_inset

 restricted to 
\begin_inset Formula $\C$
\end_inset

, following 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:-T-res"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Since 
\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 preserves finite connected colimits (
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

), composing it with the left adjoint 
\begin_inset Formula $\C\rightarrow\Kl{T_{|\C}}$
\end_inset

 yields a functor 
\begin_inset Formula $\D\rightarrow\Kl{T_{|\C}}$
\end_inset

 also preserving those colimits.
 Since it factors as 
\begin_inset Formula $\D\xrightarrow{{\cal L}^{\bullet}}\Th S\hookrightarrow\Kl{T_{|\C}}$
\end_inset

, where the right functor is full and faithful, 
\begin_inset Formula ${\cal L}^{\bullet}$
\end_inset

 also preserves finite connected colimits.
\end_layout

\begin_layout Subsubsection
Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:F-finitary"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:F-finitary"

\end_inset


\begin_inset Formula $F$
\end_inset

 is finitary because filtered colimits commute with finite limits 
\begin_inset CommandInset citation
LatexCommand citep
after "Theorem IX.2.1"
key "MacLane:cwm"
literal "false"

\end_inset

 and colimits.
 The free monad construction is due to 
\begin_inset CommandInset citation
LatexCommand cite
key "Reiterman"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:res-F"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:resF-direct"

\end_inset


\end_layout

\begin_layout Notation
Given a functor 
\begin_inset Formula $F:I\rightarrow\B$
\end_inset

, we denote the limit (resp.
 colimit) of 
\begin_inset Formula $F$
\end_inset

 by 
\begin_inset Formula $\int_{i:I}F(i)$
\end_inset

 or 
\begin_inset Formula $\lim F$
\end_inset

 (resp.
 
\begin_inset Formula $\int^{i:I}F(i)$
\end_inset

 or 
\begin_inset Formula $\colim F$
\end_inset

) and the canonical projection 
\begin_inset Formula $\lim F\rightarrow Fi$
\end_inset

 by 
\begin_inset Formula $p_{i}$
\end_inset

 for any object 
\begin_inset Formula $i$
\end_inset

 of 
\begin_inset Formula $I$
\end_inset

.
\end_layout

\begin_layout Standard
This section is dedicated to the proof of the following lemma.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:F-restricts-simpl"

\end_inset

Given a GB-signature 
\begin_inset Formula $S=({\cal A},\indexedO,\ntharvecfunct)$
\end_inset

 such that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits, 
\begin_inset Formula $F_{S}$
\end_inset

 restricts as an endofunctor on the full subcategory 
\begin_inset Formula $\C$
\end_inset

 of 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 consisting of functors preserving finite connected limits if and only if
 each 
\begin_inset Formula $\Oby n\in\C$
\end_inset

, and 
\begin_inset Formula $\alpha_{n,i}:\int\Oby n\rightarrow{\cal A}$
\end_inset

 preserves finite connected limits.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
We first introduce a bunch of intermediate lemmas.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:data-functor-elt"

\end_inset

Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 be a functor.
 For any functor 
\begin_inset Formula $G:I\rightarrow\int F$
\end_inset

, denoting by 
\begin_inset Formula $H$
\end_inset

 the composite functor 
\begin_inset Formula $I\xrightarrow{G}\int F\rightarrow\B$
\end_inset

, there exists a unique 
\begin_inset Formula $x\in\lim(F\circ H)$
\end_inset

 such that 
\begin_inset Formula $Gi=(Hi,p_{i}(x))$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Formula $\int F$
\end_inset

 is isomorphic to the opposite of the comma category 
\begin_inset Formula $y/F$
\end_inset

, where 
\begin_inset Formula $y:\op{\B}\rightarrow[\B,\Set]$
\end_inset

 is the Yoneda embedding.
 The statement follows from the universal property of a comma category.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:lim-elt"

\end_inset

Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 and 
\begin_inset Formula $G:I\rightarrow\int F$
\end_inset

 such that 
\begin_inset Formula $F$
\end_inset

 preserves the limit of 
\begin_inset Formula $H:I\xrightarrow{G}\int F\xrightarrow{}\B$
\end_inset

.
 Then, there exists a unique 
\begin_inset Formula $x\in F\lim H$
\end_inset

 such that 
\begin_inset Formula $Gi=(Hi,Fp_{i}(x))$
\end_inset

 and moreover, 
\begin_inset Formula $(\lim H,x)$
\end_inset

 is the limit of 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 preserving a limit 
\begin_inset Formula $\lim G$
\end_inset

.
 Let 
\begin_inset Formula $x\in F\lim G$
\end_inset

, thus inducing a functor 
\begin_inset Formula $G_{x}:D\rightarrow\int F$
\end_inset

 by the previous lemma.
 Then, the limit of 
\begin_inset Formula $G_{x}$
\end_inset

 is 
\begin_inset Formula $(\lim D,x)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
The unique existence of 
\begin_inset Formula $x\in F\lim H$
\end_inset

 such that 
\begin_inset Formula $Gi=(Hi,Fp_{i}(x))$
\end_inset

 follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:data-functor-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and the fact that 
\begin_inset Formula $F$
\end_inset

 preserves 
\begin_inset Formula $\lim H$
\end_inset

.
 Let 
\begin_inset Formula $\C$
\end_inset

 denote the full subcategory of 
\begin_inset Formula $[\B,\Set]$
\end_inset

 of functors preserving 
\begin_inset Formula $\lim G$
\end_inset

.
 Note that 
\begin_inset Formula $\int F$
\end_inset

 is isomorphic to the opposite of the comma category 
\begin_inset Formula $K/F$
\end_inset

, where 
\begin_inset Formula $K:\op{\B}\rightarrow\C$
\end_inset

 is the Yoneda embedding, which preserves 
\begin_inset Formula $\colim G$
\end_inset

, by an argument similar to the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We conclude from the fact that the forgetful functor from a comma category
 
\begin_inset Formula $L/R$
\end_inset

 to the product of the categories creates colimits that 
\begin_inset Formula $L$
\end_inset

 preserve.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:preserves-elt"

\end_inset

Let 
\begin_inset Formula $I$
\end_inset

 be a small category, 
\begin_inset Formula $\B$
\end_inset

 and 
\begin_inset Formula $\B'$
\end_inset

 be categories with 
\begin_inset Formula $I$
\end_inset

-limits (i.e., limits of any diagram over 
\begin_inset Formula $I$
\end_inset

).
 Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 be a functor preserving those colimits.
 Then, 
\begin_inset Formula $\int F$
\end_inset

 has 
\begin_inset Formula $I$
\end_inset

-limits, preserved by the projection 
\begin_inset Formula $\int F\rightarrow\B$
\end_inset

.
 Moreover, a functor 
\begin_inset Formula $G:\int F\rightarrow\B'$
\end_inset

 preserves them if and only if for any 
\begin_inset Formula $d:I\rightarrow\B$
\end_inset

 and 
\begin_inset Formula $x\in F\lim d$
\end_inset

, the canonical morphism 
\begin_inset Formula $G(\lim d,x)\rightarrow\int_{i:I}G(d_{i},Fp_{i}(x))$
\end_inset

 is an isomorphism.
\end_layout

\begin_layout Proof
By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lim-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

, a diagram 
\begin_inset Formula $d':I\rightarrow\int F$
\end_inset

 is equivalently given by 
\begin_inset Formula $d:I\rightarrow\B$
\end_inset

 and 
\begin_inset Formula $x\in F\lim d$
\end_inset

, recovering 
\begin_inset Formula $d'$
\end_inset

 as 
\begin_inset Formula $d'_{i}=(d_{i},Fp_{i}(x))$
\end_inset

, and moreover 
\begin_inset Formula $\lim d'=(\lim d,x)$
\end_inset

.
 
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:can-iso-app"

\end_inset

Assuming that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits and each 
\begin_inset Formula $\Oby n$
\end_inset

 preserves finite connected limits, the finite limit preservation on 
\begin_inset Formula $\alpha:\int J\rightarrow{\cal A}$
\end_inset

 of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-simpl"
plural "false"
caps "true"
noprefix "false"

\end_inset

 can be reformulated as follows: given a finite connected diagram 
\begin_inset Formula $d:D\rightarrow{\cal A}$
\end_inset

 and element 
\begin_inset Formula $o\in\Oop n{\lim d}$
\end_inset

, the following canonical morphism is an isomorphism
\begin_inset Formula 
\[
\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j
\]

\end_inset

for any 
\begin_inset Formula $j\in\{1,\dots,n\}$
\end_inset

.
\end_layout

\begin_layout Proof
Note that, by definition, 
\begin_inset Formula $\nthar oj=\alpha_{n,j}(\lim d,o)$
\end_inset

, and 
\begin_inset Formula $\nthar{\rename o{p_{i}}}j=\alpha_{n,j}(d_{i},o\{p_{i}\})$
\end_inset

.
 This is a direct application of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

[Limits commute with dependent pairs]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lem:lim-commute-dependent-pairs"

\end_inset

Given functors 
\begin_inset Formula $K:I\rightarrow\Set$
\end_inset

 and 
\begin_inset Formula $G:\int K\rightarrow\Set$
\end_inset

, the following canonical morphism is an isomorphism
\begin_inset Formula 
\[
\coprod_{\alpha\in\lim K}\int_{i:I}G(i,p_{i}(\alpha))\rightarrow\int_{i:I}\coprod_{x\in Ki}G(i,x)
\]

\end_inset


\end_layout

\begin_layout Proof
The domain consists of a family 
\begin_inset Formula $(\alpha_{i})_{i\in I}$
\end_inset

 where 
\begin_inset Formula $\alpha_{i}\in K_{i}$
\end_inset

 together with a family 
\begin_inset Formula $(g_{i})_{i\in I}$
\end_inset

 where 
\begin_inset Formula $g_{i}\in G(i,\alpha_{i})$
\end_inset

, such that that for each morphism 
\begin_inset Formula $i\xrightarrow{u}j$
\end_inset

 in 
\begin_inset Formula $I$
\end_inset

, we have  
\begin_inset Formula $Ku(\alpha_{i})=\alpha_{j}$
\end_inset

 and 
\begin_inset Formula $(Gu)(g_{i})=g_{j}$
\end_inset

.
 
\end_layout

\begin_layout Proof
The codomain consists of a family 
\begin_inset Formula $(x_{i},g_{i})_{i\in I}$
\end_inset

 where 
\begin_inset Formula $x_{i}\in Ki$
\end_inset

 and 
\begin_inset Formula $g_{i}\in G(i,x_{i})$
\end_inset

, such that for each morphism 
\begin_inset Formula $i\xrightarrow{u}j$
\end_inset

 in 
\begin_inset Formula $I$
\end_inset

, we have 
\begin_inset Formula $Ku(x_{i})=x_{j}$
\end_inset

 and 
\begin_inset Formula $(Gu)(g_{i})=g_{j}$
\end_inset

.
 
\end_layout

\begin_layout Proof
The canonical morphism maps 
\begin_inset Formula $((x_{i})_{i\in I},(g_{i})_{i\in I})$
\end_inset

 to the family 
\begin_inset Formula $(x_{i},g_{i})_{i\in I}$
\end_inset

.
 It is clearly a bijection.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:coprod-filtered"

\end_inset

A coproduct 
\begin_inset Formula $\coprod_{i}G_{i}$
\end_inset

 of functors from a small category 
\begin_inset Formula ${\cal B}$
\end_inset

 with finite connected limits to 
\begin_inset Formula $Set$
\end_inset

 preserves those limits if and only if each 
\begin_inset Formula $G_{i}$
\end_inset

 does.
\end_layout

\begin_layout Proof
This is a consequence of the following statement, which is a direct application
 of 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 2.4 and Example 2.3.(iii)"
key "classificationaccessible"
literal "false"

\end_inset

: if 
\begin_inset Formula $\B$
\end_inset

 is a small category with finite connected limits, then a functor 
\begin_inset Formula $G:\B\rightarrow\Set$
\end_inset

 preserves those limits if and only if 
\begin_inset Formula $\int G$
\end_inset

 is a coproduct of filtered categories.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

Proof of 
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-simpl"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset

Let 
\begin_inset Formula $d:I\rightarrow{\cal A}$
\end_inset

 be a finite connected diagram and 
\begin_inset Formula $X$
\end_inset

 be a functor preserving finite connected limits.
 Then,
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{align*}
\int_{i:I}F(X)_{d_{i}} & =\int_{i:I}\coprod_{n}\coprod_{o\in\Oop n{d_{i}}}X_{\nthar o1}\times\dots\times X_{\nthar on}\\
 & \cong\coprod_{n}\int_{i:I}\coprod_{o\in\Oop n{d_{i}}}X_{\nthar o1}\times\dots\times X_{\nthar on}\tag{Coproducts commute with connected limits}\\
 & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}\int_{i:I}X_{\nthar{p_{i}(o)}1}\times\dots\times X_{\nthar{p_{i}(o)}n}\tag{By \prettyref{lem:lim-commute-dependent-pairs}}\\
 & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}\int_{i:I}X_{\nthar{p_{i}(o)}1}\times\dots\times\int_{i:I}X_{\nthar{p_{i}(o)}n}\tag{By commutation of limits}
\end{align*}

\end_inset

Thus, since 
\begin_inset Formula $X$
\end_inset

 preserves finite connected limits by assumption,
\begin_inset Formula 
\begin{align}
\int_{i}F(X)_{d_{i}} & =\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\label{eq:F-restrict-1}
\end{align}

\end_inset


\end_layout

\begin_layout Proof
Now, let us prove the only if statement first.
 Assume that each 
\begin_inset Formula $\Oby n$
\end_inset

 and 
\begin_inset Formula $\alpha_{n,i}:\int\Oby n\rightarrow{\cal A}$
\end_inset

 preserve finite connected limits.
 Then,
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{align*}
\int_{i}F(X)_{d_{i}} & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\tag{By Equation \prettyref{eq:F-restrict-1}}\\
 & \cong\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\int_{i:I}\nthar{\rename o{p_{i}}}1}\times\dots\times X_{\int_{i:I}\nthar{\rename o{p_{i}}}n}\tag{By assumption on \ensuremath{\Oby n}}\\
 & \cong\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\nthar o1}\times\dots\times X_{\nthar on}\tag{By Corollary \prettyref{cor:can-iso-app}}\\
 & =F(X)_{\lim d}
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Conversely, let us assume that 
\begin_inset Formula $F$
\end_inset

 restricts to an endofunctor on 
\begin_inset Formula $\C$
\end_inset

.
 Then, 
\begin_inset Formula $F(1)=\coprod_{n}\Oby n$
\end_inset

 preserves finite connected limits.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:coprod-filtered"
plural "false"
caps "true"
noprefix "false"

\end_inset

, each 
\begin_inset Formula $\Oby n$
\end_inset

 preserves finite connected limits.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:can-iso-app"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is enough to prove that given a finite connected diagram 
\begin_inset Formula $d:D\rightarrow{\cal A}$
\end_inset

 and element 
\begin_inset Formula $o\in\Oop n{\lim d}$
\end_inset

, the following canonical morphism is an isomorphism
\begin_inset Formula 
\[
\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\end_layout

\begin_layout Standard
Now, we have
\begin_inset Formula 
\begin{align*}
\int_{i:I}F(X)_{d_{i}} & \cong F(X)_{\lim d}\tag{By assumption}\\
 & =\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\nthar o1}\times\dots\times X_{\nthar on}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
On the other hand,
\begin_inset Formula 
\begin{align*}
\int_{i:I}F(X)_{d_{i}} & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\tag{By Equation \prettyref{eq:F-restrict-1}}\\
 & =\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\int_{i:I}\nthar{\rename o{p_{i}}}1}\times\dots\times X_{\int_{i:I}\nthar{\rename o{p_{i}}}n}\tag{\ensuremath{\Oby n} preserves finite connected limits}
\end{align*}

\end_inset

It follows from those two chains of isomorphisms that each function 
\begin_inset Formula $X_{\nthar oj}\rightarrow X_{\int_{i:I}\nthar{\rename o{p_{i}}}j}$
\end_inset

 is a bijection, or equivalently (by the Yoneda Lemma), that 
\begin_inset Formula $\C(K\nthar oj,X)\rightarrow\C(K\int_{i:I}\nthar{\rename o{p_{i}}}j,X)$
\end_inset

 is an isomorphism.
 Since the Yoneda embedding is fully faithful, 
\begin_inset Formula $\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j$
\end_inset

 is an isomorphism.
\end_layout

\end_deeper
\begin_layout Subsubsection
Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:lims-coprod-pw"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:lims-coprod-pw"

\end_inset


\end_layout

\begin_layout Standard
Cocompleteness follows from 
\begin_inset CommandInset citation
LatexCommand cite
after "Remark 1.56"
key "Adamek"
literal "false"

\end_inset

, since 
\begin_inset Formula $\C$
\end_inset

 is the category of models of a limit sketch, and is thus locally presentable,
 by
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Proposition 1.51"
key "Adamek"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
For the claimed closure property, all we have to check is that limits, coproduct
s, and filtered colimits of functors preserving finite connected limits
 still preserve finite connected limits.
 The case of limits is clear, since limits commute with limits.
 Coproducts and filtered colimits also commute with finite connected limits
 
\begin_inset CommandInset citation
LatexCommand citep
after "Example 1.3.(vi)"
key "classificationaccessible"
literal "false"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Corollary
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "cor:-T-res"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:T-res"

\end_inset

The result follows from the construction of 
\begin_inset Formula $T$
\end_inset

 using colimits of initial chains, thanks to the closure properties of 
\begin_inset Formula $\C$
\end_inset

.
 More specifically, 
\begin_inset Formula $TX$
\end_inset

 can be constructed as the colimit of the chain 
\begin_inset Formula $\emptyset\rightarrow H\emptyset\rightarrow HH\emptyset\rightarrow\dots$
\end_inset

, where 
\begin_inset Formula $\emptyset$
\end_inset

 denotes the constant functor mapping anything to the empty set, and 
\begin_inset Formula $HZ=FZ+X$
\end_inset

.
\end_layout

\begin_layout Section
Soundness of the pruning phase
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:pruning-phase"

\end_inset

In this section, we assume a pattern-friendly GB-signature 
\begin_inset Formula $S$
\end_inset

 and discuss soundness of the main rules of the two mutually recursive functions
 
\begin_inset Formula $\AgdaFunction{prune}$
\end_inset

 and 
\begin_inset Formula $\AgdaFunction{prune-\ensuremath{\sigma}}$
\end_inset

 listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-gen"
plural "false"
caps "true"
noprefix "false"

\end_inset

, which handles unification of two substitutions 
\begin_inset Formula $\delta:\dotmcontext{\Gamma'_{1}}\rightarrow\Gamma$
\end_inset

 and 
\begin_inset Formula $\substofrenamings x:\dotmcontext{\Gamma'_{1}}\rightarrow\dotmcontext{\Gamma'_{2}}$
\end_inset

 where 
\begin_inset Formula $\substofrenamings x$
\end_inset

 is induced by a vector of renamings 
\begin_inset Formula $x:\dotmcontext{\Gamma'_{2}}\Longrightarrow\dotmcontext{\Gamma'_{1}}$
\end_inset

.
 Strictly speaking, this is not unification as we introduced it because
 
\begin_inset Formula $\delta$
\end_inset

 and 
\begin_inset Formula $\substofrenamings x$
\end_inset

 do not target the same context, but it is straightforward to adapt the
 definition: a unifier is given by two substitutions 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 and 
\begin_inset Formula $\sigma':\dotmcontext{\Gamma'_{2}}\rightarrow\Delta$
\end_inset

 such that the following equation holds
\begin_inset Formula 
\begin{equation}
\delta[\sigma]=\substofrenamings x[\sigma']\label{eq:unif-pruning}
\end{equation}

\end_inset

As usual, the mgu is defined as the unifier uniquely factoring any other
 unifier.
 
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:cocone-pruning"

\end_inset

The right hand-side 
\begin_inset Formula $\substofrenamings x[\sigma']$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unif-pruning"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is actually equal to 
\begin_inset Formula $\rename{\sigma'}x$
\end_inset

.
 Indeed, 
\begin_inset Formula $\substofrenamings x=(\dots,M_{i}(x_{i}),\dots)$
\end_inset

 and 
\begin_inset Formula $M_{i}(x_{i})[\sigma']=\rename{\sigma'_{i}}{x_{i}}$
\end_inset

.
\end_layout

\begin_layout Standard
From a categorical point of view, such a mgu is characterised as a pushout.
\end_layout

\begin_layout Notation
Given
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\delta:\dotmcontext{\Gamma'_{1}}\rightarrow\Gamma$
\end_inset

, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $x:\dotmcontext{\Gamma'_{2}}\Longrightarrow\dotmcontext{\Gamma'_{1}}$
\end_inset

, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma':\dotmcontext{\Gamma'_{2}}\rightarrow\Delta$
\end_inset

,
\end_layout

\begin_layout Standard
the notation 
\begin_inset Formula $\Gamma\prunecat{\delta}x{\sigma}{\sigma'}{}\dashv\Delta$
\end_inset

 means that the square 
\begin_inset Formula $\begin{array}{c}
\xymatrix{\dotmcontext{\Gamma'_{1}}\ar[r]^{\substofrenamings x}\ar[d]_{\delta} & \dotmcontext{\Gamma'_{2}}\ar[d]^{\sigma'}\\
\Gamma\ar[r]_{\sigma} & \Delta
}
\end{array}$
\end_inset

 is a pushout in 
\begin_inset Formula $\Thbot S$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:pushout-notation"

\end_inset

This justifies the similarity between the pruning notation 
\begin_inset Formula $-\prunecat ----{}$
\end_inset

 and the pullback notation of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "not:highlighted-cat-notations"
plural "false"
caps "true"
noprefix "false"

\end_inset

, since pushouts in a category are nothing but pullbacks in the opposite
 category.
\end_layout

\begin_layout Standard
In the following subsections, we detail soundness of the rules for the rigid
 case (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:case-KA-RiTC"
plural "false"
caps "true"
noprefix "false"

\end_inset

) and then for the flex case (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:pruning-metavar"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The rules 
\begin_inset Formula $\refrule{P-Empty}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

 are straightforward adaptions specialised to those specific unification
 problems of the rules 
\begin_inset Formula $\refrule{U-Empty}$
\end_inset

 and 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 described later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:u-sequential"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The failing rule 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 is justified by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:diag-bot"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Rigid (rules P-Rig and P-Rig-Fail)
\end_layout

\end_inset

Rigid (rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Rig-Fail}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:case-KA-RiTC"

\end_inset


\end_layout

\begin_layout Personal Question
Maybe it would be clearer to use the epimorphic properties of coequalisers
 exposed in 
\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

?
\end_layout

\begin_layout Standard
The rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Rig-Fail}$
\end_inset

 handle non-cyclic unification of 
\begin_inset Formula $M(x)$
\end_inset

 with 
\begin_inset Formula $\dotmcontext{\Gamma};a\vdash o(\delta)$
\end_inset

 for some 
\begin_inset Formula $o\in\Oop na$
\end_inset

, where 
\begin_inset Formula $M\notin\dotmcontext{\Gamma}$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:cocone-pruning"
plural "false"
caps "true"
noprefix "false"

\end_inset

, a unifier is given by a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 and a term 
\begin_inset Formula $u$
\end_inset

 such that 
\begin_inset Formula 
\begin{equation}
o(\delta[\sigma])=\rename ux.\label{eq:unif-prig}
\end{equation}

\end_inset

Now, 
\begin_inset Formula $u$
\end_inset

 is either some 
\begin_inset Formula $M(\arg y)$
\end_inset

 or 
\begin_inset Formula $o'(\vec{v})$
\end_inset

.
 But in the first case, 
\begin_inset Formula $\rename ux=\rename{M(y)}x=M(\arg x\circ\arg y)$
\end_inset

, contradicting 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:unif-prig"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Therefore, 
\begin_inset Formula $u=o'(\delta')$
\end_inset

 for some 
\begin_inset Formula $o'\in\Oop nm$
\end_inset

 and 
\begin_inset Formula $\delta'$
\end_inset

 is a substitution from 
\begin_inset Formula $\alpha_{o'}$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

.
 Then, 
\begin_inset Formula $\rename ux=\rename{o'}x(\rename{\delta}{\ntharvecaction{o'}x{}})$
\end_inset

.
 It follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:unif-prig"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that 
\begin_inset Formula $o=\rename{o'}x$
\end_inset

, and 
\begin_inset Formula $\delta[\sigma]=\rename{\delta'}{\ntharvecaction{o'}x{}}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We introduce some notation for the latter condition.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Notation
Given 
\begin_inset Formula $f\in\hom_{\D}(a,b)$
\end_inset

 and 
\begin_inset Formula $o\in Ka\rightarrow O$
\end_inset

, we write 
\begin_inset Formula $o_{|f}\Rightarrow\bang$
\end_inset

 to mean that 
\begin_inset Formula $Kf$
\end_inset

 does not factor 
\begin_inset Formula $o$
\end_inset

.
 Otherwise, if 
\begin_inset Formula $o=o'\circ Kf$
\end_inset

, then we write 
\begin_inset Formula $o_{|f}\Rightarrow\underline{o'}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Remark
Note that if there were more than one possible 
\begin_inset Formula $o'$
\end_inset

, then the most general unifier would not exist.
 But such a 
\begin_inset Formula $o'$
\end_inset

, if it exists, is unique because 
\begin_inset Formula $K\arg x$
\end_inset

 is epimorphic, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:epis"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In fact, this is the only place where we use this property.
 As a consequence, we could weaken the condition that morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 are monomorphic and require instead that the image of such a morphism by
 
\begin_inset Formula $O$
\end_inset

 is monomorphic.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset

In case 
\begin_inset Formula $o=\acton{\arg x}{o'}$
\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

Note that there is at most one 
\begin_inset Formula $o'$
\end_inset

 such that 
\begin_inset Formula $o=\rename{o'}x$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:O-mono"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In this case, a unifier is equivalently given by substitutions 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 and 
\begin_inset Formula $\sigma':\alpha_{o'}\rightarrow\Delta$
\end_inset

 such that 
\begin_inset Formula $\delta[\sigma]=\rename{\sigma'}{\ntharvecaction{o'}x{}}$
\end_inset

.
 But, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:cocone-pruning"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this is precisely the data for a unifier of 
\begin_inset Formula $\delta$
\end_inset

 and 
\begin_inset Formula $x^{o'}$
\end_inset

.
 This actually induces an isomorphism between the two categories of unifiers,
 thus justifying the rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Rig-Fail}$
\end_inset

.
 
\end_layout

\begin_layout Subsection
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Flex (rule P-Flex)
\end_layout

\end_inset

Flex (rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:pruning-metavar"

\end_inset


\end_layout

\begin_layout Standard
The rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 handles unification of 
\begin_inset Formula $M(x)$
\end_inset

 with 
\begin_inset Formula $N(y)$
\end_inset

 where 
\begin_inset Formula $M\neq N$
\end_inset

 in a scope 
\begin_inset Formula $a$
\end_inset

.
 More explicitly, this is about computing the pushout of 
\begin_inset Formula $(X:a)\xrightarrow{{\cal L}x}(X:m)\cong(M:m)\xhookrightarrow{in_{M}}\dotmcontext{\Gamma}$
\end_inset

 and 
\begin_inset Formula $(X:a)\xrightarrow{{\cal L}y}(X:n)\cong(N:n)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that 
\begin_inset Formula $N(y)$
\end_inset

, as a substitution 
\begin_inset Formula $(X:a)\rightarrow(X:n)$
\end_inset

, is just 
\begin_inset Formula ${\cal L}y$
\end_inset

, while 
\begin_inset Formula $M(\arg x)$
\end_inset

 is 
\begin_inset Formula ${\cal L}\arg x[in_{M}]:(X:a)\rightarrow\Gamma$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:functor-L-intuition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\end_inset

Thanks to the following lemma, it is actually enough to compute the pushout
 of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

, taking 
\begin_inset Formula $A=(X:a)$
\end_inset

, 
\begin_inset Formula $B=(X:m)$
\end_inset

, 
\begin_inset Formula $C=(X:n)$
\end_inset

, 
\begin_inset Formula $Y=\dotmcontext{\Gamma}\backslash M$
\end_inset

, so that 
\begin_inset Formula $B+Y\cong\dotmcontext{\Gamma}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
YADE DIAGRAM diagrams/pushout-in.json
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
In any category, 
\begin_inset Note Note
status open

\begin_layout Lemma
denoting morphism composition by 
\begin_inset Formula $f\circ g=g[f]$
\end_inset

, the following rule applies
\begin_inset Formula 
\[
\dfrac{X\prune gf{\sigma}u\dashv Z}{X+Y\prune{g[in_{1}]}f{\sigma+Y}{u[in_{1}]}\dashv Z+Y}
\]

\end_inset


\end_layout

\begin_layout Lemma
In other words,
\end_layout

\end_inset

 if the square below left is a pushout, then so is the square below right.
\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1.5em}
\end_layout

\end_inset


\begin_inset Formula 
\[
\begin{array}{c}
\xymatrix{A\ar[r]^{f}\ar[d]_{g} & B\ar@{-->}[d]^{\sigma}\\
C\ar@{-->}[r]_{u} & Z
}
\end{array}\quad\begin{array}{c}
\xymatrix{A\ar[r]^{f}\ar[d]_{g} & B\ar[r]^{in_{1}} & B+Y\ar@{-->}[d]^{\sigma+Y}\\
C\ar@{-->}[r]_{u} & Z\ar@{-->}[r]_{in_{1}} & Z+Y
}
\end{array}.
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{c}
\xymatrix{A\ar[r]^{f}\ar[d]_{g} & B\ar[r]^{in_{1}} & B+Y\ar@{-->}[d]^{\sigma+Y}\\
C\ar@{-->}[r]_{u} & Z\ar@{-->}[r]_{in_{1}} & Z+Y
}
\end{array}$
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{c}
\xymatrix{A\ar[r]^{f}\ar[d]_{g} & B\ar@{-->}[d]^{u}\\
C\ar@{-->}[d]_{in_{1}} & Z\ar@{-->}[d]^{in_{1}}\\
C+Y\ar@{-->}[r]_{\sigma+Y} & Z+Y
}
\end{array}$
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJBIl0sWzAsMSwiWCJdLFsxLDAsIkIiXSxbMSwxLCJaI
l0sWzAsMSwiZyIsMl0sWzAsMiwiZiJdLFsxLDMsIlxcc2lnbWEiLDIseyJzdHlsZSI6eyJib2R5Ijp7I
m5hbWUiOiJkYXNoZWQifX19XSxbMiwzLCJ1IiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFza
GVkIn19fV1d
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	A & B 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	C & Z
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["g"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["f", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["
\backslash
sigma"', dashed, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["u", dashed, from=1-2, to=2-2]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
qquad
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	A & B 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	C & Z 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	{C+Y} & {Z+Y}
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["g"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["f", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{in_1}"', from=2-1, to=3-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma+Y}"', dashed, from=3-1, to=3-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["u", dashed, from=1-2, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{in_1}", dashed, from=2-2, to=3-2]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the pushout of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

 is the image by 
\begin_inset Formula ${\cal L}$
\end_inset

 of the pullback of 
\begin_inset Formula $\arg x$
\end_inset

 and 
\begin_inset Formula $\arg y$
\end_inset

 in 
\begin_inset Formula ${\cal A}$
\end_inset

, thus justifying the rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

.
\end_layout

\begin_layout Section
Soundness of the unification phase
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:coequalising-phase"

\end_inset


\end_layout

\begin_layout Standard
In this section, we assume a pattern-friendly GB-signature 
\begin_inset Formula $S$
\end_inset

 and discuss soundness of the main rules of the two mutually recursive functions
 
\begin_inset Formula $\AgdaFunction{unify}$
\end_inset

 and 
\begin_inset Formula $\AgdaFunction{unify-\ensuremath{\sigma}}$
\end_inset

 listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-gen"
plural "false"
caps "true"
noprefix "false"

\end_inset

, which compute coequalisers in 
\begin_inset Formula $\Thbot S$
\end_inset

.
 
\end_layout

\begin_layout Standard
The failing rules 
\begin_inset Formula $\refrule{U-Fail}$
\end_inset

 and 
\begin_inset Formula $\refrule{U-Id-Fail}$
\end_inset

 are justified by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:diag-bot"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Both rules 
\begin_inset Formula $\refrule{Clash}$
\end_inset

 and 
\begin_inset Formula $\refrule{U-Rig}$
\end_inset

 handle unification of two rigid terms 
\begin_inset Formula $o(\delta)$
\end_inset

 and 
\begin_inset Formula $o'(\delta')$
\end_inset

.
 If 
\begin_inset Formula $o\neq o'$
\end_inset

, they do not have any unifier: this is the rule 
\begin_inset Formula $\refrule{Clash}$
\end_inset

.
 If 
\begin_inset Formula $o=o'$
\end_inset

, then a substitution is a unifier if and only if it unifies 
\begin_inset Formula $\delta$
\end_inset

 and 
\begin_inset Formula $\delta'$
\end_inset

, thus justifying the 
\begin_inset Formula $\refrule{U-Rig}$
\end_inset

 rule.
\end_layout

\begin_layout Standard
In the next subsections, we discuss the rule sequential rules 
\begin_inset Formula $\refrule{U-Empty}$
\end_inset

 and 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:u-sequential"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the rule 
\begin_inset Formula $\refrule{No-Cycle}$
\end_inset

 transitioning to the pruning phase (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:no-cycle"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the rule 
\begin_inset Formula $\refrule{Same-MVar}$
\end_inset

 unifying metavariable with itself (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-flex-same-metavar"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and the failing rule 
\begin_inset Formula $\refrule{Cycle}$
\end_inset

 for cyclic unification of a metavariable with a term which includes it
 deeply (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-rig-cyclic"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Sequential unification (rules U-Empty and U-Split)
\end_layout

\end_inset

Sequential unification (rules 
\begin_inset Formula $\refrule{U-Empty}$
\end_inset

 and 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:u-sequential"

\end_inset

The rule 
\begin_inset Formula $\refrule{U-Empty}$
\end_inset

 is a direct application of the following general lemma.
\end_layout

\begin_layout Lemma
If 
\begin_inset Formula $A$
\end_inset

 is initial in a category, then any diagram of the shape 
\begin_inset Formula $\xymatrix{A\coeqr{}{} & B\ar[r]^{1_{B}} & B}
$
\end_inset

 is a coequaliser.
\end_layout

\begin_layout Standard
The rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 is a direct application of a stepwise construction of coequalisers valid
 in any category, as noted by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite[Theorem 9]{DBLP:books/daglib/0068768}
\end_layout

\end_inset

: if the first two diagrams below are coequalisers, then the last one as
 well.
\begin_inset Note Note
status open

\begin_layout Plain Layout
YADE DIAGRAM diagrams/coeq-pointwise.json
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsOCxbMCwxLCJBXzEiXSxbMSwxLCJcXEdhbW1hIl0sWzIsMSwiXFxEZ
Wx0YV8xIl0sWzMsMSwiQV8yIl0sWzQsMCwiXFxHYW1tYSJdLFs1LDEsIlxcRGVsdGFfMSJdLFs0LDIsI
lxcR2FtbWEiXSxbNiwxLCJcXERlbHRhXzIiXSxbMCwxLCJ0XzEiLDAseyJjdXJ2ZSI6LTF9XSxbMCwxL
CJ1XzEiLDIseyJjdXJ2ZSI6MX1dLFsxLDIsIlxcc2lnbWFfMSIsMCx7InN0eWxlIjp7ImJvZHkiOnsib
mFtZSI6ImRhc2hlZCJ9fX1dLFszLDQsInRfMiJdLFs0LDUsIlxcc2lnbWFfMSJdLFszLDYsInVfMiIsM
l0sWzYsNSwiXFxzaWdtYV8xIiwyXSxbNSw3LCJcXHNpZ21hXzIiLDAseyJzdHlsZSI6eyJib2R5Ijp7I
m5hbWUiOiJkYXNoZWQifX19XV0=
\end_layout

\begin_layout Plain Layout

$
\backslash
begin{tikzcd}[row sep=tiny]
\end_layout

\begin_layout Plain Layout

	&&&&[-20pt] 
\backslash
Gamma 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	{
\backslash
Gamma'_1} & 
\backslash
Gamma & {
\backslash
Delta_1} & {
\backslash
Gamma'_2} &&[-20pt] {
\backslash
Delta_1} & {
\backslash
Delta_2} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	&&&&[-10pt] 
\backslash
Gamma
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_1}", curve={height=-6pt}, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_1}"', curve={height=6pt}, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}", dashed, from=2-2, to=2-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_2}", from=2-4, to=1-5]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}", from=1-5, to=2-6]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_2}"', from=2-4, to=3-5]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}"', from=3-5, to=2-6]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2}", dashed, from=2-6, to=2-7]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout

$
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\xymatrix{\Gamma'_{1}+\Gamma'_{2}\coeqr{t_{1},t_{2}}{u_{1},u_{2}} & \Gamma\ar@{-->}[r]^{\sigma_{2}\circ\sigma_{1}} & \Delta_{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Lemma
\begin_inset Formula 
\[
\xymatrix{A_{1}+A_{2}\coeqr{t_{1},t_{2}}{u_{1},u_{2}} & \Gamma\ar@{-->}[r]^{\sigma_{2}\circ\sigma_{1}} & \Delta_{2}}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

[Theorem 9, 
\backslash
cite{DBLP:books/daglib/0068768}]
\end_layout

\end_inset

In any category, denoting morphism  composition 
\begin_inset Formula $f\circ g$
\end_inset

 by 
\begin_inset Formula $g[f]$
\end_inset

, the following rule applies.
\begin_inset Formula 
\[
\unificationstepwise{}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsMyxbMCwwLCJBXzErQV8yIl0sWzEsMCwiQiJdLFsyLDAsIkQiXSxbM
CwxLCJmXzEsZl8yIiwwLHsiY3VydmUiOi0yfV0sWzAsMSwiZl8xJyxmXzInIiwyLHsiY3VydmUiOjJ9X
SxbMSwyLCJ2XFxjaXJjIHUiXV0=
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	{A_1+A_2} & 
\backslash
Gamma & 
\backslash
Delta_2 	
\backslash
arrow["{t_1,t_2}"above, curve={height=-12pt}, from=1-1, to=1-2] 	
\backslash
arrow["{u_1,u_2}"', curve={height=12pt}, from=1-1, to=1-2] 	
\backslash
arrow["{
\backslash
sigma_2
\backslash
circ 
\backslash
sigma_1}", from=1-2, to=1-3, dashed] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We therefore get the rule
\begin_inset Formula 
\[
\unificationrigrig
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Flex-Rig, no cycle (rule No-Cycle)
\end_layout

\end_inset

Flex-Flex, no cycle (rule 
\begin_inset Formula $\refrule{No-Cycle}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:no-cycle"

\end_inset

The rule 
\begin_inset Formula $\refrule{No-Cycle}$
\end_inset

 transitions from unification to pruning.
 While unification is a coequaliser construction, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we explained that pruning is a pushout construction.
 The rule is justified by the following well-known connection between those
 two notions, taking 
\begin_inset Formula $B$
\end_inset

 to be 
\begin_inset Formula $\dotmcontext{\Gamma}\backslash M$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 to be the singleton context 
\begin_inset Formula $M:m$
\end_inset

, so that the coproduct of those two contexts in 
\begin_inset Formula $\Thbot S$
\end_inset

 is their disjoint union 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

.
\end_layout

\begin_layout Lemma
Consider a commuting square 
\begin_inset Formula $\begin{array}{c}
\xymatrix{A\ar[r]^{u}\ar[d]_{v} & B\ar[d]^{f}\\
C\ar[r]_{g} & D
}
\end{array}$
\end_inset

 in any category.
 If the coproduct 
\begin_inset Formula $B+C$
\end_inset

 of 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 exists, then this is a pushout if and only if 
\begin_inset Formula $B+C\xrightarrow{f,g}D$
\end_inset

 is the coequaliser of 
\begin_inset Formula $in_{1}\circ u$
\end_inset

 and 
\begin_inset Formula $in_{2}\circ v$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
YADE DIAGRAM diagrams/pushout-coeq-simpl.json
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\align center
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[every node/.style={inner sep=5pt,outer sep=0pt,anchor=base,tex
t height=1.2ex, text depth=0.25ex}] 
\end_layout

\begin_layout Plain Layout


\backslash
node (0) at (12.666666666666666em, -3.3333333333333335em) {$A$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
node (1) at (18em, -4.666666666666667em) {$C$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
node (2) at (18em, -2em) {$B$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
node (3) at (23.333333333333332em, -3.3333333333333335em) {$B+C$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
node (4) at (3.3333333333333335em, -2em) {$A$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
node (5) at (7.333333333333333em, -2em) {$B$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
node (6) at (7.333333333333333em, -6em) {$D$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
node (7) at (3.3333333333333335em, -6em) {$C$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
node (8) at (28.666666666666668em, -3.3333333333333335em) {$D$} ; 
\end_layout

\begin_layout Plain Layout


\backslash
path 
\end_layout

\begin_layout Plain Layout

(0) to[black,->, bend right={11.459155902616464}, ] node[coordinate](9){}
 (1) 
\end_layout

\begin_layout Plain Layout

(0) to[black,->, bend right={-11.459155902616464}, ] node[coordinate](10){}
 (2) 
\end_layout

\begin_layout Plain Layout

(2) to[black,->, bend right={-11.459155902616464}, ] node[coordinate](11){}
 (3) 
\end_layout

\begin_layout Plain Layout

(1) to[black,->, bend right={11.459155902616464}, ] node[coordinate](12){}
 (3) 
\end_layout

\begin_layout Plain Layout

(4) to[black,->, ] node[coordinate](13){} (5) 
\end_layout

\begin_layout Plain Layout

(5) to[black,->, ] node[coordinate](14){} (6) 
\end_layout

\begin_layout Plain Layout

(4) to[black,->, ] node[coordinate](15){} (7) 
\end_layout

\begin_layout Plain Layout

(7) to[black,->, ] node[coordinate](16){} (6) 
\end_layout

\begin_layout Plain Layout

(3) to[black,->, ] node[coordinate](17){} (8) 
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout


\backslash
path[->] 
\end_layout

\begin_layout Plain Layout

(0) edge["$
\backslash
scriptstyle $"', pos=0.5, black,->, bend right={11.459155902616464}, ] (1)
 
\end_layout

\begin_layout Plain Layout

(0) edge["$
\backslash
scriptstyle $", pos=0.5, black,->, bend right={-11.459155902616464}, ] (2)
 
\end_layout

\begin_layout Plain Layout

(2) edge["$
\backslash
scriptstyle in_1$", pos=0.5, black,->, bend right={-11.459155902616464}, ]
 (3) 
\end_layout

\begin_layout Plain Layout

(1) edge["$
\backslash
scriptstyle in_2$"', pos=0.5, black,->, bend right={11.459155902616464}, ]
 (3) 
\end_layout

\begin_layout Plain Layout

(4) edge["$
\backslash
scriptstyle $", pos=0.5, black,->, ] (5) 
\end_layout

\begin_layout Plain Layout

(5) edge["$
\backslash
scriptstyle f$", pos=0.5, black,->, ] (6) 
\end_layout

\begin_layout Plain Layout

(4) edge["$
\backslash
scriptstyle $", pos=0.5, black,->, ] (7) 
\end_layout

\begin_layout Plain Layout

(7) edge["$
\backslash
scriptstyle g$"', pos=0.5, black,->, ] (6) 
\end_layout

\begin_layout Plain Layout

(3) edge["$
\backslash
scriptstyle f{,}g$", pos=0.5, black,->, ] (8) 
\end_layout

\begin_layout Plain Layout

; 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{A\ar[r]\ar[d] & B\ar[d]^{f}\\
C\ar[r]_{g} & D
}
\qquad
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Subsection
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Flex-Flex, same metavariable (rule Same-MVar)
\end_layout

\end_inset

Flex-Flex, same metavariable (rule 
\begin_inset Formula $\refrule{Same-MVar}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:flex-flex-same-metavar"

\end_inset

Here we detail unification of 
\begin_inset Formula $M(x)$
\end_inset

 and 
\begin_inset Formula $M(y)$
\end_inset

, for 
\begin_inset Formula $x,y\in\hom_{{\cal A}}(m,a)$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:functor-L-intuition"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $M(\arg x)={\cal L}\arg x[in_{M}]$
\end_inset

 and 
\begin_inset Formula $M(\arg y)={\cal L}\arg y[in_{M}]$
\end_inset

.
 We exploit the following lemma with 
\begin_inset Formula $u={\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula $v={\cal L}\arg y$
\end_inset

.
\end_layout

\begin_layout Lemma
In any category, 
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

denoting morphism composition 
\begin_inset Formula $g\circ f$
\end_inset

 by 
\begin_inset Formula $f[g]$
\end_inset

 and coequalisers as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "not:cat-coeq"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the following rule applies:
\begin_inset Formula 
\[
\dfrac{B\vdash u=v\Rightarrow h\dashv C}{B+D\dashv u[in_{B}]=v[in_{B}]\Rightarrow h+1_{D}\dashv C+D}
\]

\end_inset

In other words,
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 if the below left diagram is a coequaliser, then so is the below right
 diagram.
 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[
\end_layout

\begin_layout Plain Layout


\backslash
xymatrix@R=2pt{A
\backslash
ar@<+.5ex>[r]^{u}
\backslash
ar@<-.5ex>[r]_{v} & B
\backslash
ar@{-->}[r]^{h} & C}
\backslash
quad
\backslash
begin{array}{c}
\backslash
xymatrix@C=1.5em@R=2pt{ & B
\backslash
ar[rd]^{in_{B}}
\backslash

\backslash
A
\backslash
ar[ru]^{u}
\backslash
ar[rd]_{v} &  & B+D
\backslash
ar@{-->}[r]^{h+1_{D}} & C+D
\backslash

\backslash
 & B
\backslash
ar[ru]_{in_{B}}}
\backslash
end{array}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{A\ar@<+.5ex>[r]^{u}\ar@<-.5ex>[r]_{v} & B\ar@{-->}[r]^{h} & C}
\qquad\begin{array}{c}
\xymatrix{ & B\ar[rd]^{in_{B}}\\
A\ar[ru]^{u}\ar[rd]_{v} &  & B+D\ar@{-->}[r]^{h+1_{D}} & C+D\\
 & B\ar[ru]_{in_{B}}
}
\end{array}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It follows that it is enough to compute the coequaliser of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

.
 Furthermore, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is the image by 
\begin_inset Formula ${\cal L}$
\end_inset

 of the equaliser of 
\begin_inset Formula $\arg x$
\end_inset

 and 
\begin_inset Formula $\arg y$
\end_inset

, thus justifying the rule 
\begin_inset Formula $\refrule{Same-MVar}$
\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Flex-rigid, cyclic (rule Cycle)
\end_layout

\end_inset

Flex-rigid, cyclic (rule 
\begin_inset Formula $\refrule{Cycle}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:flex-rig-cyclic"

\end_inset

The rule 
\begin_inset Formula $\refrule{Cycle}$
\end_inset

 handles unification of 
\begin_inset Formula $M(\arg x)$
\end_inset

 and a term 
\begin_inset Formula $t$
\end_inset

 such that 
\begin_inset Formula $t$
\end_inset

 is rigid and 
\begin_inset Formula $M$
\end_inset

 occurs in 
\begin_inset Formula $t$
\end_inset

.
 In this section, we show that indeed there is no successful unifier.
 More precisely, we prove 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:occurcheck-final"
plural "false"
caps "true"
noprefix "false"

\end_inset

 below, stating that if there is a unifier of a term 
\begin_inset Formula $t$
\end_inset

 and a metavariable application 
\begin_inset Formula $M(x)$
\end_inset

, then either 
\begin_inset Formula $M$
\end_inset

 occurs at top-level in 
\begin_inset Formula $t$
\end_inset

, or it does not occur at all.
 The argument follows the basic intuition that 
\begin_inset Formula $\sigma_{M}=t[M\mapsto\sigma_{M}]$
\end_inset

 is impossible if 
\begin_inset Formula $M$
\end_inset

 occurs deeply in 
\begin_inset Formula $u$
\end_inset

 because the sizes of both hand sides can never match.
 To make this statement precise, we need some recursive definitions and
 properties of size.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:size-occur-check"

\end_inset

The size 
\begin_inset Formula $|t|\in\mathbb{N}$
\end_inset

 of a proper term 
\begin_inset Formula $t$
\end_inset

 is recursively defined by 
\begin_inset Formula $|M(\arg x)|=0$
\end_inset

, and 
\begin_inset Formula $|o(\vec{t})|=1+|\vec{t}|$
\end_inset

, with 
\begin_inset Formula $|\vec{t}|=\sum_{i}t_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
We will also need to count the occurrences of a metavariables in a term.
\end_layout

\begin_layout Definition
For any term 
\begin_inset Formula $t$
\end_inset

 we define 
\begin_inset Formula $|t|_{M}$
\end_inset

 recursively by 
\begin_inset Formula $|M(\arg x)|_{M}=1$
\end_inset

, 
\begin_inset Formula $|N(\arg x)|_{M}=0$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 if 
\begin_inset Formula $N\neq M$
\end_inset

, and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $|o(\vec{t})|_{M}=|\vec{t}|_{M}$
\end_inset

 with the sum convention as above for 
\begin_inset Formula $|\vec{t}|_{M}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sizeM-factor"

\end_inset

For any term 
\begin_inset Formula $\text{\ensuremath{\dotmcontext{\Gamma};a\vdash}}t$
\end_inset

, if 
\begin_inset Formula $|t|_{M}=0$
\end_inset

, then 
\begin_inset Formula $\dotmcontext{\Gamma}\backslash M;a\vdash t$
\end_inset

.
 Moreover, for any 
\begin_inset Formula $\dotmcontext{\Gamma}=(M_{1}:m_{1},\dots,M_{n}:m_{n})$
\end_inset

, well-formed term 
\begin_inset Formula $t$
\end_inset

 in context 
\begin_inset Formula $\dotmcontext{\Gamma};a$
\end_inset

, and successful substitution 
\begin_inset Formula $\sigma:\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Delta}$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma]|=|t|+\sum_{i}|t|_{M_{i}}\times|\sigma_{i}|$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:size-consequences"

\end_inset

For any term 
\begin_inset Formula $t$
\end_inset

 in context 
\begin_inset Formula $\dotmcontext{\Gamma};a$
\end_inset

 with 
\begin_inset Formula $(M:m)\in\dotmcontext{\Gamma}$
\end_inset

, successful substitution 
\begin_inset Formula $\sigma:\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Delta}$
\end_inset

, morphism 
\begin_inset Formula $x\in\hom_{{\cal A}}(m,a)$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 in context 
\begin_inset Formula $\Delta;u$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma,M\mapsto u]|\geq|t|+|u|\times|t|_{M}$
\end_inset

 and 
\begin_inset Formula $|M(x)[u]|=|u|$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:occurcheck-final"

\end_inset

Let 
\begin_inset Formula $t$
\end_inset

 be a term in context 
\begin_inset Formula $\dotmcontext{\Gamma};a$
\end_inset

 with 
\begin_inset Formula $(M:m)\in\dotmcontext{\Gamma}$
\end_inset

 and 
\begin_inset Formula $x\in\hom_{{\cal A}}(m,a)$
\end_inset

 such that 
\begin_inset Formula $(M\mapsto u,\sigma):\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Delta}$
\end_inset

 unifies 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $M(x)$
\end_inset

.
 Then, either 
\begin_inset Formula $t=M(y)$
\end_inset

 for some 
\begin_inset Formula $y\in\hom_{{\cal A}}(m,a)$
\end_inset

, or 
\begin_inset Formula $\dotmcontext{\Gamma};a\vdash t$
\end_inset

.
 
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $t[\sigma,M\mapsto u]=M(x)[u]$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma,M\mapsto u]|=|M(x)[u]|$
\end_inset

.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:size-consequences"
plural "false"
caps "true"
noprefix "false"

\end_inset

 implies 
\begin_inset Formula $|u|\geq|t|+|u|\times|t|_{M}$
\end_inset

.
 Therefore, either 
\begin_inset Formula $|t|_{M}=0$
\end_inset

 and we conclude by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sizeM-factor"
plural "false"
caps "true"
noprefix "false"

\end_inset

, or 
\begin_inset Formula $|t|_{M}>0$
\end_inset

 and 
\begin_inset Formula $|t|=0$
\end_inset

, so that 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $M(\arg y)$
\end_inset

 for some 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Section
Termination and completeness
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:termination-completeness"

\end_inset


\end_layout

\begin_layout Subsection
Termination
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:termination"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Each inductive rule in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

 provides an elementary step for the construction of the most general unifier.
 To ensure that this set of rules describes a terminating algorithm, we
 essentially need two properties: 
\emph on
progress
\emph default
, i.e., there is always one rule that applies given some input data
\begin_inset Note Note
status open

\begin_layout Plain Layout
et aussi que ca preserve la propriete qu'une des branches est un coproduit
 +
\end_layout

\end_inset

, and 
\emph on
termination
\emph default
, i.e., there is no infinite sequence of rule applications.
 The former is ensured by Agda's type-checker.
\end_layout

\end_inset

 In this section, we sketch an explicit argument to justify termination
 of our algorithm described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-gen"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Note that the pruning and the unification phases are not mutually recursive:
 the latter depends on the former, but not conversely.
 Therfore, we can show first that the pruning phase terminates, and then
 that the unification does.
 Both phases involve three recursive calls (cf.
 the rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

, 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

, 
\begin_inset Formula $\refrule{U-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

).
 In each phase, the second recursive call for splitting is not structurally
 recursive, making Agda unable to check termination.
 However, we can devise an adequate notion of input size so that for each
 recursive call, the inputs are strictly smaller than the inputs of the
 calling site.
 First, we define the size 
\begin_inset Formula $|\dotmcontext{\Gamma}|$
\end_inset

 of a proper metacontext 
\begin_inset Formula $\dotmcontext{\Gamma}$
\end_inset

 as its length, while 
\begin_inset Formula $|\bot|=0$
\end_inset

 by definition.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We extend this definition to the case where 
\begin_inset Formula $\Gamma=\bot$
\end_inset

, by taking 
\begin_inset Formula $|\bot|=0$
\end_inset

.
\end_layout

\end_inset

 We also recursively define the size
\begin_inset Foot
status open

\begin_layout Plain Layout
The difference with the notion of size introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:size-occur-check"
plural "false"
caps "true"
noprefix "false"

\end_inset

 is that metavariable applications are now of size 1 instead of 0.
 
\end_layout

\end_inset

 
\begin_inset Formula $||t||$
\end_inset

 of a proper term 
\begin_inset Formula $t$
\end_inset

 by 
\begin_inset Formula $||M(\arg x)||=1$
\end_inset

 and 
\begin_inset Formula $||o(\vec{t})||=1+||\vec{t}||$
\end_inset

, with 
\begin_inset Formula $||\vec{t}||=\sum_{i}||t_{i}||$
\end_inset

.
 We also define the size of the error term 
\begin_inset Formula $||!||$
\end_inset

 as 
\begin_inset Formula $1$
\end_inset

.
 Note that no term is of size 0.
 
\end_layout

\begin_layout Definition
We say that a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 is 
\emph on
monotone 
\emph default
if 
\begin_inset Formula $||t[\sigma]||\leq||t||$
\end_inset

 for any term well-formed in the metacontext 
\begin_inset Formula $\Gamma$
\end_inset

.
\end_layout

\begin_layout Example
The error substitution 
\begin_inset Formula $\bang$
\end_inset

 is monotone since there is no term of size 0.
 A substitution 
\begin_inset Formula $\sigma:\dotmcontext{\Gamma}\rightarrow\dotmcontext{\Delta}$
\end_inset

 such that 
\begin_inset Formula $\sigma_{M}$
\end_inset

 is a metavariable application for any 
\begin_inset Formula $(M:m)\in\dotmcontext{\Gamma}$
\end_inset

 is monotone (as in the output of the rules 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 and 
\begin_inset Formula $\refrule{Same-MVar}$
\end_inset

).
\end_layout

\begin_layout Standard
Let us first quickly justify termination of the pruning phase.
 
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:pruning-monotone"

\end_inset

If there is a finite derivation tree of 
\begin_inset Formula $\Gamma\prune{\vec{t}}x{\sigma}{\vec{w}}\dashv\Delta$
\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\bot$
\end_inset

 is not connected because 
\begin_inset Formula $\bot+\bot=\bot$
\end_inset


\end_layout

\end_inset

 then 
\begin_inset Formula $\sigma$
\end_inset

 is monotone.
\end_layout

\begin_layout Corollary
The pruning phase always terminates.
\end_layout

\begin_layout Proof
Consider the above defined size of the input, which is a term 
\begin_inset Formula $t$
\end_inset

 for 
\begin_inset Formula $\AgdaFunction{prune}$
\end_inset

, or a list of terms 
\begin_inset Formula $\vec{t}$
\end_inset

 for 
\begin_inset Formula $\AgdaFunction{prune-\ensuremath{\sigma}}$
\end_inset

.
 It is straightforward to check that the sizes of the inputs of recursive
 calls are strictly smaller thanks to the previous lemma.
 Let us detail the case of the rule 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

.
 We show that the input 
\begin_inset Formula $\delta[\sigma_{1}]$
\end_inset

 of the second recursive call is smaller than the original input 
\begin_inset Formula $t,\delta$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:pruning-monotone"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we know that 
\begin_inset Formula $\sigma_{1}$
\end_inset

 is either a metavariable renaming or the error substitution 
\begin_inset Formula $\bang$
\end_inset

.
 Then,
\begin_inset Formula 
\begin{align*}
||\delta[\sigma_{1}]|| & \leq||\delta||\tag{By \prettyref{lem:pruning-monotone}}\\
 & <||\delta||+||t||\tag{No term is of size 0}\\
 & =||t,\delta||
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
For termination of the main unification phase, we consider the size of the
 input to be the (lexicographic) pair 
\begin_inset Formula $(|\Gamma|,||t||)$
\end_inset

 for 
\begin_inset Formula $\AgdaFunction{unify}$
\end_inset

 or 
\begin_inset Formula $(|\Gamma|,||\vec{t}||)$
\end_inset

 for 
\begin_inset Formula $\AgdaFunction{unify-\ensuremath{\sigma}}$
\end_inset

, given as input a pair of terms 
\begin_inset Formula $(t,t'$
\end_inset

) or lists of terms 
\begin_inset Formula $(\vec{t},\vec{t'})$
\end_inset

 in the metacontext 
\begin_inset Formula $\Gamma$
\end_inset

.
 
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:unif-size-smaller"

\end_inset

If there is a finite derivation tree of 
\begin_inset Formula $\Gamma\prune{\vec{t}}x{\sigma}{\vec{w}}\dashv\Delta$
\end_inset

 or 
\begin_inset Formula $\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

, then 
\begin_inset Formula $|\Gamma|\geq|\Delta|$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:unif-renaming"

\end_inset

If there is a finite derivation tree of 
\begin_inset Formula $\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

 such that 
\begin_inset Formula $|\Gamma|=|\Delta|$
\end_inset

, then 
\begin_inset Formula $\sigma$
\end_inset

 is monotone.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
The unification algorithm as defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-full-gen"
plural "false"
caps "true"
noprefix "false"

\end_inset

 always terminates.
\end_layout

\begin_layout Proof
It is straightforward to check that the sizes of the inputs of recursive
 calls are strictly smaller thanks to the previous lemmas.
 Let us detail the case of the rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

.
 We show that the size 
\begin_inset Formula $(|\Delta|,||\delta_{1}[\sigma]||)$
\end_inset

 of the second recursive call is strictly smaller than the size 
\begin_inset Formula $(|\Gamma|,||t_{1},\delta_{1}||)$
\end_inset

 of the original input.
 
\end_layout

\begin_layout Proof
If 
\begin_inset Formula $|\Delta|<|\Gamma|$
\end_inset

 then we are done.
 Otherwise, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:unif-size-smaller"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we have 
\begin_inset Formula $|\Delta|=|\Gamma|$
\end_inset

, and by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:unif-renaming"
plural "false"
caps "true"
noprefix "false"

\end_inset

,
\begin_inset Formula 
\[
||\delta_{1}[\sigma]||\leq||\delta_{1}||<||\delta_{1}||+||t_{1}||=||t_{1},\delta_{1}||
\]

\end_inset


\end_layout

\begin_layout Personal Question
Can we define it truly recursively?
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There are two recursive rules: 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unify-stepwise"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unifying-rec"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Contrary to the pruning phase, the first one is not structurally recursive
 since a substitution is applied to the argument.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Completeness
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:completeness"

\end_inset


\end_layout

\begin_layout Standard
In this section, we explain why soundness (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:coequalising-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

) and termination (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:termination"
plural "false"
caps "true"
noprefix "false"

\end_inset

) entail completeness.
 Intuitively, one may worry that the algorithm fails in cases where it should
 not.
 In fact, we already checked in the previous sections that failure only
 occurs when there is no unifier, as expected.
 Indeed, failure is treated as a free 
\begin_inset Quotes eld
\end_inset

terminal
\begin_inset Quotes erd
\end_inset

 unifier, as explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, by considering the category 
\begin_inset Formula $\Thbot S$
\end_inset

 extending category 
\begin_inset Formula $\Th S$
\end_inset

 with an error metacontext 
\begin_inset Formula $\bot$
\end_inset

.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:completeness-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

 implies that since the algorithm terminates and computes the coequaliser
 in 
\begin_inset Formula $\Thbot S$
\end_inset

, it always finds the most general unifier in 
\begin_inset Formula $\Th S$
\end_inset

 if it exists, and otherwise returns failure (i.e., the map to the terminal
 object 
\begin_inset Formula $\bot$
\end_inset

).
 
\end_layout

\begin_layout Section
Applications
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:applications"

\end_inset

In this section, we present various examples of pattern-friendly signatures
 summarised in Tables
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:GB-sig-systemF"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
We start in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ex-arg-sets"
plural "false"
caps "true"
noprefix "false"

\end_inset

 with a variant of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus where metavariable arguments are sets rather than lists.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we present simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus, as an example of syntax specified by a multi-sorted binding signature.
 We then explain in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 how we can handle 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

 equations by working on the normalised syntax.
 Next, we introduce an example of unification for ordered syntax in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ordered-calculus"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and finally we present an example of polymorphic such as System F, in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset

 , whose signature is implemented in Agda (see the supplemental material).
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the examples, we motivate the definition of the category 
\begin_inset Formula ${\cal A}$
\end_inset

 based on what we expect from metavariable arities, following 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:ar-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
fullshort{
\end_layout

\end_inset

We also adopt 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:shape-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

 , where the endofunctor 
\begin_inset Formula $F$
\end_inset

 is defined as
\begin_inset Formula 
\[
F(X)_{a}\cong\coprod_{\ell\in V}\coprod_{o\in O_{\ell}}\prod_{j\in\gamma_{\ell}}X_{H_{\ell,j}(a,o)}
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\backslash
rqshape}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection
Binding signatures
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "subsec:bidning-sig"

\end_inset

As a first step, let us parameterise the unification algorithm by a binding
 signature 
\begin_inset CommandInset citation
LatexCommand cite
key "BindingSignatures"
literal "false"

\end_inset

.
 A syntax is then specified by a set of symbols 
\begin_inset Formula $O$
\end_inset

 together with a list of natural numbers 
\begin_inset Formula $\vec{\alpha}_{o}$
\end_inset

 for each 
\begin_inset Formula $o\in O$
\end_inset

 specifying the number of arguments (the size of the list) and the number
 of bound variables in each argument.
 For example, pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus is specified by 
\begin_inset Formula $O=\{app,lam\}$
\end_inset

 with 
\begin_inset Formula $\vec{\alpha}_{app}=(0,0)$
\end_inset

 and 
\begin_inset Formula $\vec{\alpha}_{lam}=(1)$
\end_inset

.
 The unification algorithm described in the previous section straightforwardly
 generalises to any syntax specified by a binding signature.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises the generic algorithm that we will later interpret in a more
 general setting, where metavariable arguments are morphisms in a category.
 Since nothing enforces them to be lists
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ex-arg-sets"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Section 8.2"
key "longgenericunif"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ex-arg-sets"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

 for an example where arguments are sets.
\end_layout

\end_inset

, the vector notation is dropped for these arguments in the figure, but
 we still use it in the following specialisation to syntax specified by
 a binding signature.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises the generic algorithm that we will later interpret in a more
 broader setting.
 In this general setting, metavariable arguments are morphisms in a category:
 nothing enforces them to be lists.
\end_layout

\begin_layout Plain Layout
In the figure, the vector notation for the arguments of metavariables is
 dropped because in the general setting we consider in this paper, nothing
 enforces them to be lists .
 We still use the vector notation in the following specialisation to a syntax
 specified by a binding signature.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In the rule 
\begin_inset Formula $\refrule{U-RigRig}$
\end_inset

, the expression 
\begin_inset Formula $o(\vec{t})$
\end_inset

 can be an operation or a variable, in which case 
\begin_inset Formula $\vec{t}$
\end_inset

 is the empty list.
 If 
\begin_inset Formula $o$
\end_inset

 is an operation, the exact nature of 
\begin_inset Formula $\vec{t}$
\end_inset

 depends on the arity 
\begin_inset Formula $(\alpha_{1},\dots,\alpha_{p})$
\end_inset

 of 
\begin_inset Formula $o$
\end_inset

: then 
\begin_inset Formula $\vec{t}$
\end_inset

 is a list of terms of size 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $\Gamma;n+\alpha_{i}\vdash t_{i}$
\end_inset

 for each 
\begin_inset Formula $i\in\{1,\dots,p\}$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the scope of 
\begin_inset Formula $o(\vec{t})$
\end_inset

.
 The rigid case for operations in the pruning phase consists in the following
 rule.
\begin_inset Formula 
\[
\dfrac{\Gamma\prune{\vec{t}}{M_{1}(\vec{x},\overbrace{v_{n+1},\mydots,v_{n+1+\alpha_{1}}}^{\mathclap{\text{bound variables}}}),\mydots,M_{p}(\mydots)}{\sigma}{\vec{u}}\dashv\Delta}{\Gamma\prune{o(\vec{t})}{M(\arg{\vec{x}})}{\sigma}{o(\vec{u})}\dashv\Delta}
\]

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The notation 
\begin_inset Formula ${\cal L}^{+}\vec{x}^{o}$
\end_inset

 indeed essentially unfolds to 
\begin_inset Formula $\maybold M_{1}(\vec{x})+\maybold M_{2}(\vec{x})$
\end_inset

 in the application case, and to 
\begin_inset Formula $\maybold M'(\vec{x},|C|)$
\end_inset

 in the abstraction case.
 The rule 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 applies when there is no such 
\begin_inset Formula $o'$
\end_inset

, a situation which we denote by 
\begin_inset Formula $o\neq\vec{x}\cdot\dots$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Note that the premises of the rules 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 are not explicitly defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

, although for a syntax specified by a binding signature, they have the
 same meaning as in the previous section.
 In fact, the generic algorithm works in a more general setting, as we are
 going to explain in the next section, so that they need to be customised
 for each specific situation.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
we propose an interpretation of typing rules to define the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 accounting for the syntax:
\begin_inset Formula 
\[
\Gamma
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Examples of (pattern-friendly) GB-signatures (
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:GB-signature"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:all-syntax"

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\vec{\sigma}\arSep\tau)=\mydots+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{o}=(\mydots)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $()$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\vdash t:\tau'\Rightarrow\tau\quad\Gamma\vdash u:\tau'}{\Gamma\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in T\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{l}
\vec{\sigma}\arSep(\tau'\Rightarrow\ensuremath{\tau})\\
\vec{\sigma}\arSep\tau'
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\vec{\sigma},\tau_{1}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta\eta$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\vec{\sigma}\arSep\tau)=\mydots+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{o}=(\mydots)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{\begin{array}{c}
x:(\tau_{1},\dots,\tau_{n})\Rightarrow\iota\in(\Gamma,\vec{y}:\vec{\tau}_{0})\\
\forall i\in\{1,\dots,n\}\ \Gamma,\vec{y}:\vec{\tau}\vdash t_{i}:\tau_{i}
\end{array}}{\Gamma\vdash\lambda\vec{y}.x\vec{t}:\vec{\tau}_{0}\Rightarrow\iota}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{c}
\{a_{j,\tau_{1},\dots,\vec{\tau}_{0},\iota_{0}}|\tau=\vec{\tau}_{0}\Rightarrow\iota,\\
j\in|\vec{\sigma}|_{\vec{\tau}\Rightarrow\iota}\}
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{c}
\vec{\sigma},\vec{\tau}_{0}\arSep\tau_{1}\\
\dots\\
\vec{\sigma},\vec{\tau}_{0}\arSep\tau_{n}
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\vec{\sigma}\arSep\tau)=\mydots+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{o}=(\mydots)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\vec{\tau}'\Rightarrow\tau\in\Gamma\quad\tau\text{ is a base type}\quad\Gamma\vdash\vec{t}:\vec{\tau}'}{\Gamma\vdash x\vec{t}:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{c}
\{a_{i,\tau'_{1},\dots,\tau'_{n}}|i\in|\vec{\sigma}|_{\vec{\tau}'\Rightarrow\tau}\\
\text{ and \ensuremath{\tau} is a base type}\}
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{c}
\vec{\sigma}\arSep\tau'_{1}\\
\dots\\
\vec{\sigma}\arSep\tau'_{n}
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\vec{\sigma},\tau_{1}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ordered-calculus"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ordered-calculus"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(\vec{\sigma}\Fsep\vec{\omega}\arSep\tau)=\mydots+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{o}=(\mydots)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{\Gamma\Fsep\cdot\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\text{\text{ and }\ensuremath{\vec{\omega}=()}}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $()$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{}{\Gamma\Fsep x:\tau\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v^{>}|\text{\ensuremath{\vec{\omega}=()}}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $()$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega\vdash t:\tau'\Rightarrow\tau\quad\Gamma\Fsep\cdot\vdash u:\tau'}{\Gamma\Fsep\Omega\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in T\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{l}
\vec{\sigma}\Fsep\vec{\omega}\arSep(\tau'\Rightarrow\ensuremath{\tau})\\
\vec{\sigma}\Fsep()\arSep\tau'
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega_{1}\vdash t:\tau'\twoheadrightarrow\tau\quad\Gamma\Fsep\Omega_{2}\vdash u:\tau'}{\Gamma\Fsep\Omega_{1},\Omega_{2}\vdash t^{>}\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{c}
\{a_{\tau'}^{\vec{\omega}_{1},\vec{\omega}_{2}}|\tau'\in T\text{ and }\\
\ensuremath{\vec{\omega}=\vec{\omega}_{1},\vec{\omega}_{2}}\}
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{l}
\vec{\sigma}\Fsep\vec{\omega}_{1}\arSep(\tau'\twoheadrightarrow\ensuremath{\tau})\\
\vec{\sigma}\Fsep\vec{\omega}_{2}\arSep\tau'
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\Fsep\Omega\vdash t:\tau_{2}}{\Gamma\Fsep\Omega\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\vec{\sigma},\tau_{1}\Fsep\vec{\omega}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\Fsep\Omega\vdash\lambda^{>}x.t:\tau_{1}\twoheadrightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}^{>}|\tau=(\tau_{1}\twoheadrightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\vec{\sigma},\tau_{1}\Fsep\vec{\omega}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
The (pattern-friendly) GB-signature of (syntactic) system F (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:GB-sig-systemF"

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O(p|\vec{\sigma}\rightarrow\tau)=\mydots+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{o}=(\mydots)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{n\Fsep\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n\Fsep\Gamma\vdash t:\tau'\Rightarrow\tau\quad n\Fsep\Gamma\vdash u:\tau'}{n\Fsep\Gamma\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in S_{n}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{l}
n\Fsep\vec{\sigma}\arSep\tau'\Rightarrow\ensuremath{\tau}\\
n\Fsep\vec{\sigma}\arSep\tau'
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n\Fsep\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{n\Fsep\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n\Fsep\vec{\sigma},\tau_{1}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n\Fsep\Gamma\vdash t:\forall\tau_{1}\quad\tau_{2}\in S_{n}}{n\Fsep\Gamma\vdash t\cdot\tau_{2}:\tau_{1}[\tau_{2}]}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{A_{\tau_{1},\tau_{2}}|\tau=\tau_{1}[\tau_{2}]\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n\Fsep\vec{\sigma}\arSep\forall\tau_{1})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n+1\Fsep wk(\Gamma)\vdash t:\tau}{n\Fsep\Gamma\vdash\Lambda t:\forall\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{\Lambda_{\tau'}|\tau=\forall\tau'\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n+1\Fsep wk(\vec{\sigma})\arSep\tau')$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Metavariable arguments as sets
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:ex-arg-sets"

\end_inset

If we think of the arguments of a metavariable as specifying the available
 variables, then it makes sense to assemble them in a set rather than in
 a list.
 This motivates considering the category 
\begin_inset Formula ${\cal A}=\mathbb{I}$
\end_inset

 whose objects are natural numbers and a morphism 
\begin_inset Formula $n\rightarrow p$
\end_inset

 is a subset of 
\begin_inset Formula $\{1,\dots,p\}$
\end_inset

 of cardinal 
\begin_inset Formula $n$
\end_inset

.
 Equivalently, 
\begin_inset Formula $\mathbb{I}$
\end_inset

 can be taken as subcategory of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 consisting of strictly increasing injections, or as the subcategory of
 the augmented simplex category consisting of injective functions.
 Then, a metavariable takes as argument a set of variables, rather than
 a list of distinct variables.
 In this approach, unifying two metavariables (see the rules 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

) amount to computing a set intersection.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Arities as sets
\end_layout

\begin_layout Standard
In this example, we describe pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with metavariables whose arities are sets of free variables.
 They do not take any explicit argument and they cannot be applied to bound
 variables.
 
\end_layout

\begin_layout Standard
We adopt a locally nameless approach, with two kinds of variables: the named
 ones, chosen in an infinite set 
\begin_inset Formula ${\cal V}$
\end_inset

 of names (e.g., 
\begin_inset Formula $\mathbb{N}$
\end_inset

), and the unnamed ones, as before, which will be used for binding.
 We thus choose 
\begin_inset Formula $\mathcal{A}$
\end_inset

 to be 
\begin_inset Formula $\mathbb{S}\times\mathbb{F}_{m}$
\end_inset

 where 
\begin_inset Formula $\mathbb{S}$
\end_inset

 is the category of finite subsets of 
\begin_inset Formula $\mathcal{V}$
\end_inset

 and inclusions (not injections!) between them.
 Pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus can be specified by an endofunctor 
\begin_inset Formula $F$
\end_inset

 defined by 
\begin_inset Formula $F(X)_{A,n}=n+A+X_{A,n+1}+X_{A,n}\times X_{A,n}$
\end_inset

.
\end_layout

\begin_layout Standard
A metavariable arity, as an object of 
\begin_inset Formula ${\cal A}$
\end_inset

, consists of two components: a finite set of named variables, and a number
 of arguments among unnamed variables.
 Let us define pure arities as those whose second component is 
\begin_inset Formula $0$
\end_inset

.
 A metavariable is said pure if its arity is, and a metacontext is said
 pure if each metavariable is.
 
\end_layout

\begin_layout Standard
The pure metavariables are the ones mentioned at the beginning of this section.
 Unifying a pure metavariable with itself, as in the rule 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

, is a no-op, while unifying a pure metavariable with another one (rule
 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

) produces a new pure metavariable whose arity is the intersection of the
 input metavariable arities.
 Exploiting this observation, an easy induction shows that the most general
 unifier targets a pure metacontext.
\end_layout

\begin_layout Lemma
Assume an endofunctor for syntax as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:endo-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 If 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 or 
\begin_inset Formula $\Gamma\prune t{\coprod_{i}{\cal L}f_{i}}{\sigma}u\dashv\Delta$
\end_inset

, and 
\begin_inset Formula $\Delta\neq\bot$
\end_inset

, then 
\begin_inset Formula $\Delta$
\end_inset

 is pure whenever 
\begin_inset Formula $\Gamma$
\end_inset

 is.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\color red
I don't know if that's useful
\color inherit
: the metavariable arity rather specify which closest bound variables it
 can use.A metavariable can be substituted with another if the arity of the
 latter is included in the arity of the former.
 This motivates considering the category 
\begin_inset Formula ${\cal A}=\mathbb{S}$
\end_inset

 whose objects are finite subsets of 
\begin_inset Formula $\mathbb{N}$
\end_inset

, and morphisms are inclusions.
 In this approach, the rule 
\begin_inset Formula $\textsc{U-FlexFlex}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 unifying a metavariable with itself is a no-op, while unifying a metavariable
 with another one (rule 
\begin_inset Formula $\textsc{P-Flex}$
\end_inset

) amounts to computing the intersection of their arities.
\end_layout

\begin_layout Plain Layout
We can adapt the specification of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus to this setting: 
\begin_inset Formula $F(X)_{A}=A+X_{A}\times X_{A}+X_{A+1}$
\end_inset

, where 
\begin_inset Formula $A\mapsto A+1$
\end_inset

 is the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping a subset 
\begin_inset Formula $A$
\end_inset

 of 
\begin_inset Formula $\mathbb{N}$
\end_inset

 to 
\begin_inset Formula $\{0\}\cup\{a+1|a\in A\}$
\end_inset

.
 Let us describe inductively the syntax.
 a scope 
\begin_inset Formula $C$
\end_inset

 is then a finite subset of 
\begin_inset Formula $\mathbb{N}$
\end_inset

.
\begin_inset Formula 
\[
\dfrac{x\in C}{\Gamma;C\vdash x}\qquad\dfrac{\Gamma;C\vdash t\quad\Gamma;C\vdash u}{\Gamma;C\vdash t\ u}\qquad\dfrac{\Gamma;C+1\vdash t}{\Gamma;C\vdash\lambda t}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{M:A\in\Gamma\quad A\subset C}{\Gamma;C\vdash M}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Note that a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $\{0\}$
\end_inset

 can be used either at top level in the scope 
\begin_inset Formula $\{0\}$
\end_inset

, or in 
\begin_inset Formula $\lambda t$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Thinking of metavariables as sets rather than
\end_layout

\begin_layout Plain Layout
Consider 
\begin_inset Formula $\mathbb{S}$
\end_inset

 the category where objects are natural numbers and a morphism 
\begin_inset Formula $n\rightarrow p$
\end_inset

 is a subset of 
\begin_inset Formula $\{0,\dots,p-1\}$
\end_inset

 of cardinal 
\begin_inset Formula $n$
\end_inset

.
 For instance, 
\begin_inset Formula $\mathbb{S}$
\end_inset

 can be taken as subcategory of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 consisting of strictly increasing injections, or as the subcategory of
 the augmented simplex category consisting of injective functions.
 Again, we can define the endofunctor for 
\begin_inset Formula $\lambda$
\end_inset

-calculus as before.
 Then, a metavariable takes as argument a set of available variables, rather
 than a list of distinct variables.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Subsection
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "subsec:quantum-lambda"

\end_inset

Ca nemarche pasIn this section we explain how we can define pattern unification
 for quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/popl/PaganiSV14"
literal "false"

\end_inset

.
 We denote by 
\begin_inset Formula $S$
\end_inset

 the set of types, which is inductively generated as follows
\begin_inset Formula 
\[
A,B,C\in S::=\mathbf{qubit}|A\multimap B|!(A\multimap B)|1|A\otimes B|A+B|A^{\ell}
\]

\end_inset

where 
\begin_inset Formula $A^{\ell}$
\end_inset

 is intuitively the type of finite lists of elements of type 
\begin_inset Formula $A$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We denote by 
\begin_inset Formula $!S$
\end_inset

 the set of non-linear types, that is, types of the shape 
\begin_inset Formula $!-$
\end_inset

.
 In fact 
\begin_inset Formula $!S$
\end_inset

 is isomorphic to 
\begin_inset Formula $S\times S$
\end_inset

, since any non linear type must be of the shape 
\begin_inset Formula $!(A\multimap B)$
\end_inset

.
 We denote by 
\begin_inset Formula $\boldsymbol{S}$
\end_inset

 the set of linear types.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We consider metavariable arities of the shape 
\begin_inset Formula $\Delta\vdash A$
\end_inset

, where 
\begin_inset Formula $\Delta$
\end_inset

 is the multiset of the argument types, and 
\begin_inset Formula $A$
\end_inset

 is the output type of the metavariable.
 We denote by 
\begin_inset Formula $!\Delta$
\end_inset

 the non linear part of 
\begin_inset Formula $\Delta$
\end_inset

, i.e., its sub-multiset consisting of its non-linear types, that is, types
 of the shape 
\begin_inset Formula $!A$
\end_inset

.
 We denote by 
\begin_inset Formula $\boldsymbol{\Delta}$
\end_inset

 the linear part of 
\begin_inset Formula $\Delta$
\end_inset

.
 Substituting a metavariable of arity 
\begin_inset Formula $\Delta_{1}\vdash A_{1}$
\end_inset

 with a metavariable of arity 
\begin_inset Formula $\Delta_{2}\vdash A_{2}$
\end_inset

 requires that 
\begin_inset Formula $A_{1}=A_{2}$
\end_inset

, 
\begin_inset Formula $\boldsymbol{\Delta_{1}}=\boldsymbol{\Delta_{2}}$
\end_inset

, and an injective renaming 
\begin_inset Formula $\bang\Delta_{1}\hookrightarrow\bang\Delta_{2}$
\end_inset

.
 Therefore, we choose 
\begin_inset Formula ${\cal A}$
\end_inset

 to be the category whose objects are metavariable arities 
\begin_inset Formula $\Delta\vdash A$
\end_inset

 and the set of morphisms between 
\begin_inset Formula $\Delta_{1}\vdash A_{1}$
\end_inset

 and 
\begin_inset Formula $\Delta_{2}\vdash A_{2}$
\end_inset

 is empty if 
\begin_inset Formula $A_{1}\neq A_{2}$
\end_inset

 or 
\begin_inset Formula $\boldsymbol{\Delta_{1}}\neq\boldsymbol{\Delta_{2}}$
\end_inset

, or is the set of injective renamings between 
\begin_inset Formula $!\Delta_{1}$
\end_inset

 and 
\begin_inset Formula $\bang\Delta_{2}$
\end_inset

 otherwise.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
A metavariable could have linear arguments, and non linear ones.
 We therefore consider metavariable arities 
\begin_inset Formula $\Gamma;!\Delta\vdash A$
\end_inset

, where 
\begin_inset Formula $\Gamma$
\end_inset

 is a finite multi-set of linear types, 
\begin_inset Formula $!\Delta$
\end_inset

 is a multi-set of non linear types, and 
\begin_inset Formula $A$
\end_inset

 is the output type of the metavariable.
 Substituting a metavariable of arity 
\begin_inset Formula $\Gamma_{1};!\Delta_{1}\vdash A_{1}$
\end_inset

 with a metavariable of arity 
\begin_inset Formula $\Gamma_{2};!\Delta_{2}\vdash A_{2}$
\end_inset

 requires that 
\begin_inset Formula $\Gamma_{1}=\Gamma_{2}$
\end_inset

, 
\begin_inset Formula $A_{1}=A_{2}$
\end_inset

, and an injective renaming 
\begin_inset Formula $!\Delta_{1}\hookrightarrow!\Delta_{2}$
\end_inset

.
 Therefore, we choose 
\begin_inset Formula ${\cal A}=\bang S\times\mathbb{R}[\underline{S}]\times S$
\end_inset

, where 
\begin_inset Formula $\mathbb{R}[\underline{S}]$
\end_inset

 is the category of multisets in 
\begin_inset Formula $\underline{S}$
\end_inset

 and injective renamings between them.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The components of the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 are specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:quantum-endo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except for the promotion, which we discuss below.
 We use the following notations.
\end_layout

\begin_layout Notation
\begin_inset Formula $\delta(P)$
\end_inset

 denotes either a singleton set or the empty set, depending on whether the
 property 
\begin_inset Formula $P$
\end_inset

 is true.
\end_layout

\begin_layout Notation
\begin_inset Formula $|\Delta|_{!C}$
\end_inset

 denotes the number of occurrences of 
\begin_inset Formula $!C$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

.
 By convention, we take it to be 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $!C$
\end_inset

 does not make sense (i.e., when 
\begin_inset Formula $C$
\end_inset

 is not 
\begin_inset Formula $A\multimap B$
\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
, listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:quantum-endo"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 A type 
\begin_inset Formula $\boldsymbol{A}$
\end_inset

 in bold face is implicitly assumed to be linear; a multiset 
\begin_inset Formula $\boldsymbol{\Gamma}$
\end_inset

 in bold face is implicitly assumed to consist of linear types only.
 A context 
\begin_inset Formula $!\Delta$
\end_inset

 in the typing rules consists of non linear types only.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first rule handles the term constants in 
\begin_inset Formula ${\cal C}=\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}$
\end_inset

, that all have typing rules of the following shape
\begin_inset Formula 
\[
\dfrac{c\in{\cal C}}{!\Delta\vdash c:A_{c}\multimap B_{c}}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Here, the context 
\begin_inset Formula $!\Delta$
\end_inset

 consists only of non linear types.
 We take
\begin_inset Formula 
\[
O_{c}(\Delta\vdash C)=\delta(\Delta\vdash C=\bang\Delta\vdash A_{c}\multimap B_{c})\qquad\gamma_{c}=0
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula ${\cal A}(\emptyset\vdash A_{c}\multimap B_{c},\Gamma\vdash C)$
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{c}}y(\emptyset\vdash A_{c}\multimap B_{c})
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
where 
\begin_inset Formula $\delta(P)$
\end_inset

 denotes either a singleton set or the empty set, depending on whether 
\begin_inset Formula $P$
\end_inset

 is true.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, 
\begin_inset Formula ${\cal A}(\emptyset\vdash\tau,\Delta\vdash C)$
\end_inset

 is non-empty and a singleton set precisely when 
\begin_inset Formula $A=\tau$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\Delta}=\emptyset$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Now, we introduce the linear variable case
\begin_inset Formula 
\[
\infer[ax]{\bang{\Delta},x:A\entail x:A}{\text{\ensuremath{A} linear}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
we take
\begin_inset Formula 
\[
O_{v}(\Delta\vdash C)=\delta(\boldsymbol{\Delta}=C)\qquad\gamma_{v}=0
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{\boldsymbol{A}}y(\boldsymbol{A}\vdash\boldsymbol{A})}
\]

\end_inset

where 
\begin_inset Formula $|\Delta|_{\boldsymbol{A}}$
\end_inset

 counts the number of occurrences of 
\begin_inset Formula $\boldsymbol{A}$
\end_inset

 inIndeed, 
\begin_inset Formula $y(\boldsymbol{A}\vdash\boldsymbol{A})$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is a singleton set (accounting for the variable 
\begin_inset Formula $x$
\end_inset

) and non empty precisely when 
\begin_inset Formula $\Delta$
\end_inset

 is of the shape 
\begin_inset Formula $!\Delta,x:\boldsymbol{A}$
\end_inset

, and 
\begin_inset Formula $\tau=\boldsymbol{A}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us handle the non linear variable case.
\begin_inset Formula 
\[
\infer[axd]{\bang{\Delta},x:\bang(A\loli B)\entail x:A\loli B}{}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
We take
\begin_inset Formula 
\[
O_{v!}(\Delta\vdash C)=\delta(\Delta=\bang\Delta)\times|\Delta|_{!C}\qquad\gamma_{v!}=0
\]

\end_inset

where 
\begin_inset Formula $|\Delta|_{!C}$
\end_inset

 counts the number of occurrences of 
\begin_inset Formula $!C$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

.
 By convention, we take it to be 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $!C$
\end_inset

 does not make sense.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, 
\begin_inset Formula $y(!(A\multimap B)\vdash A\multimap B)$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is the number (as a cardinal set) of occurences of 
\begin_inset Formula $!(A\multimap B)$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

, whenever 
\begin_inset Formula $\tau=A\multimap B$
\end_inset

 (otherwise, it is the empty set).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us now handle the 
\begin_inset Formula $\lambda$
\end_inset

-abstraction rule.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\infer[\loli_{I}]{\Delta\entail\lambda x^{A}.M:A\loli B}{\Delta,x:A\entail M:B}
\]

\end_inset

Denoting linear contexts with a bold face, we take
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
O_{l}(\Delta\vdash C)=\{l_{A,B}|C=A\multimap B)\qquad H_{l,1}(\Delta\vdash C,l_{A,B})=(\Delta,A\vdash B)
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
where 
\begin_inset Formula $\underline{\Delta},A\vdash B$
\end_inset

 denotes the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping 
\begin_inset Formula $\Delta'\vdash A'$
\end_inset

 to 
\begin_inset Formula $\Delta',A\vdash B$
\end_inset

.
 Note that 
\begin_inset Formula $y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is non-empty only when 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma}$
\end_inset

 and 
\begin_inset Formula $\tau=A\multimap B$
\end_inset

, in which case it is a singleton set.
 This is why we have to quantify over 
\begin_inset Formula $\boldsymbol{\Gamma}$
\end_inset

, so that it works for any 
\begin_inset Formula $\Delta$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us now discuss promotion for values.
\begin_inset Formula 
\[
\infer[p]{\bang\Delta\entail V:\bang{(A\loli B)}}{\bang\Delta\entail V:A\loli B}
\]

\end_inset

This typing rule can be split as described in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

, depending on what 
\begin_inset Formula $V$
\end_inset

 is: a variable, a 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, or a term constant 
\begin_inset Formula $c\in{\cal C}=\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules for values
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\dots+\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{}{!\Delta,x:\bang(A\multimap B)\vdash x:\bang(A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash\bang(A\multimap B))}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{!\Delta,x:A\vdash M:B}{!\Delta\vdash\lambda x^{A}.M:\bang(A\multimap B)}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}X_{\underline{\Delta},A\vdash B}\times y(\emptyset\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{}{!\Delta\vdash c:\bang(A_{c}\multimap B_{c})}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{c}}y(\emptyset\vdash\bang(A_{c}\multimap B_{c}))$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Let us explain how the coproduct components are inferred.
 Each premise is straightforwardly translated.
 For example, in the elimination rule for abstraction, the premise 
\begin_inset Formula $\bang\Delta,\Gamma\entail M:A\loli B$
\end_inset

 becomes 
\begin_inset Formula $X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}$
\end_inset

, where 
\begin_inset Formula $\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B$
\end_inset

 is the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 to 
\begin_inset Formula $!\Delta,\boldsymbol{\Gamma}\vdash A\multimap B$
\end_inset

.
 Conclusions are always of the shape 
\begin_inset Formula $!\Delta,\Gamma\vdash t:\tau$
\end_inset

, or 
\begin_inset Formula $!\Delta,\Gamma,\Sigma\vdash t:\tau$
\end_inset

 where 
\begin_inset Formula $\Gamma,\Sigma$
\end_inset

 consist of linear types.
 This justifies the global quantification over 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Sigma$
\end_inset

, and the multiplication by a representable functor 
\begin_inset Formula $y(\boldsymbol{\Gamma}\vdash\tau)$
\end_inset

 or 
\begin_inset Formula $y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash\tau)$
\end_inset

, which evaluated at 
\begin_inset Formula $\Delta\vdash A$
\end_inset

 is non-empty (and a singleton set) precisely when 
\begin_inset Formula $A=\tau$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma}$
\end_inset

, or 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma},\boldsymbol{\Sigma}$
\end_inset

 in the second case.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float table
wide true
sideways true
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $!\Delta$
\end_inset

 is non linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $!\Delta$
\end_inset

 is non linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{c\in\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}}{!\Delta\vdash c:A_{c}\multimap B_{c}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{c}}y(\emptyset\vdash A_{c}\multimap B_{c})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{A}}y(\boldsymbol{A}\vdash\boldsymbol{A})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{adjustbox}{rotate=90}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\dots+\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:B}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_E]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma,
\backslash
Sigma
\backslash
entail   
\backslash
letunitterm{M}{N}:A }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash1}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\boldsymbol{\Sigma}}\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_I]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
tensterm{M}{N}:A
\backslash
tensor B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash B}\times y(\boldsymbol{\Gamma},\boldsymbol{\boldsymbol{\Sigma}}\vdash A\otimes B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail    
\backslash
lettensterm{x^{A}}{y^{B}}{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
tensor B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A,y:B
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B,C}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\otimes B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},A,B\vdash C}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^
\backslash
ell]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injl{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A}\times y(\boldsymbol{\Gamma}\vdash A\oplus B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^r]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injr{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\oplus B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
match{P}{x^A}{M}{y^B}N:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail P:A
\backslash
sumtype B   &   
\backslash
deduce{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,y:B
\backslash
entail N:C}{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A
\backslash
entail M:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B,C}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\oplus B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},A\vdash C}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},B\vdash C}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tlist{-
\backslash
!}_{
\backslash
!
\backslash
!I}]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   M:
\backslash
tlist{A} }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit
\backslash
oplus(A{
\backslash
otimes}
\backslash
tlist A) } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash1\oplus(A\otimes A^{l})}\times y(\boldsymbol{\Gamma}\vdash A^{l})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[{
\backslash
tt rec}]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma
\backslash
entail 
\backslash
letrec{f^{A
\backslash
multimap B}}{x}{M}{N}:C }
\end_layout

\begin_layout Plain Layout

{  
\backslash
deduce
\end_layout

\begin_layout Plain Layout

{ 
\backslash
bang
\backslash
Delta,f:
\backslash
bang{(A
\backslash
multimap B)},x:A
\backslash
entail M:B   }
\end_layout

\begin_layout Plain Layout

{  
\backslash
bang
\backslash
Delta,
\backslash
Gamma,f:
\backslash
bang{(A
\backslash
multimap B)}
\backslash
entail N:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B,C}X_{\underline{!\Delta},!(A\multimap B),A\vdash B}\times X_{\underline{!\Delta},\boldsymbol{\Gamma},!(A\multimap B)\vdash C}\times y(\boldsymbol{\Gamma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{\ell}(\Delta\vdash C)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{\ell,j}(\Delta\vdash C,o)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{c\in{\cal C}}{!\Delta\vdash c:A_{c}\multimap B_{c}}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\delta(\Delta\vdash C=\bang\Delta\vdash A_{c}\multimap B_{c})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[ax]{\bang{\Delta},x:A\entail x:A}{\text{\ensuremath{A} linear}}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta(\boldsymbol{\Delta}=C)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[axd]{\bang{\Delta},x:\bang(A\loli B)\entail x:A\loli B}{}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta(\Delta=\bang\Delta)\times|\Delta|_{!C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[\loli_{I}]{\Delta\entail\lambda x^{A}.M:A\loli B}{\Delta,x:A\entail M:B}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\dfrac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{A,B}|C=A\multimap B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,1}=\Delta,A\vdash B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:C}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli C   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\Gamma,\Sigma,A}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\multimap C\\
H_{-,1}=\bang\Delta,\Sigma\vdash A
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_E]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma,
\backslash
Sigma
\backslash
entail   
\backslash
letunitterm{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{u_{\Gamma,\Sigma}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash1\\
H_{-,1}=\bang\Delta,\Sigma\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_I]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
tensterm{M}{N}:A
\backslash
tensor B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{t_{A,B,\Gamma,\Sigma}|\Delta\vdash C=\bang\Delta,\Gamma,\Sigma\vdash A\otimes B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\\
H_{-,1}=\bang\Delta,\Sigma\vdash B
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail    
\backslash
lettensterm{x^{A}}{y^{B}}{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
tensor B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A,y:B
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{t'_{A,B,\Gamma,\Sigma}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\otimes B\\
H_{-,1}=\bang\Delta,\Sigma,A,B\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^
\backslash
ell]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injl{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{inl_{A,B}|C=A\oplus B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^r]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injr{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{inr_{A,B}|C=A\oplus B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
match{P}{x^A}{M}{y^B}N:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail P:A
\backslash
sumtype B   &   
\backslash
deduce{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,y:B
\backslash
entail N:C}{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A
\backslash
entail M:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{\frac{}{}}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{m_{A,B,\Gamma,\Sigma}|\Delta=!\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\oplus B\\
H_{-,1}=\bang\Delta,\Sigma,A\vdash C\\
H_{-,2}=\bang\Delta,\Sigma,B\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tlist{-
\backslash
!}_{
\backslash
!
\backslash
!I}]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   M:
\backslash
tlist{A} }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit
\backslash
oplus(A{
\backslash
otimes}
\backslash
tlist A) } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{tail_{A}|C=A^{\ell}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash1\oplus(A\otimes A^{\ell})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[{
\backslash
tt rec}]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma
\backslash
entail 
\backslash
letrec{f^{A
\backslash
multimap B}}{x}{M}{N}:C }
\end_layout

\begin_layout Plain Layout

{  
\backslash
deduce
\end_layout

\begin_layout Plain Layout

{ 
\backslash
bang
\backslash
Delta,f:
\backslash
bang{(A
\backslash
multimap B)},x:A
\backslash
entail M:B   }
\end_layout

\begin_layout Plain Layout

{  
\backslash
bang
\backslash
Delta,
\backslash
Gamma,f:
\backslash
bang{(A
\backslash
multimap B)}
\backslash
entail N:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{\frac{}{}}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{rec_{A,B}|A,B\in S\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\Delta,f:\bang(A\multimap B)\vdash C\\
H_{-,1}=\bang\Delta,f:\bang(A\multimap B),A\vdash B
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{adjustbox}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Some components of the endofunctor specifying the quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:quantum-endo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
end{adjustbox}
\end_layout

\begin_layout Plain Layout

%
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)_{\Gamma;!\Delta\vdash\tau}=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{ (\ensuremath{\Gamma=\{A\}}, \ensuremath{\tau=A})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A\in\bang S}y(A;\emptyset\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|!\Delta|_{!A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B\in S}y(\emptyset;!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
See note below
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{1,\tau}\delta_{\Gamma,\emptyset}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset;\emptyset\vdash1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{\Gamma,A;!\Delta\vdash B}$
\end_inset

 or 
\begin_inset Formula $X_{\Gamma;!\Delta,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)_{\Delta\vdash\tau}=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\boldsymbol{\Delta},\{A\}}\delta_{\tau,A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A\in\boldsymbol{S}}y(A\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|!\Delta|_{!(A\multimap B)}\delta_{\boldsymbol{\Delta},\emptyset}\delta_{\tau,A\multimap B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B\in S}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
See note below
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\tau,1}\delta_{\boldsymbol{\Delta},\emptyset}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset\vdash1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{\Delta,A\vdash B}\delta_{\tau,A\multimap B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:B}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{!\Delta,\Gamma\vdash A\multimap B}\times X_{!\Delta,\Sigma\vdash A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\Delta,(!\Delta,\Gamma,\Sigma)}\delta_{\tau,B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\Delta}\vdash B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:simply-typed-so"

\end_inset

 In this section, we present the example of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 Our treatment generalises to any multi-sorted binding signature
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "FioreHur"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $T$
\end_inset

 denote the set of simple types generated by a set of base types and a binary
 arrow type construction 
\begin_inset Formula $-\Rightarrow-$
\end_inset

.
 Let us now describe the category 
\begin_inset Formula ${\cal A}$
\end_inset

 of arities, or scopes, and renamings between them.
 An arity 
\begin_inset Formula $\vec{\sigma}\arSep\tau$
\end_inset

 consists of a list of input types 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and an output type 
\begin_inset Formula $\tau$
\end_inset

.
 A term 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $\vec{\sigma}\arSep\tau$
\end_inset

 considered as a scope is intuitively a well-typed term 
\begin_inset Formula $t$
\end_inset

 of type 
\begin_inset Formula $\tau$
\end_inset

 potentially using variables whose types are specified by 
\begin_inset Formula $\vec{\sigma}$
\end_inset

.
 A valid choice of arguments for a metavariable 
\begin_inset Formula $M:(\vec{\sigma}\arSep\tau)$
\end_inset

 in scope 
\begin_inset Formula $\vec{\sigma}'\arSep\tau'$
\end_inset

 first requires 
\begin_inset Formula $\tau=\tau'$
\end_inset

, and consists of an injective renaming 
\begin_inset Formula $\vec{r}$
\end_inset

 between 
\begin_inset Formula $\vec{\sigma}=(\sigma_{1},\dots,\sigma_{m})$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma}'=(\sigma'_{1},\dots,\sigma'_{n})$
\end_inset

, that is, a choice of distinct positions 
\begin_inset Formula $(r_{1},\dots,r_{m})$
\end_inset

 in 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

 such that 
\begin_inset Formula $\vec{\sigma}=\sigma'_{\vec{r}}$
\end_inset

.
\end_layout

\begin_layout Standard
This discussion determines the category of arities as 
\begin_inset Formula ${\cal A}=\mathbb{F}_{m}[T]\times T$
\end_inset

 , where 
\begin_inset Formula $\mathbb{F}_{m}[T]$
\end_inset

 is the category of finite lists of elements of 
\begin_inset Formula $T$
\end_inset

 and injective renamings between them.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises the definition of the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 specifying the syntax, where 
\begin_inset Formula $|\vec{\sigma}|_{\tau}$
\end_inset

 denotes the number (as a cardinal set) of occurrences of 
\begin_inset Formula $\tau$
\end_inset

 in 
\begin_inset Formula $\vec{\sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
The induced signature is pattern-friendly and so the generic pattern unification
 algorithm applies.
 Equalisers and pullbacks are computed following the same pattern as in
 pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 For example, to unify 
\begin_inset Formula $M(\vec{x})$
\end_inset

 and 
\begin_inset Formula $M(\vec{y})$
\end_inset

, we first compute the vector 
\begin_inset Formula $\vec{z}$
\end_inset

 of common positions between 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

, thus satisfying 
\begin_inset Formula $x_{\vec{z}}=y_{\vec{z}}$
\end_inset

.
 Then, the most general unifier maps 
\begin_inset Formula $M:(\vec{\sigma}\arSep\tau)$
\end_inset

 to the term 
\begin_inset Formula $P(\vec{z})$
\end_inset

, where the arity 
\begin_inset Formula $\vec{\sigma}'\arSep\tau'$
\end_inset

 of the fresh metavariable 
\begin_inset Formula $P$
\end_inset

 is the only possible choice such that 
\begin_inset Formula $P(\vec{z})$
\end_inset

 is a valid term in the scope 
\begin_inset Formula $\vec{\sigma}\arSep\tau$
\end_inset

, that is, 
\begin_inset Formula $\tau'=\tau$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma}'=\sigma_{\vec{z}}$
\end_inset

.
\end_layout

\begin_layout Subsection
Simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset


\begin_inset Formula $\eta$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:normalised-lc"

\end_inset


\end_layout

\begin_layout Standard
Let us explain how we account for Miller's original setting: simply-typed
 
\begin_inset Formula $\lambda$
\end_inset

-calculus modulo 
\begin_inset Formula $\beta$
\end_inset

 and 
\begin_inset Formula $\eta$
\end_inset

-equations.
 Let us denote a type 
\begin_inset Formula $\sigma_{1}\Rightarrow\dots\Rightarrow\sigma_{n}\Rightarrow\iota$
\end_inset

 by 
\begin_inset Formula $\vec{\sigma}\Rightarrow\iota$
\end_inset

, where 
\begin_inset Formula $\iota$
\end_inset

 is a base type.
 Note that any type can be written in this way, uniquely.
 We consider the same set of scopes as in the previous section, but with
 different morphisms as we explain now.
 As a preliminary remark, note that any scope 
\begin_inset Formula $\vec{\sigma}\rightarrow(\vec{\tau}\Rightarrow\iota)$
\end_inset

, induces a type 
\begin_inset Formula $\vec{\sigma},\vec{\tau}\Rightarrow\iota$
\end_inset

.
 A morphism between two scopes respectively inducing the types 
\begin_inset Formula $\vec{\tau}\Rightarrow\iota$
\end_inset

 and 
\begin_inset Formula $\vec{\tau}'\Rightarrow\iota'$
\end_inset

 is a morphism between the scopes 
\begin_inset Formula $\vec{\tau}\rightarrow\iota$
\end_inset

 and 
\begin_inset Formula $\vec{\tau}'\rightarrow\iota'$
\end_inset

 in the sense of the previous section.
 As a consequence, our category of scopes is equivalent to 
\begin_inset Formula $\mathbb{F}_{m}[T]\times B$
\end_inset

 where 
\begin_inset Formula $B$
\end_inset

 is the set of base types.
\end_layout

\begin_layout Standard
We follow Cheney's presentation
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
after "Section 2.2"
key "cheney2005relating"
literal "false"

\end_inset

 of the equation-free syntax of 
\begin_inset Formula $\beta$
\end_inset

-short 
\begin_inset Formula $\eta$
\end_inset

-long normal forms with metavariables.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 shows the base syntax which is generated by a single rule combining application
 and abstraction.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Like 
\begin_inset CommandInset citation
LatexCommand citet
key "vezzosi2014categorical"
literal "true"

\end_inset

, we consider the set of the simple types as inductively generated by a
 single construction 
\begin_inset Formula $\vec{\sigma}\Rightarrow\iota$
\end_inset

, where 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 is a list of types, and 
\begin_inset Formula $\iota$
\end_inset

 is a base type.
 We also adopt the De Bruijn convention to label variables: a base context
 is just a list of simple types and a variable is just a natural number
 smaller than the size of the base context.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We follow Cheney's presentation
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
after "Section 2.2"
key "cheney2005relating"
literal "false"

\end_inset

 of the equation-free syntax of 
\begin_inset Formula $\beta$
\end_inset

-short 
\begin_inset Formula $\eta$
\end_inset

-long normal forms, enriched with metavariables.
 Let us first describe the base syntax.
 The typing judgement is of the shape 
\begin_inset Formula $\vec{\sigma}\vdash t:\tau$
\end_inset

, where 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 is a base context, 
\begin_inset Formula $t$
\end_inset

 is a term, and 
\begin_inset Formula $\tau$
\end_inset

 is a simple type.
 This differs from our well-formedness judgement which are of the shape
 
\begin_inset Formula $a\vdash t$
\end_inset

, but we can handle it by merging the context 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and the type 
\begin_inset Formula $\tau$
\end_inset

 into a single entity 
\begin_inset Formula $\vec{\sigma}\rightarrow\tau$
\end_inset

, which we call a scope.
 In other words, in our setting, 
\begin_inset Formula $\vec{\sigma}\vdash t:\tau$
\end_inset

 would be denoted by 
\begin_inset Formula $\vec{\sigma}\rightarrow\tau\vdash t$
\end_inset

.
 We keep the former notation for simplicity.
 The base syntax is generated by the following rule, which combines application
 and abstraction in a single construction.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\overrightarrow{(\sigma,\delta)}_{i}=(\vec{\tau_{1}}\Rightarrow\iota_{1},\dots,\vec{\tau_{n}}\Rightarrow\iota_{n})\Rightarrow\iota\quad\forall j,\vec{\sigma},\vec{\delta},\vec{\tau_{i}}\vdash t_{j}:\iota_{j}'}{\vec{\sigma}\vdash\lambda_{\vec{\delta}}.i\vec{t}:\vec{\delta}\Rightarrow\iota}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\overrightarrow{(\sigma,\delta)}_{i}=(\tau_{1},\dots,\tau_{n})\Rightarrow\iota\quad\forall j\in\{1,\dots n\},\ \vec{\sigma},\vec{\delta}\vdash t_{j}:\tau_{j}}{\vec{\sigma}\vdash\lambda_{\vec{\delta}}.i\vec{t}:\vec{\delta}\Rightarrow\iota}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{\sigma_{i}=(\vec{\tau_{1}}\Rightarrow,\dots,\tau_{n})\Rightarrow\tau\quad\forall j,\vec{\sigma}\vdash t_{j}:\tau_{j}}{\vec{\sigma}\vdash\underline{i}\vec{t}:\Rightarrow\tau}\qquad\dfrac{\vec{\sigma},\tau_{1}\vdash t:\vec{\delta}\Rightarrow\tau_{2}}{\vec{\sigma}\vdash\lambda t:\tau_{1},\vec{\delta}\Rightarrow\tau_{2}}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Note that this rule cannot be specified by a (multi-sorted) 
\emph on
binding arit
\emph default
y
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "FioreHur"
literal "false"

\end_inset

, but it does fit into our format (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, but it does not pose any significant challenge to provide a specification
 of operation symbols, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for more details.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us now describe the enriched syntax.
 We write 
\begin_inset Formula $M::\vec{\tau}\Rightarrow\iota\in\Gamma$
\end_inset

 to mean that the type induced by the scope of 
\begin_inset Formula $M$
\end_inset

 declared in 
\begin_inset Formula $\Gamma$
\end_inset

 is 
\begin_inset Formula $\vec{\tau}\Rightarrow\iota$
\end_inset

.
 The introduction rule for metavariables is the following.
\begin_inset Formula 
\[
\dfrac{M::(\tau_{1},\dots,\tau_{n})\Rightarrow\iota\in\Gamma\qquad(x_{1},\dots,x_{n})\text{ are distinct variables in \ensuremath{\vec{\sigma},\vec{\tau}'} of type \ensuremath{\vec{\tau}}}}{\Gamma;\vec{\sigma}\vdash\lambda_{\vec{\tau'}}M(\vec{x)}:\vec{\tau}'\Rightarrow\iota}
\]

\end_inset

Thanks to our modified notion of scope morphism, this rule indeed complies
 with our introduction rule for metavariables, in the sense that it requires
 the same data.
 
\end_layout

\begin_layout Standard
Let us note that the metavariable arities 
\begin_inset Formula $\vec{\sigma}\rightarrow\tau\Rightarrow\tau'$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma},\tau\rightarrow\tau'$
\end_inset

 are equivalent in the sense that they share the same metavariable introduction
 rule.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In the rule above, the scope is 
\begin_inset Formula $\vec{\sigma}\rightarrow(\vec{\tau}'\Rightarrow\iota)$
\end_inset

, which induces the type 
\begin_inset Formula $\vec{\sigma},\vec{\tau}'\Rightarrow\iota$
\end_inset

, so that we retrieve the expected notion of patterns.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
, let us describe the set of morphisms between two scopes.
 In fact, this set depends only on the types 
\begin_inset Formula $\vec{\tau}\Rightarrow\iota$
\end_inset

 and 
\begin_inset Formula $\vec{\tau}'\Rightarrow\iota'$
\end_inset

 induced by those scopes: it is empty if 
\begin_inset Formula $\iota\neq\iota$
\end_inset

'; otherwise, it consists of a list of distinct variables of type 
\begin_inset Formula $\vec{\tau}$
\end_inset

 in the context 
\begin_inset Formula $\vec{\tau}'$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Finally, it is worth noting that the notion of metatypes that is automatically
 derived by our setting is more liberal than Vezzosi-Abel's: their metatypes
 are types rather tha scopes.
 This restriction prevented them from describing terms as morphisms and
 mgus as coequalisers.
 Another consequence is that our unification problems are 
\begin_inset Quotes eld
\end_inset

harder
\begin_inset Quotes erd
\end_inset

 since we have more metavariable substitutions.
 It is easy to check that given a restricted unification problem, the mgu
 computed by our algorithm fits into their restricted fragment (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Paragraph
Comparison with Vezzosi-Abel's envisioned generalisation
\end_layout

\begin_layout Plain Layout
In their conclusion, 
\begin_inset CommandInset citation
LatexCommand citet
key "vezzosi2014categorical"
literal "false"

\end_inset

 sketched a track to extend their work for a suitable class of languages:
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Instead of [the category of patterns] we can consider a generic category
 
\begin_inset Formula $Ctx$
\end_inset

 having all the pullbacks and equalisers and whose arrows are monomorphisms.
 And instead of the grammar of [normal forms of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus] we can use an arbitrary one defined by a family of operators
 [...] as long as they are functorial with respect to 
\begin_inset Formula $Ctx$
\end_inset

.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
The key additional ingredient that we introduce is the preservation of equaliser
s and pullbacks by the operation symbols and their arities.
 This is crucial to ensure that given two terms, either there is a mgu,
 either there is no unifier.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
We already sketched in the introduction how to handle simply-typed lambda-terms
 modulo 
\begin_inset Formula $\beta$
\end_inset

- and 
\begin_inset Formula $\eta$
\end_inset

-equations.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 shows more explicitly how the syntax fits into our setting.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Higher-order pattern unification was originally introduced for closed simply-typ
ed lambda-terms with metavariables applied to distinct variables.
 Lambda-terms are considered in 
\begin_inset Formula $\beta$
\end_inset

-short 
\begin_inset Formula $\eta$
\end_inset

-long normal forms.
 Although we do not explicitly cover equations, the syntax of those normal
 forms is equation free and can be specified by a GB-signature: we take
 the same category of arities as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

, and we consider the operations as specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:ordered-calculus"

\end_inset


\end_layout

\begin_layout Standard
Our setting handles linear ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus, consisting of 
\begin_inset Formula $\lambda$
\end_inset

-terms using all the variables in context.
 In this context, a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $m\in\mathbb{N}$
\end_inset

 can only be used in the scope 
\begin_inset Formula $m$
\end_inset

, and there is no freedom in choosing the arguments of a metavariable applicatio
n, since all the variables must be used, in order.
 Thus, there is no need to even mention those arguments in the syntax.
 It is thus not surprising that ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus is already handled by first-order unification, where metavariables
 do not take any argument, by considering ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus as a multi-sorted Lawvere theory where the sorts are the scopes,
 and the syntax is generated by operations 
\begin_inset Formula $L_{n}\times L_{m}\rightarrow L_{n+m}$
\end_inset

 and abstractions 
\begin_inset Formula $L_{n+1}\rightarrow L_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Our generalisation can handle calculi combining ordered and unrestricted
 variables, such as the calculus underlying ordered linear logic described
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Polakow00lfm"
literal "false"

\end_inset

.
 In this section we detail this specific example.
 Note that this does not fit into Schack-Nielsen and Schürman's pattern
 unification algorithm
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "DBLP:journals/corr/abs-1009-2795"
literal "false"

\end_inset

 for linear types where exchange is allowed (the order of their variables
 does not matter).
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $T$
\end_inset

 of types is generated by a set of atomic types and two binary arrow type
 constructions 
\begin_inset Formula $\Rightarrow$
\end_inset

 and 
\begin_inset Formula $\twoheadrightarrow$
\end_inset

.
 The syntax extends pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus with a distinct application 
\begin_inset Formula $t^{>}\ u$
\end_inset

 and abstraction 
\begin_inset Formula $\lambda^{>}u$
\end_inset

.
 Variables contexts are of the shape 
\begin_inset Formula $\vec{\sigma}\Fsep\vec{\omega}\arSep\tau$
\end_inset

, where 
\begin_inset Formula $\vec{\sigma}$
\end_inset

, 
\begin_inset Formula $\vec{\omega}$
\end_inset

, and 
\begin_inset Formula $\tau$
\end_inset

 are taken in 
\begin_inset Formula $T$
\end_inset

.
 The idea is that a term in such a context has type 
\begin_inset Formula $\tau$
\end_inset

 and must use all the variables of 
\begin_inset Formula $\vec{\omega}$
\end_inset

 in order, but is free to use any of the variables in 
\begin_inset Formula $\vec{\sigma}$
\end_inset

.
 Assuming a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $\vec{\sigma}\Fsep\vec{\omega}\arSep\tau$
\end_inset

, the above discussion about ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus justifies that there is no need to specify the arguments for 
\begin_inset Formula $\vec{\omega}$
\end_inset

 when applying 
\begin_inset Formula $M$
\end_inset

.
 Thus, a metavariable application 
\begin_inset Formula $M(\vec{x})$
\end_inset

 in the scope 
\begin_inset Formula $\vec{\sigma}'\Fsep\vec{\omega}'\arSep\tau'$
\end_inset

 is well-formed if 
\begin_inset Formula $\tau=\tau'$
\end_inset

 and 
\begin_inset Formula $\vec{x}$
\end_inset

 is an injective renaming from 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 to 
\begin_inset Formula $\vec{\sigma}'$
\end_inset

.
 Therefore, we take 
\begin_inset Formula ${\cal A}=\mathbb{F}_{m}[T]\times T^{*}\times T$
\end_inset

 for the category of arities, where 
\begin_inset Formula $T^{*}$
\end_inset

 denotes the discrete category whose objects are lists of elements of 
\begin_inset Formula $T$
\end_inset

.
 The remaining components of the GB-signature are specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

: we alternate typing rules for the unrestricted and the ordered fragments
 (variables, application, abstraction).
\end_layout

\begin_layout Standard
Pullbacks and equalisers are computed essentially as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 For example, the most general unifier of 
\begin_inset Formula $M(\vec{x})$
\end_inset

 and 
\begin_inset Formula $M(\vec{y})$
\end_inset

 maps 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $P(\vec{z})$
\end_inset

 where 
\begin_inset Formula $\vec{z}$
\end_inset

 is the vector of common positions of 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

, and 
\begin_inset Formula $P$
\end_inset

 is a fresh metavariable of arity 
\begin_inset Formula $\sigma_{\vec{z}}\Fsep\vec{\omega}\arSep\tau$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Intuitively, given 
\begin_inset Formula $X\in\Set$
\end_inset

, the set 
\begin_inset Formula $X_{n}$
\end_inset

 is the set of expressions with exactly 
\begin_inset Formula $n$
\end_inset

 (distinct) variables.
 Then, we can consider the linear lambda-calculus, as an endofunctor on
 
\begin_inset Formula $\Set$
\end_inset

 mapping 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $F(X)$
\end_inset

 where 
\begin_inset Formula $F(X)_{n}=y1+\coprod_{p+q=n}X_{p}\times X_{q}+(n+1)\times X_{n+1}$
\end_inset

.
 Note that we could also specify a non-linear binder by replacing 
\begin_inset Formula $(n+1)\times X_{n+1}$
\end_inset

 with 
\begin_inset Formula $\coprod_{p>n}\left(\begin{array}{c}
p\\
n
\end{array}\right)X_{p}$
\end_inset

.
 We could also have a non linear application by replacing 
\begin_inset Formula $\coprod_{p+q=n}X_{p}\times X_{q}$
\end_inset

 with 
\begin_inset Formula $X_{n}\times X_{n}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Then, 
\begin_inset Formula $F^{*}(0)$
\end_inset

 is the linear lambda-calculus.
 
\begin_inset Formula $F^{*}(yn)$
\end_inset

 is the syntax of linear 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with one 
\begin_inset Formula $n$
\end_inset

-ary metavariable applied to 
\begin_inset Formula $n$
\end_inset

 (distinct) variables.
 
\end_layout

\begin_layout Plain Layout
Note that 
\begin_inset Formula $F(X)$
\end_inset

 is of the shape 
\begin_inset Formula $I+\coprod_{i}X_{p_{i,1}}\times\dots\times X_{p_{i,m_{i}}}\times yn_{i}$
\end_inset

 and each 
\begin_inset Formula $X\mapsto X_{p_{i,1}}\times\dots\times X_{p_{i,m_{i}}}\times yn_{i}$
\end_inset

 is left adjoint to 
\begin_inset Formula $X\mapsto X_{n_{i}}\times(yp_{i,1}+\dots+yp_{i,m_{i}})$
\end_inset

.
 
\color red
No
\color inherit

\begin_inset Formula $\bang$
\end_inset


\color red
 But almost, i.e., if there exists a morphism 
\begin_inset Formula $A\rightarrow X_{p}\times y_{n}$
\end_inset

, then in fact 
\begin_inset Formula $A=A_{n}yn$
\end_inset

 and there exists a morphism 
\begin_inset Formula $A_{n}\times yp\rightarrow X$
\end_inset

, but the converse is false.
 
\end_layout

\begin_layout Remark
We could have done the non-linear version in this setting as well, but the
 abstract syntax is more convoluted (see the binomial coefficient) and metavaria
bles must still be linear.
\end_layout

\begin_layout Example
linear lambda calculus, quantum lambda calculus
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Intrinsic polymorphic syntax
\end_layout

\begin_layout Subsubsection
Syntactic system F
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:system-F"

\end_inset


\end_layout

\begin_layout Standard
We present intrinsic System F, in the spirit of
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HamanaPoly"
literal "false"

\end_inset

.
 The Agda implementation of the friendly GB-signature can be found in the
 supplemental material.
\end_layout

\begin_layout Standard
The syntax of types in type scope 
\begin_inset Formula $n$
\end_inset

 is inductively generated as follows, following the De Bruijn level convention.
\begin_inset Formula 
\[
\dfrac{1\leq i\leq n}{n\vdash\var i}\qquad\dfrac{n\vdash t\quad n\vdash u}{n\vdash t\Rightarrow u}\qquad\dfrac{n+1\vdash t}{n\vdash\forall t}
\]

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $S:\mathbb{F}_{m}\rightarrow\Set$
\end_inset

 be the functor mapping 
\begin_inset Formula $n$
\end_inset

 to the set 
\begin_inset Formula $S_{n}$
\end_inset

 of types for system 
\begin_inset Formula $F$
\end_inset

 taking free type variables in 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

.
 In other words, 
\begin_inset Formula $S_{n}=\{\tau|n\vdash\tau\}$
\end_inset

.
 Intuitively, a metavariable arity 
\begin_inset Formula $n\Fsep\vec{\sigma}\arSep\tau$
\end_inset

 specifies the number 
\begin_inset Formula $n$
\end_inset

 of free type variables, the list of input types 
\begin_inset Formula $\vec{\sigma}$
\end_inset

, and the output type 
\begin_inset Formula $\tau$
\end_inset

, all living in 
\begin_inset Formula $S_{n}$
\end_inset

.
 This provides the underlying set of objects of the category 
\begin_inset Formula ${\cal A}$
\end_inset

 of arities.
 A term 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $n\Fsep\vec{\sigma}\arSep\tau$
\end_inset

 considered as a scope is intuitively a well-typed term of type 
\begin_inset Formula $\tau$
\end_inset

 potentially involving ground variables of type 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and type variables in 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

.
\end_layout

\begin_layout Standard
A metavariable 
\begin_inset Formula $M:(n\Fsep\sigma_{1},\dots,\sigma_{p}\arSep\tau)$
\end_inset

 in the scope 
\begin_inset Formula $n'\Fsep\vec{\sigma}'\arSep\tau'$
\end_inset

 must be supplied with a choice 
\begin_inset Formula $(\eta_{1},\dots,\eta_{n})$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 distinct type variables among the set 
\begin_inset Formula $\{1,\dots n'\}$
\end_inset

 such that 
\begin_inset Formula $\tau[\vec{\eta}]=\tau'$
\end_inset

, as well as an injective renaming 
\begin_inset Formula $\vec{\sigma}[\vec{\eta}]\rightarrow\vec{\sigma}'$
\end_inset

, i.e., a list of distinct positions 
\begin_inset Formula $r_{1},\dots,r_{p}$
\end_inset

 such that 
\begin_inset Formula $\vec{\sigma}[\vec{\eta}]=\sigma'_{\vec{r}}$
\end_inset

.
\end_layout

\begin_layout Standard
This defines the data for a morphism in 
\begin_inset Formula ${\cal A}$
\end_inset

 between 
\begin_inset Formula $(n\Fsep\vec{\sigma}\arSep\tau)$
\end_inset

 and 
\begin_inset Formula $(n'\Fsep\vec{\sigma}'\arSep\tau')$
\end_inset

.
 The intrinsic syntax of system 
\begin_inset Formula $F$
\end_inset

 can then be specified as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:GB-sig-systemF"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The induced GB-signature is pattern-friendly.
 For example, morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 are easily seen to be monomorphic; we detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:A-finite-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the proof that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits.
\end_layout

\begin_layout Standard
Pullbacks and equalisers in 
\begin_inset Formula ${\cal A}$
\end_inset

 are essentially computed as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

, by computing the vector of common (value) positions.
 For example, given a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $m\Fsep\vec{\sigma}\arSep\tau$
\end_inset

, to unify 
\begin_inset Formula $M(\vec{w}\Fsep\vec{x})$
\end_inset

 with 
\begin_inset Formula $M(\vec{y}\Fsep\vec{z})$
\end_inset

, we compute the vector of common positions 
\begin_inset Formula $\vec{p}$
\end_inset

 between 
\begin_inset Formula $\vec{w}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

, and the vector of common positions 
\begin_inset Formula $\vec{q}$
\end_inset

 between 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{z}$
\end_inset

.
 Then, the most general unifier maps 
\begin_inset Formula $M$
\end_inset

 to the term 
\begin_inset Formula $P(\vec{p}\Fsep\vec{q})$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

 is a fresh metavariable.
 Its arity 
\begin_inset Formula $m'\Fsep\vec{\sigma}'\arSep\tau'$
\end_inset

 is the only possible one for 
\begin_inset Formula $P(\vec{p}|\vec{q})$
\end_inset

 to be well-formed in the scope 
\begin_inset Formula $m\Fsep\vec{\sigma}\arSep\tau$
\end_inset

, that is, 
\begin_inset Formula $m'$
\end_inset

 is the size of 
\begin_inset Formula $\vec{p}$
\end_inset

, while 
\begin_inset Formula $\tau'=\tau[p_{i}\mapsto i]$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma}'=\text{\ensuremath{\sigma_{\vec{q}}}}[p_{i}\mapsto i]$
\end_inset

.
\end_layout

\begin_layout Subsubsection
System F modulo 
\begin_inset Formula $\beta\eta$
\end_inset


\end_layout

\begin_layout Standard
In this section, we sketch how we can handle system F modulo 
\begin_inset Formula $\beta\eta$
\end_inset

 in the spirit of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

, by devising a signature for normal forms.
 To make the syntax more legible, we depart from the previous presentation
 and instead consider system F as a pure type system.
 We also ignore the De Bruijn encoding.
 A scope is now of the shape 
\begin_inset Formula $\vec{y}:\vec{u}\rightarrow\tau$
\end_inset

, where 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\vec{y}:\vec{u}$
\end_inset

 is a list of variable declarations 
\begin_inset Formula $y_{1}:u_{1},\dots,y_{n}:u_{n}$
\end_inset

 where 
\begin_inset Formula $u_{i}$
\end_inset

 is either 
\begin_inset Formula $*$
\end_inset

, meaning that 
\begin_inset Formula $y_{i}$
\end_inset

 is a type variable, or a type which is well-formed in context involving
 all the type variables occuring before 
\begin_inset Formula $y_{i}$
\end_inset

 in the scope;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\tau$
\end_inset

 is a type well-formed in 
\begin_inset Formula $\vec{y}:\vec{u}$
\end_inset

.
\end_layout

\begin_layout Standard
We use the notation 
\begin_inset Formula $\prod(\alpha:u).\tau$
\end_inset

 , where 
\begin_inset Formula $\tau$
\end_inset

 may depend on 
\begin_inset Formula $\alpha$
\end_inset

, to mean either 
\begin_inset Formula $\forall\alpha.\tau_{2}$
\end_inset

 in case 
\begin_inset Formula $u=*$
\end_inset

, or 
\begin_inset Formula $u\Rightarrow\tau$
\end_inset

 otherwise (in the latter case, 
\begin_inset Formula $\tau$
\end_inset

 does not depend on 
\begin_inset Formula $\alpha$
\end_inset

).
 
\end_layout

\begin_layout Standard
Note that any type can be written as 
\begin_inset Formula $\prod(y_{1}:u_{1})\prod\dots\prod(y_{n}:u_{n}).\iota$
\end_inset

, abbreviated as 
\begin_inset Formula $\prod(\vec{y}:\vec{u}).\iota$
\end_inset

, where 
\begin_inset Formula $\iota$
\end_inset

 is a type variable.
 Any scope 
\begin_inset Formula $(\vec{y}:\vec{u})\rightarrow\prod(\vec{z}:\vec{v}).\iota$
\end_inset

, induces a type 
\begin_inset Formula $\prod(\vec{y}:\vec{u})(\vec{z}:\vec{v}).\iota$
\end_inset

.
 A morphism between two scopes inducing the types 
\begin_inset Formula $\prod(\vec{y}:\vec{u}).\iota$
\end_inset

 and 
\begin_inset Formula $\prod(\vec{z}:\vec{v}).\iota'$
\end_inset

 is an injective renaming 
\begin_inset Formula $\rho$
\end_inset

 between 
\begin_inset Formula $\vec{y}:\vec{u}$
\end_inset

 and 
\begin_inset Formula $\vec{z}:\vec{v}$
\end_inset

 such that 
\begin_inset Formula $\iota[\rho]=\iota'$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The morphisms are injective renamings in the obvious sense.
 Note that the category of scopes of the previous section embeds into this
 one, and this embedding is actually an equivalence – in particular, any
 scope is isomorphic to one where the type variables are declared at the
 beginning and are not interleaved with term variables.
 It follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:A-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that the category of scopes has finite connected limits.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us now describe the base syntax.
 We write
\begin_inset Formula $\Gamma\vdash t:*$
\end_inset

 to mean that 
\begin_inset Formula $t$
\end_inset

 is a type well-formed in 
\begin_inset Formula $\Gamma$
\end_inset

 and we do not make any syntactic distinction between type and term abstractions.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To make things simpler and more consistent with our treatment of syntactic
 system F, we restrict to normalised types, that is, to types of the shape
 
\begin_inset Formula $\forall^{p}\vec{\sigma}\Rightarrow\iota$
\end_inset

, where 
\begin_inset Formula $\iota$
\end_inset

 is a type variable and each 
\begin_inset Formula $\sigma_{i}$
\end_inset

 can of course include 
\begin_inset Formula $\forall$
\end_inset

.
 In other words, we consider types up to the reduction relation 
\begin_inset Formula $\sigma\Rightarrow\forall\tau\sim\forall(wk\sigma\Rightarrow\tau)$
\end_inset

.
\end_layout

\begin_layout Plain Layout
We consider the same set of scopes as in the previous section, but with
 different morphisms as we explain now.
 As a preliminary remark, note that any scope 
\begin_inset Formula $m|\vec{\sigma}\rightarrow(\forall^{p}\vec{\tau}\Rightarrow\iota)$
\end_inset

, induces a type 
\begin_inset Formula $\forall^{m+p}wk^{p}\vec{\sigma},\overrightarrow{\tau}\Rightarrow\iota$
\end_inset

.
 A morphism between two scopes respectively inducing the types 
\begin_inset Formula $\forall^{p}\vec{\sigma}\Rightarrow\iota$
\end_inset

 and 
\begin_inset Formula $\forall^{p'}\vec{\sigma}'\Rightarrow\iota'$
\end_inset

 is a morphism between the scopes 
\begin_inset Formula $p|\vec{\sigma}\rightarrow\iota$
\end_inset

 and 
\begin_inset Formula $p'|\vec{\sigma}'\rightarrow\iota'$
\end_inset

 in the sense of the previous section.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
type equality does not preserve term equalities, ah mais je m'en fous je
 fais que des formes normales.
\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
As a consequence, our category of scopes is equivalent to 
\begin_inset Formula $\mathbb{F}_{m}[T]\times B$
\end_inset

 where 
\begin_inset Formula $B$
\end_inset

 is the set of base types.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The base syntax is generated by the following rule, where 
\begin_inset Formula $\iota$
\end_inset

 denotes a type variable, and 
\begin_inset Formula $u_{i}$
\end_inset

 or 
\begin_inset Formula $v_{i}$
\end_inset

 are either types or 
\begin_inset Formula $*$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{\Gamma,\vec{y}:\vec{u}\vdash x:\iota}{\Gamma\vdash\lambda\vec{y}.x:\prod(\vec{y}:\vec{u}).\iota}\qquad\dfrac{\begin{array}{cc}
 & \Gamma,\vec{y}:\vec{u}\vdash x:\prod(\alpha_{1}:v_{1}).\tau_{1}\\
\Gamma,\vec{y}:\vec{u}\vdash t_{1}:v_{1} & \tau_{1}[\alpha_{1}\mapsto t_{1}]=\prod(\alpha_{2}:v_{2}).\tau_{2}\\
\Gamma,\vec{y}:\vec{u}\vdash t_{2}:v_{2} & \tau_{2}[\alpha_{2}\mapsto t_{2}]=\prod(\alpha_{3}:v_{3}).\tau_{3}\\
\dots & \tau_{n}[\alpha_{n}\mapsto t_{n}]=\iota
\end{array}}{\Gamma\vdash\lambda\vec{y}.x\vec{t}:\prod(\vec{y}:\vec{u}).\iota}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that 
\begin_inset Formula $\tau_{i}[a_{1}\mapsto t_{i}]=\tau_{i}$
\end_inset

 if 
\begin_inset Formula $v_{i}$
\end_inset

 is not 
\begin_inset Formula $*$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let us now describe the enriched syntax.
 We write 
\begin_inset Formula $M::\prod(\vec{y}:\vec{u}).\iota$
\end_inset

 to mean that the type induced by the arity of 
\begin_inset Formula $M$
\end_inset

 is 
\begin_inset Formula $\prod(\vec{y}:\vec{u}).\iota$
\end_inset

.
 The introduction rule for metavariables is the following.
\begin_inset Formula 
\[
\dfrac{M::\prod(\vec{x}:\vec{t}).\iota\in\Gamma\qquad\begin{array}{c}
(\alpha_{1},\dots,\alpha_{n})\text{ are distinct variables in \ensuremath{\vec{y},\vec{z}} of sort \ensuremath{\vec{t}}}\end{array}}{\Gamma;\vec{y}:\vec{u}\vdash\lambda\vec{z}.M(\vec{\alpha}):\prod(\vec{z}:\vec{v}).\iota'}
\]

\end_inset

As in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

, thanks to our modified notion of scope morphism, this rule indeed complies
 with our introduction rule for metavariables, in the sense that it requires
 the same data.
 
\end_layout

\begin_layout Subsubsection
Proof that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits (Section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

 on system F)
\begin_inset Note Note
status open

\begin_layout Plain Layout
Proof of Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:A-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:A-finite-F"

\end_inset

In this section, we show that the category 
\begin_inset Formula ${\cal A}$
\end_inset

 of arities for System F (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

) has finite connected limits.
 First, note that 
\begin_inset Formula ${\cal A}$
\end_inset

 is the op-lax colimit of the functor from 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 to the category of small categories mapping 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $\mathbb{F}_{m}[S_{n}]\times S_{n}$
\end_inset

.
 Let us introduce the category 
\begin_inset Formula ${\cal A}'$
\end_inset

 whose definition follows that of 
\begin_inset Formula ${\cal A}$
\end_inset

, but without the output types: objects are pairs of a natural number 
\begin_inset Formula $n$
\end_inset

 and an element of 
\begin_inset Formula $S_{n}$
\end_inset

.
 Formally, this is the op-lax colimit of 
\begin_inset Formula $n\mapsto\mathbb{F}_{m}[S_{n}]$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:A'-lim"

\end_inset


\begin_inset Formula ${\cal A}'$
\end_inset

 has finite connected limits, and the projection functor 
\begin_inset Formula ${\cal A}'\rightarrow\mathbb{F}_{m}$
\end_inset

 preserves them.
\end_layout

\begin_layout Proof
The crucial point is that 
\begin_inset Formula ${\cal A}'$
\end_inset

 is not only op-fibred over 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 by construction, it is also fibred over 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
 Intuitively, if 
\begin_inset Formula $\vec{\sigma}\in\mathbb{F}_{m}[S_{n}]$
\end_inset

 and 
\begin_inset Formula $f:n'\rightarrow n$
\end_inset

 is a morphism in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

, then 
\begin_inset Formula $f_{!}\vec{\sigma}\in\mathbb{F}_{m}[S_{n'}]$
\end_inset

 is essentially 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 restricted to elements of 
\begin_inset Formula $S_{n}$
\end_inset

 that are in the image of 
\begin_inset Formula $S_{f}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that 
\begin_inset Formula $f_{!}:\mathbb{F}_{m}[S_{n}]\rightarrow\mathbb{F}_{m}[S_{n'}]$
\end_inset

 is right adjoint to 
\begin_inset Formula $\vec{\sigma}\mapsto\vec{\sigma}[f]$
\end_inset

, and is thus continuous.
\end_layout

\end_inset

 We can now apply 
\begin_inset CommandInset citation
LatexCommand citep
after "Corollary 4.3"
key "grayfib"
literal "false"

\end_inset

, since each 
\begin_inset Formula $\mathbb{F}_{m}[S_{n}]$
\end_inset

 has finite connected limits.
\begin_inset Note Note
status open

\begin_layout Plain Layout
is it?
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are now ready to prove that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits.
\end_layout

\begin_layout Lemma
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits.
\end_layout

\begin_layout Proof
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset

Proof of Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:A-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset


\end_layout

\end_inset

Since 
\begin_inset Formula $S:\mathbb{F}_{m}\rightarrow\Set$
\end_inset

 preserves finite connected limits, 
\begin_inset Formula $\int S$
\end_inset

 has finite connected limits and the projection functor to 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 preserves them by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Proof
Now, the 2-category of small categories with finite connected limits and
 functors preserving those between them is the category of algebras for
 a 2-monad on the category of small categories 
\begin_inset CommandInset citation
LatexCommand citep
key "BLACKWELL19891"
literal "false"

\end_inset

.
 Thus, it includes the weak pullback of 
\begin_inset Formula ${\cal A}'\rightarrow\mathbb{F}_{m}\leftarrow\int S$
\end_inset

.
 But since 
\begin_inset Formula $\int S\rightarrow\mathbb{F}_{m}$
\end_inset

 is a fibration, and thus an isofibration, by 
\begin_inset CommandInset citation
LatexCommand citep
key "JoyalStreetPullbacks"
literal "false"

\end_inset

 this weak pullback can be computed as a pullback, which is 
\begin_inset Formula ${\cal A}$
\end_inset

.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:related-work"

\end_inset


\end_layout

\begin_layout Standard
First-order unification has been explained from a lattice-theoretic point
 of view by 
\begin_inset CommandInset citation
LatexCommand cite
key "plotkinunification"
literal "false"

\end_inset

, and later categorically analysed by 
\begin_inset CommandInset citation
LatexCommand citet
after "Section 9.7"
key "DBLP:books/daglib/0068768,Goguen89whatis,10.5555/92134"
literal "false"

\end_inset

 as coequalisers.
 However, there is little work on understanding pattern unification algebraicall
y, with the notable exception of 
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

, working with normalised terms of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 The present paper
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ifshort{
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
An expanded version of this work can be found in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "longgenericunif"
literal "false"

\end_inset

.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

 can be thought of as a generalisation of their work as sketched in their
 conclusion, although our treatment of their case study differs (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:normalised-lc"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
Although our notion of signature has a broader scope since we are not specifical
ly focusing on syntax where variables can be substituted, our work is closer
 in spirit to the presheaf approach
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "fiore:presheaf"
literal "false"

\end_inset

 to binding signatures than to the nominal approach
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "PittsAM:newaas"
literal "false"

\end_inset

 in that everything is explicitly scoped: terms come with their scope, metavaria
bles always appear with their patterns.
\end_layout

\begin_layout Standard
Nominal unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "10.1007/978-3-540-45220-1_41"
literal "false"

\end_inset

 is an alternative to pattern unification where metavariables are not supplied
 with the list of allowed variables.
 Instead, substitution can capture variables.
 Nominal unification explicitly deals with 
\begin_inset Formula $\alpha$
\end_inset

-equivalence as an external relation on the syntax, and as a consequence
 deals with freshness problems in addition to unification problems.
 
\end_layout

\begin_layout Standard
Nominal unification and pattern unification problems are inter-translatable
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "cheney2005relating,DBLP:journals/tocl/LevyV12"
literal "false"

\end_inset

.
 As Cheney notes, this result indirectly provides semantic foundations for
 pattern unification based on the nominal approach.
 In this respect, the present work provides a more direct semantic analysis
 of pattern unification, leading us to the generic algorithm we present,
 parameterised by a general notion of signature for the syntax.
\end_layout

\begin_layout Standard
Pattern unification has also been studied from the viewpoint of logical
 frameworks
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "pientka2003tabled,DBLP:conf/icfp/NanevskiPP03,DBLP:journals/tocl/NanevskiPP08,DBLP:conf/tlca/AbelP11"
literal "false"

\end_inset

 using contextual types to characterise metavariables.
 LF-style signatures handle type dependency, but there are also GB-signatures
 which cannot be encoded with an LF signature.
 For example, GB-signatures allow us to express pattern unification for
 ordered lambda terms (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ordered-calculus"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
In the dependently-typed setting, 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:conf/lics/Pfenning91"
literal "false"

\end_inset

 provides unification and antiunification algorithms in the pattern fragment
 for the calculus of constructions.
 
\begin_inset CommandInset citation
LatexCommand citet
after "Chapter 4"
key "DBLP:phd/ethos/Gundry13"
literal "false"

\end_inset

 presents a pattern unification algorithm for a dependent type theory, as
 a component of his type inference algorithm.
 It actually implements "dynamic pattern unification", which addresses unificati
on problems that do not necessarily fit into the pattern fragment at first.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Finally, let us mention our semantics for metavariables does differ in a
 critical way from prior semantics of metavariables (e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:journals/tocl/HuPS22"
literal "false"

\end_inset

 or 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:conf/aplas/Hamana04"
literal "false"

\end_inset

).
 Those models permit interpreting general metavariables -- i.e., a metavariable
 can be instantiated with a full substitution of arbitrary terms.
 A consequence of this is that they contain the semantic analogues of problems
 outside the pattern fragment, such as 
\begin_inset Formula $M(x,x)\stackrel{?}{=}N(x,x)$
\end_inset

 .
 Since problems like this do not have most general unifiers, the more general
 categories in the literature correspondingly do not always have suitable
 coequalisers.
 However, the pattern fragment is much more restrictive: a metavariable
 can only be instantiated with a disjoint collection of free variables,
 ensuring that mgu's can be found (if they exist).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our semantics for metavariables has been engineered so that it can 
\emph on
only
\emph default
 interpret metavariable instantiations in the pattern fragment, and cannot
 interpret full metavariable instantiations, contrary to prior semantics
 of metavariables, e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:journals/tocl/HuPS22"
literal "false"

\end_inset

 or 
\begin_inset CommandInset citation
LatexCommand citet
key "DBLP:conf/aplas/Hamana04"
literal "false"

\end_inset

.
 This restriction gives our model much stronger properties, enabling us
 to characterise each part of the pattern unification algorithm in terms
 of universal properties.
 This lets us extend Rydeheard and Burstall's proof to the pattern case.
\end_layout

\begin_layout Standard

\series bold
Conflicts of interest.

\series default
 Ambroise Lafont is part of the INRIA team PARTOUT.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
We presented a generic unification algorithm for Miller's pattern fragment
 with its associated initial-algebra semantics, parameterised by a new notion
 of signature for syntax with metavariables.
 Our setting does not handle type dependency, which notably implies that
 we do not deal with type metavariables (even in our system F example).
 A natural question to ask is to which extent this work could be adapted
 to dependently-typed languages.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Another direction would be to tackle syntax with equations, which would
 provide a way to handle linear calculus such as linear 
\begin_inset Formula $\lambda$
\end_inset

-calculus, where variables must be used exactly once, as in the ordered
 case, but in any order, and where typing derivations are identified up
 to some symmetry.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In the future, we plan to provide fully mechanised proof of correctness.
 We also plan to see how this work applies to dependently-typed languages,
 going beyond polymorphic syntax.
 Finally, we are interesting in further extending the setting to cover unificati
on modulo equations, or linear syntax without restriction on the order the
 variables are used.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "bib"
options "jfplike"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\begin_layout Plain Layout


\backslash
startappendix
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
secappendix{
\end_layout

\end_inset

Proof of
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
