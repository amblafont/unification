#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass acmart
\begin_preamble
\input{common-preamble}
\end_preamble
\use_default_options false
\begin_modules
enumitem
\end_modules
\maintain_unincluded_children false
\begin_local_layout
#\DeclareLyXModule{Other}
#DescriptionBegin
#Defines Notation
#DescriptionEnd
#Category: theorems

Format 66

Requires    amsmath

# acmart document class includes amssymb
Provides amssymb 1

# The environments defined (regular and starred) are :
# - Property

Style Notation
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             notation
    LabelString           "Notation \thethm."
    Preamble
\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{notation}[theorem]{Notation}}
    EndPreamble
End

Style Remark
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             remark
    LabelString           "Remark \thethm."
    Preamble
\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{remark}[theorem]{Remark}}
    EndPreamble
End

Style Property
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             property
    LabelString           "Property \thethm."
    Preamble
\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{property}[theorem]{Property}}
    EndPreamble
End


Style "Personal Question"
    CopyStyle             Theorem
    DependsOn               Theorem
    LatexName             personalquestion
    LabelString           "Personal Question \thethm."
    Preamble
      %\newenvironment{personalquestion}{\shortfull{\comment}{\begin{question}\color{red}(personal)}}{\shortfull{\endcomment}{\end{question}}}
      \newenvironment{personalquestion}{\comment}{\endcomment}
    EndPreamble
End


Style "Long Proof"
    CopyStyle             Proof
    DependsOn               Proof
    LatexName             longproof
    LabelString           "Long proof."
    Preamble
      \newenvironment{longproof}{\shortfull{\comment}{\begin{proof}}}{\shortfull{\endcomment}{\end{proof}}}
    EndPreamble
End

Style "Appendix"
    CopyStyle             Section
    DependsOn               Section
    LatexName             secappendix
    LabelString           "Appendix"
    Preamble
    EndPreamble
End
\end_local_layout
\language british
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style ACM-Reference-Format
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Abstract
\begin_inset Note Note
status open

\begin_layout Plain Layout
In a Lawvere theory freely generated by operations, an equaliser diagram
 has a limit as long as it has a cone.
 As it is well-known, this translates in terms of first-order unification
 as the existence of a most general unifier as long as there exists a unifier.
 Generalising the so-called pattern fragment of second-order unification
 identified by Miller, we propose an extension of this result for a class
 of non-free Lawvere theories generated by a new notion of signature in
 order to capture syntax with variable binding and metavariables, including
 simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus, (intrinsic) System F, ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\end_inset

 
\end_layout

\begin_layout Abstract
We provide a generic second-order unification algorithm for Miller's pattern
 fragment, implemented in Agda.
 The syntax with metavariables is parameterised by a notion of signature
 generalising binding signatures, covering ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus, or (intrinsic) polymorphic syntax such as System F.
 The correctness of the algorithm is stated and proved on papers using a
 categorical perspective, based on the observation that the most general
 unifier is an equaliser in a multi-sorted Lawvere theory, thus generalising
 the case of first-order unification.
\end_layout

\begin_layout Title
Generic pattern unification
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\type}{\ \mathrm{type}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Th}[1]{\mathrm{MCon}(#1)}
\end_inset


\begin_inset FormulaMacro
\newcommand{\arSep}{\rightarrow}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Thbot}[1]{\mathrm{MCon_{\bot}}(#1)}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Fsep}{|}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lamrenaming}[1]{#1\uparrow}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lamsubst}[2]{#1\uparrow^{#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\wk}[1]{\textrm{wk }#1}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\catbot}[1]{#1_{\bot}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\rename}[2]{#1\{#2\}}
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset FormulaMacro
\newcommand{\nar}[1]{\kappa_{#1}}
\end_inset


\end_layout

\end_inset


\begin_inset FormulaMacro
\newcommand{\ntharvec}[1]{\alpha_{#1}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\ntharvecaction}[3]{#2_{#3}^{#1}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\ntharvecfunct}{\ntharvec{}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\nthar}[2]{\overline{#1}_{#2}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\nthaarvec}[1]{\alpha'_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\nthaarvecfunct}{\nthaarvec{}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\nthaar}[2]{\alpha'_{#1,#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Oop}[2]{O_{#1}(#2)}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Inj}{\mathrm{Inj}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\veciflyx}[2]{\vecif{#1}{#2}}
{\vec{#2}_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\var}[1]{#1}
\end_inset


\begin_inset FormulaMacro
\newcommand{\lcvar}[1]{\underline{#1}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\refruletwo}[2]{\hyperlink{#2}{\textsc{#1}}}
{\underline{\textsc{#1}}(\textsc{#2})}
\end_inset


\begin_inset FormulaMacro
\newcommand{\refrule}[1]{\refruletwo{#1}{#1}}
{\underline{\textsc{#1}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\maybold}[1]{#1}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\refULrule}[1]{\refruletwo{U\ensuremath{\Lambda}-#1}{UL-#1}}
\end_inset


\begin_inset Formula $\newcommand{\niton}{\not\owns}$
\end_inset


\begin_inset FormulaMacro
\newcommand{\refPLrule}[1]{\refruletwo{P\ensuremath{\Lambda}-#1}{PL-#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\labelrule}[2]{\hypertarget{#2}{#1}}
{#1(\textsc{#2})}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\highlighted}[1]{\colorbox{blue!10}{\ensuremath{#1}}}
{{\color{blue}#1}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\labelruletwo}[3]{\labelrule{#1\textsc{#2}}{#3}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\labelULrule}[2]{\labelruletwo{#1}{U\ensuremath{\Lambda}-#2}{UL-#2}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\labelPLrule}[2]{\labelruletwo{#1}{P\ensuremath{\Lambda}-#2}{PL-#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\labellabelrule}[2]{\labelruletwo{#1}{#2}{#2}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kl}[1]{Kl_{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\arg}[1]{#1}
{#1}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Eil}[1]{#1\text{-alg}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\something}[1]{\underline{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\prunecat}[5]{\vdash_{#5}#1\boldsymbol{:>}#2\Rightarrow#4;#3}
\end_inset


\begin_inset FormulaMacro
\newcommand{\prune}[4]{\prunecat{#1}{#2}{#3}{#4}{}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\B}{\mathscr{B}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\D}{\mathscr{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\C}{\mathscr{C}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\colim}{\mathrm{colim}\ }
\end_inset


\begin_inset FormulaMacro
\newcommand{\Set}{\mathrm{Set}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\FinSet}{\mathrm{FinSet}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Nom}{\mathrm{Nom}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KlD}{\Kl{\D^{+}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\op}[1]{#1^{op}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\bang}{\oc}
{!}
\end_inset


\begin_inset FormulaMacro
\newcommand{\none}{\bang}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationtopconcl}{\bot\vdash\vec{t}=\vec{u}\Rightarrow\bang\dashv\bot}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationtop}{\dfrac{}{\unificationtopconcl}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationemptyconcl}{\Gamma\vdash()=()\Rightarrow1_{\Gamma}\dashv\Gamma}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationempty}{\dfrac{}{\unificationemptyconcl}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationstepwisenolabel}[1]{\inferruletwo{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{u_{1}}\Rightarrow\sigma_{1}\dashv\Delta_{1}}{\Delta_{1}\vdash\veciflyx{#1}{t_{2}}[\text{\ensuremath{\sigma_{1}]}}=\veciflyx{#1}{u_{2}}[\text{\ensuremath{\sigma_{1}]}}\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash\veciflyx{}{t_{1}},\veciflyx{#1}{t_{2}}=\veciflyx{}{u_{1}},\veciflyx{#1}{u_{2}}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}}
{\dfrac{\Gamma\vdash\veciflyx{}{t_{1}}=\veciflyx{}{u_{1}}\Rightarrow\sigma_{1}\dashv\Delta_{1}\quad\Delta_{1}\vdash\veciflyx{#1}{t_{2}}[\text{\ensuremath{\sigma_{1}]}}=\veciflyx{#1}{u_{2}}[\text{\ensuremath{\sigma_{1}]}}\Rightarrow\sigma_{2}\dashv\Delta_{2}}{\Gamma\vdash\veciflyx{}{t_{1}},\veciflyx{#1}{t_{2}}=\veciflyx{}{u_{1}},\veciflyx{#1}{u_{2}}\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationstepwise}[1]{\unificationstepwisenolabel{#1}\textsc{U-Split}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\unificationrigrignolabel}{\dfrac{\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash o(\vec{t})=o(\vec{u})\Rightarrow\sigma\dashv\Delta}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\unificationrigrigneqo}{\dfrac{o\neq o'}{\Gamma\vdash o(\vec{t})=o'(\vec{u})\Rightarrow\bang\dashv\bot}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\pruningemptyconcl}{\Gamma\prune{()}{()}{1_{\Gamma}}{()}\dashv\Gamma}
\end_inset


\begin_inset FormulaMacro
\newcommand{\pruningempty}{\dfrac{}{\pruningemptyconcl}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
keywords{Unification, Category theory, Syntax}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Unification consists in finding a 
\emph on
unifier 
\emph default
of two terms 
\begin_inset Formula $t,u$
\end_inset

, that is a (metavariable) substitution 
\begin_inset Formula $\sigma$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

.
 Unification algorithms try to compute a most general unifier 
\begin_inset Formula $\sigma$
\end_inset

, in the sense that given any other unifier 
\begin_inset Formula $\delta$
\end_inset

, there exists a unique 
\begin_inset Formula $\delta'$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma[\delta']$
\end_inset

.
 First-order unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "robinsonunif"
literal "false"

\end_inset

 is used in ML-style type inference systems and logic programming languages
 such as Prolog.
 More advanced type systems, where variable binding is crucially involved,
 requires second-order unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "huetunif"
literal "false"

\end_inset

, which is undecidable
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "unifundecidable"
literal "false"

\end_inset

.
 However, Miller
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

 identified a decidable fragment: in so-called 
\emph on
pattern unification
\emph default
,
\emph on
 
\emph default
metavariables are allowed to take distinct variables as arguments.
 In this situation, we can write an algorithm that either fails in case
 there is no unifier, or computes the most general unifier.
\end_layout

\begin_layout Standard
Recent results in type inference, Dunfield-Krishnaswami
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/DunfieldK19"
literal "false"

\end_inset

, or Jinxu et.
 al
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/ZhaoOS19"
literal "false"

\end_inset

, include very large proofs: the former comes with a 190 page appendix,
 and the latter comes with a Coq proof many thousands of lines long -- and
 both of these results are for tiny kernel calculi.
 If we ever hope to extend this kind of result to full programming languages
 like Haskell or OCaml, we must raise the abstraction level of these proofs,
 so that they are no longer linear (with a large constant) in the size of
 the calculus.
 A close examination of these proofs shows that a large part of the problem
 is that the type inference algorithms make use of unification, and the
 correctness proofs for type inference end up essentially re-establishing
 the entire theory of unification for each algorithm.
 The reason they do this is because algorithmic typing rules essentially
 give a first-order functional program with no abstractions over (for example)
 a signature for the unification algorithm to be defined over, or any axiomatic
 statement of the invariants the algorithmic typing rules had to maintain.
\end_layout

\begin_layout Standard
The present work is a first step towards a general solution to this problem.
 Our generic unification algorithm implemented in Agda is parameterised
 by a new notion of signature for syntax with metavariables, whose scope
 goes beyond the standard binding signatures.
 One important feature is that the notion of contexts is customisable, making
 it possible to cover simply-typed second-order syntax, ordered syntax,
 or (intrinsic) polymorphic syntax such as System F.
 We focused on Miller's pattern unification, as this is already a step beyond
 the above-cited works
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/pacmpl/ZhaoOS19,DBLP:journals/pacmpl/DunfieldK19"
literal "false"

\end_inset

 that use plain first-order unification.
 Moreover, this is necessary for types with binders (e.g., fixed-point operators
 like 
\begin_inset Formula $\mu a.A[a]$
\end_inset

) as well as for rich type systems like dependent types.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection*
Related work
\end_layout

\begin_layout Plain Layout
First-order unification, where all metavariables are constant, was categorically
 rephrased in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

.
 Pattern unification was introduced in 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/logcom/Miller91"
literal "false"

\end_inset

, as a particular case of higher-order unification for the simply-typed
 lambda-calculus, where metavariables are applied to distinct variables.
 It was categorically rephrased in 
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
, with concluding hints about how to generalise their work.
\end_layout

\end_inset

The present paper can be thought of as a generalisation of their work.
\end_layout

\begin_layout Personal Question
\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

 propose une generalisation interessante, avec le lemme sur les epis.
 (Theorem 10).
 Est-ce qu'on pourrait encore generaliser encore notre business?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As an introduction, we start by presenting pattern unification in the case
 of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

, before The goal of this paper is to generalise it, by parameterising the
 algorithm by a signature specifying a syntax.
 Then, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we motivate our general setting and provide categorical semantics of the
 algorithm, by revisiting pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Agda implementation
\end_layout

\begin_layout Standard
We use Agda as a programming language, not as a theorem prover.
 We leave for future work the task of mechanising the correctness proof
 of the algorithm, by investigating the formalisation of various concepts
 from category theory – a notorious challenge on its own – on which our
 proof relies on.
\end_layout

\begin_layout Standard
Since we focus on providing an effective implementation, the definitions
 of our data structures typically do not mention the properties.
 For example, our definition of categories in Agda does not include associativit
y of composition and neutrality of the identity:
\end_layout

\begin_layout Standard
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdacode{category}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Furthermore, we are not reluctant to using logically inconsistent features
 to make programming easier: the type hierachy is collapsed and the termination
 checker is disabled.
 We find that dependent types are still helpful in guiding the implementation.
 In comparison, we previously implemented an ocaml version where the code
 was much less constrained by the typing discipline, and thus more error-prone.
\end_layout

\begin_layout Subsection*
Related work
\end_layout

\begin_layout Standard
First-order unification has been explained from a lattice-theoretic point
 of view by Plotkin
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "plotkinunification"
literal "false"

\end_inset

, and later categorically analysed in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Section 9.7"
key "DBLP:books/daglib/0068768,Goguen89whatis,10.5555/92134"
literal "false"

\end_inset

 as coequalisers.
 However, there is little work on understanding pattern unification algebraicall
y, with the notable exception of 
\begin_inset CommandInset citation
LatexCommand cite
key "vezzosi2014categorical"
literal "false"

\end_inset

, working with normalised terms of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 The present paper
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ifshort{
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
An expanded version of this work can be found in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "longgenericunif"
literal "false"

\end_inset

.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

 can be thought of as a generalisation of their work.
\end_layout

\begin_layout Standard
Although our notion of signature has a broader scope since we are not specifical
ly focusing on syntax where variables can be substituted, our work is closer
 in spirit to the presheaf approach
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "fiore:presheaf"
literal "false"

\end_inset

 to binding signatures than to the nominal approach
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "PittsAM:newaas"
literal "false"

\end_inset

 in that everything is explicitly scoped: terms come with their support,
 metavariables always appear with their scope of allowed variables.
\end_layout

\begin_layout Standard
Nominal unification
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-540-45220-1_41"
literal "false"

\end_inset

 is an alternative to pattern unification where metavariables are not supplied
 with the list of allowed variables.
 Instead, substitution can capture variables.
 Nominal unification explicitly deals with 
\begin_inset Formula $\alpha$
\end_inset

-equivalence as an external relation on the syntax, and as a consequence
 deals with freshness problems in addition to unification problems.
 
\end_layout

\begin_layout Standard
Cheney
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cheney2005relating"
literal "false"

\end_inset

 shows that nominal unification and pattern unification problems are inter-trans
latable.
 As he notes, this result indirectly provides semantic foundations for pattern
 unification based on the nominal approach.
 In this respect, the present work provides a more direct semantic analysis
 of pattern unification, leading us to the generic algorithm we present,
 parameterised by a general notion of signature for the syntax.
\end_layout

\begin_layout Subsection*
Plan of the paper
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:summary-algo"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we present our generic pattern unification algorithm, parameterised by
 our generalised notion of binding signature.
 We introduce categorical semantics of pattern unification in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:cat-settings"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We show correctness of the two phases of the unification algorithm in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:coequalising-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Completeness is justified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:completeness"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Finally, we present some examples of signatures in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:applications"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection*
General notations
\end_layout

\begin_layout Standard
Given a list 
\begin_inset Formula $\vec{x}=(x_{1},\dots,x_{n})$
\end_inset

 and a list of positions 
\begin_inset Formula $\vec{p}=(p_{1},\dots,p_{m})$
\end_inset

 taken in 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

, we denote 
\begin_inset Formula $(x_{p_{1}},\dots,x_{p_{m}})$
\end_inset

 by 
\begin_inset Formula $x_{\vec{p}}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Given a category 
\begin_inset Formula $\B$
\end_inset

, we denote its opposite category by 
\begin_inset Formula $\op{\B}$
\end_inset

.
 If 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are two objects of 
\begin_inset Formula $\B$
\end_inset

, we denote the set of morphisms between 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 by 
\begin_inset Formula $\hom_{\B}(a,b)$
\end_inset

.
 We denote the identity morphism at an object 
\begin_inset Formula $x$
\end_inset

 by 
\begin_inset Formula $1_{x}$
\end_inset

.
 We denote the coproduct of two objects 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 by 
\begin_inset Formula $A+B$
\end_inset

 and the coproduct of a family of objects 
\begin_inset Formula $(A_{i})_{i\in I}$
\end_inset

 by 
\begin_inset Formula $\coprod_{i\in I}A_{i}$
\end_inset

, and similarly for morphisms.
 If 
\begin_inset Formula $f:A\rightarrow B$
\end_inset

 and 
\begin_inset Formula $g:A'\rightarrow B$
\end_inset

, we  denote the induced morphism 
\begin_inset Formula $A+A'\rightarrow B$
\end_inset

 by 
\begin_inset Formula $f,g$
\end_inset

.
 Coproduct injections 
\begin_inset Formula $A_{i}\rightarrow\coprod_{i\in I}A_{i}$
\end_inset

 are typically denoted by 
\begin_inset Formula $in_{i}$
\end_inset

.
 Let 
\begin_inset Formula $T$
\end_inset

 be a monad on a category 
\begin_inset Formula $\B$
\end_inset

.
 We denote its unit by 
\begin_inset Formula $\eta$
\end_inset

, and its Kleisli category by 
\begin_inset Formula $\Kl T$
\end_inset

: the objects are the same as those of 
\begin_inset Formula $\B$
\end_inset

, and a Kleisli morphism from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

 is a morphism 
\begin_inset Formula $A\rightarrow TB$
\end_inset

 in 
\begin_inset Formula $\B$
\end_inset

.
 We denote the Kleisli composition of 
\begin_inset Formula $f:A\rightarrow TB$
\end_inset

 and 
\begin_inset Formula $g:B\rightarrow TC$
\end_inset

 by 
\begin_inset Formula $f[g]:A\rightarrow TC$
\end_inset

.
 
\end_layout

\begin_layout Section
Presentation of the algorithm
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:summary-algo"

\end_inset


\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout

\series bold
Judgments
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta\quad\Longleftrightarrow & \quad\text{\ensuremath{\sigma:\Gamma\rightarrow\Delta}\text{ is the most general unifier of \ensuremath{\vec{t}} and \ensuremath{\vec{u}}}}\\
\Gamma\prune{\vec{u}}{\ensuremath{\overrightarrow{M(\vec{x})}}}{\sigma}{\vec{w}}\dashv\Delta\quad\Longleftrightarrow & \quad\ensuremath{\sigma:\Gamma\rightarrow\Delta}\text{ extended with \ensuremath{M_{i}\mapsto w_{i}} is the most \text{general unifier of \ensuremath{\Gamma\vdash\vec{u}} and \ensuremath{\overrightarrow{M(\vec{x})}}}}\\
\highlighted{m\vdash\vec{x}=\vec{y}\Rightarrow\vec{z}\dashv p}\quad\Longleftrightarrow & \quad(z_{1},\dots,z_{p})\text{ are the common positions of \ensuremath{(x_{1},\dots,x_{m})} and \ensuremath{(y_{1},\dots,y_{m})}}\\
\highlighted{\highlighted{n\prunecat{\vec{x}}{\vec{y}}{\vec{r}\dashv p}{\vec{l}}{}}}\quad\Longleftrightarrow & \quad(l_{1},\dots,l_{p})\text{ and \ensuremath{(r_{1},\dots,r_{p})} are the common value positions of \ensuremath{(x_{1},\dots,x_{n})} and \ensuremath{\vec{y}}}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Unification Phase
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Formula 
\[
\labelULrule{\unificationempty}{Empty}\quad\labelULrule{\unificationtop}{ExFalso}
\]

\end_inset


\begin_inset Formula 
\[
\labelULrule{\unificationstepwisenolabel{}}{Split}{}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid-rigid (
\begin_inset Formula $o,o'$
\end_inset

 are applications, 
\begin_inset Formula $\lambda$
\end_inset

-abstractions, or variables)
\begin_inset Formula 
\[
\labelULrule{\unificationrigrignolabel}{RigRig}\qquad\labelULrule{\unificationrigrigneqo}{Clash}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-*, no cycle 
\begin_inset Formula 
\[
\labelULrule{\dfrac{M\notin u\qquad\Gamma\prune u{\maybold M(\vec{x})}{\sigma}w\dashv\Delta}{\Gamma,M:m\vdash M(\vec{x})=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}}{NoCycle}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Flex, same
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labelULrule{\dfrac{\highlighted{m\vdash\vec{x}=\vec{y}\Rightarrow\vec{z}\dashv p}}{\Gamma,M:m\vdash M(\vec{x})=M(\vec{y})\Rightarrow M\mapsto M'(\vec{z})\dashv\Gamma,M':p}}{Flex}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Rigid, cyclic
\begin_inset Formula 
\[
\labelULrule{\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(\vec{x})=u\Rightarrow\bang\dashv\bot}}{Cyclic}{}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Non-cyclic Phase
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Formula 
\[
\pruningempty\quad\dfrac{}{\bot\prune{\vec{t}}{\overrightarrow{M(\vec{x})}}{\bang}{\bang}\dashv\bot}
\]

\end_inset


\begin_inset Formula 
\[
\labelPLrule{\inferruletwo{\Gamma\prune{t_{1}}{M(\vec{x}_{1})}{\sigma_{1}}{u_{1}}\dashv\Delta_{1}}{\Delta_{1}\prune{\vec{t_{2}}[\sigma_{1}]}{\overrightarrow{M(\vec{x}_{2})}}{\sigma_{2}\dashv\Delta_{2}}{\vec{u_{2}}}}{\Gamma\prune{t_{1},\vec{t_{2}}}{M_{1}(\vec{x}_{1}),\overrightarrow{M(\vec{x}_{2})}}{\sigma_{1}[\sigma_{2}]}{u_{1}[\sigma_{2}],\vec{u}_{2}}\dashv\Delta_{2}}}{Split}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid
\end_layout

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\labelPLrule{\dfrac{\Gamma\prune t{\maybold M'(\vec{x},\overbrace{\var{n+1}}^{\mathclap{\text{bound variable}}})}{\sigma}w\dashv\Delta}{\Gamma\prune{\lambda t}{\maybold M(\vec{x})}{\sigma}{\lambda w}\dashv\Delta}}{Lam}{}\quad\labelPLrule{\dfrac{\Gamma\prune{t,u}{\maybold M_{1}(\vec{x}),\maybold M_{2}(\vec{x})}{\sigma}{w_{1},w_{2}}\dashv\Delta}{\Gamma\prune{t\ u}{\maybold M(\vec{x})}{\sigma}{w_{1}\ w_{2}}\dashv\Delta}}{\textsc{App}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labelPLrule{\dfrac{y=x_{i}}{\Gamma\prune y{\maybold M(\vec{x})}{1_{\Gamma}}{\var i}\dashv\Gamma}}{VarOk}\qquad\labelPLrule{\dfrac{y\notin\vec{x}}{\Gamma\prune y{\maybold M(\vec{x})}{\bang}{\bang}\dashv\bot}}{VarFail}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex
\begin_inset Formula 
\[
\labelPLrule{\dfrac{\highlighted{n\prunecat{\vec{x}}{\vec{y}}{\vec{r}\dashv p}{\vec{l}}{}}}{\Gamma,N:n\prune{N(\vec{x})}{\maybold M(\vec{y})}{N\mapsto P(\vec{r})}{P(\vec{l})}\dashv\Gamma,P:p}}{Flex}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unification for pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:algo-pure-lambda"

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout

\series bold
Judgments
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.5em}
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta\quad\Longleftrightarrow & \quad\text{\ensuremath{\sigma:\Gamma\rightarrow\Delta}\text{ is the most general unifier of \ensuremath{\vec{t}} and \ensuremath{\vec{u}}}}\\
\Gamma\prune{\vec{u}}{\ensuremath{\overrightarrow{M(x)}}}{\sigma}{\vec{w}}\dashv\Delta\quad\Longleftrightarrow & \quad\ensuremath{\sigma:\Gamma\rightarrow\Delta}\text{ extended with \ensuremath{M_{i}\mapsto w_{i}} is the most \text{general unifier of \ensuremath{\Gamma\vdash\vec{u}} and \ensuremath{\overrightarrow{M(\vec{x})}}}}\\
\highlighted{m\vdash x=y\Rightarrow z\dashv p}\quad\Longleftrightarrow & \quad\xymatrix{p\ar[r]^{z} & m\coeqr{x}{y} & \dots}
\text{ is an equaliser in \ensuremath{{\cal A}}}\\
\highlighted{\highlighted{n\prunecat xy{r\dashv p}l{}}}\quad\Longleftrightarrow & \quad\begin{array}{c}
\xymatrix{p\ar[r]^{l}\ar[d]_{r} & n\ar[d]^{x}\\
\dots\ar[r]_{y} & \dots
}
\end{array}\text{ is a pullback in \ensuremath{{\cal A}}}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Unification Phase
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Formula 
\[
\unificationempty\quad\unificationtop
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\unificationstepwisenolabel x}{U-Split}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid-rigid
\begin_inset Formula 
\[
\labellabelrule{\unificationrigrignolabel}{U-RigRig}\qquad\labellabelrule{\unificationrigrigneqo}{U-Clash}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-*, no cycle 
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\notin u\qquad\Gamma\prune u{\maybold M(x)}{\sigma}w\dashv\Delta}{\Gamma,M:m\vdash M(x)=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}}{U-NoCycle}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Flex, same
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\Gamma,M:m\vdash M(x)=M(y)\Rightarrow M\mapsto M'(z)\dashv\Gamma,M':p}}{U-Flex}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex-Rigid, cyclic
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang\dashv\bot}}{U-Cyclic}\quad\text{+ symmetric rule}
\]

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Non-cyclic Phase
\end_layout

\begin_layout Itemize
Structural rules
\begin_inset Formula 
\[
\pruningempty\quad\dfrac{}{\bot\prune{\vec{t}}{\overrightarrow{M(x)}}{\bang}{\bang}\dashv\bot}
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\inferruletwo{\Gamma\prune{t_{1}}{M_{1}(x_{1})}{\sigma_{1}}{u_{1}}\dashv\Delta_{1}}{\Delta_{1}\prune{\vec{t_{2}}[\sigma_{1}]}{\overrightarrow{M_{2}(x_{2})}}{\sigma_{2}\dashv\Delta_{2}}{\vec{u_{2}}}}{\Gamma\prune{t_{1},\vec{t_{2}}}{M_{1}(x_{1}),\overrightarrow{M(x_{2})}}{\sigma_{1}[\sigma_{2}]}{u_{1}[\sigma_{2}],\vec{u}_{2}}\dashv\Delta_{2}}}{\textsc{P-Split}}
\]

\end_inset


\end_layout

\begin_layout Itemize
Rigid
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\Gamma\prune{\vec{t}}{M_{1}(\ntharvecaction{o'}x1),\dots,M_{n}(\ntharvecaction{o'}xn)}{\sigma}{\vec{u}}\dashv\Delta\quad o=\rename{o'}x}{\Gamma\prune{o(\vec{t})}{M(\arg x)}{\sigma}{o'(\vec{u})}\dashv\Delta}}{P-Rig}\quad\labellabelrule{\dfrac{o\neq\rename{\dots}x}{\Gamma\prune{o(\vec{t})}{M(\arg x)}{\bang}{\bang}\dashv\bot}}{P-Fail}
\]

\end_inset


\end_layout

\begin_layout Itemize
Flex
\begin_inset Formula 
\[
\labellabelrule{\dfrac{\highlighted{n\prunecat xy{r\dashv p}l{}}}{\Gamma,N:n\prune{N(x)}{\maybold M(y)}{N\mapsto P(r)}{P(l)}\dashv\Gamma,P:p}}{P-Flex}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Generic pattern unification algorithm (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:intro-generic"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:generic-algo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this section, we start by describing a pattern unification algorithm
 for pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, summarised in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-pure-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Then we present our generic algorithm (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

), and finally show that it indeed describes a terminating algorithm in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:progress"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Soundness of the algorithm is justified in later sections.
\end_layout

\begin_layout Subsection
An example: pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:example-lambda"

\end_inset


\end_layout

\begin_layout Standard
Consider the syntax of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with metavariables satisfying the pattern restriction.
 We list the Agda code in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:syntax-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

, together with more legible inductive rules generating the syntax.
 We write 
\begin_inset Formula $\Gamma;n\vdash t$
\end_inset

 to mean 
\begin_inset Formula $t$
\end_inset

 is a wellformed 
\begin_inset Formula $\lambda$
\end_inset

-term in the context 
\begin_inset Formula $\Gamma;n$
\end_inset

, consisting of two parts:
\end_layout

\begin_layout Enumerate
a metavariable context 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

, specifying metavariable symbols 
\begin_inset Formula $M_{i}$
\end_inset

 together with their arities, i.e, their number of arguments 
\begin_inset Formula $m_{i}$
\end_inset

, and 
\end_layout

\begin_layout Enumerate
a variable context, which is a mere natural number indicating the highest
 possible free variable.
\end_layout

\begin_layout Standard
Free variables are indexed from 
\begin_inset Formula $1$
\end_inset

 and we use the De Bruijn level convention: the variable bound in 
\begin_inset Formula $\Gamma;n\vdash\lambda t$
\end_inset

 is 
\begin_inset Formula $\var n+1$
\end_inset

, not 
\begin_inset Formula $0$
\end_inset

, as it would be using De Bruijn indices
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DB"
literal "false"

\end_inset

.
 In Agda, variables in the variable context 
\begin_inset Formula $n$
\end_inset

 consist of elements of 
\begin_inset Formula $\AgdaDatatype{Fin}\ n$
\end_inset

, the type of natural numbers between
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Formula $\AgdaDatatype{Fin}\ n$
\end_inset

 is actually defined in the standard library as an inductive type designed
 to be (canonically) isomorphic with 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

.
 We also use a nameless encoding of metavariable contexts: they are mere
 lists of metavariable arities, and metavariables are referred to by their
 index in the list (starting from 0).
 More concretely, let us focus on the last constructor building a metavariable
 application in the context 
\begin_inset Formula $\Gamma;n$
\end_inset

.
 The argument of type 
\begin_inset Formula $m\in\Gamma$
\end_inset

 is an index of any element 
\begin_inset Formula $m$
\end_inset

 in the list 
\begin_inset Formula $\Gamma$
\end_inset

.
 This constructor also takes an argument of type 
\begin_inset Formula $m\Rightarrow n$
\end_inset

, which unfolds as 
\begin_inset Formula $\AgdaDatatype{Vec}\ \AgdaSymbol{(}\AgdaDatatype{Fin}\ \AgdaBound{n}\AgdaSymbol{)}\ \AgdaBound{m}$
\end_inset

: this is the type of lists of size 
\begin_inset Formula $m$
\end_inset

 consisting of natural numbers between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

.
 Note that contrary to our mathematical description, the Agda code does
 not explicitly enforce that the metavariable arguments are distinct.
 Anyway, our unification algorithm is only guaranteed to produce correct
 outputs if this constraint is satisfied in the inputs.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset

 is a metavariable context 
\begin_inset Formula $M_{1}:m_{1},\dots,M_{p}:m_{p}$
\end_inset

 specifying a metavariable symbol 
\begin_inset Formula $M_{i}$
\end_inset

 together with its number of arguments 
\begin_inset Formula $m_{i}$
\end_inset

.
\begin_inset Formula 
\[
\dfrac{1\leq i\leq n}{\Gamma;n\vdash\var i}\qquad\dfrac{\Gamma;n\vdash t\quad\Gamma;n\vdash u}{\Gamma;n\vdash t\ u}\qquad\dfrac{\Gamma;n+1\vdash t}{\Gamma;n\vdash\lambda t}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{M:m\in\Gamma\quad1\leq i_{1},\dots,i_{m}\leq n\quad i_{1},\dots i_{m}\text{ distinct}}{\Gamma;n\vdash M(\var{i_{1}},\dots,\var{i_{m}})}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{M:m\in\Gamma\quad1\leq i_{1},\dots,i_{m}\leq n\quad i_{1},\dots i_{m}\text{ distinct}}{\Gamma;n\vdash M(v_{i_{1}},\dots,v_{i_{m}})}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalibcode{membership}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Formula 
\[
\dfrac{}{a\in(a,\dots)}\quad\dfrac{a\in\ell}{a\in(x,\ell)}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
agdalccode{metacontext}
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{renamings}
\end_layout

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{syntax}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Formula 
\[
\dfrac{1\leq i\leq n}{\Gamma;n\vdash\lcvar i}\quad\dfrac{\Gamma;n\vdash t\quad\Gamma;n\vdash u}{\Gamma;n\vdash t\ u}\quad\dfrac{\Gamma;n+1\vdash t}{\Gamma;n\vdash\lambda t}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\dfrac{M:m\in\Gamma\quad\overbrace{x:m\Rightarrow n}^{x_{1},\mydots,x_{m}\in\{1,\mydots,n\}\text{ distinct}}}{\Gamma;n\vdash M(\var{x_{1}},\mydots,\var{x_{m}})}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Syntax of 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:syntax-lam"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
To alleviate notations, a metavariable application is denoted by 
\begin_inset Formula $M(i_{1},\dots,i_{m})$
\end_inset

 instead of 
\begin_inset Formula $M(v_{i_{1}},\dots,v_{i_{m}})$
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The benefit is that there is no need to shift free variables under a 
\begin_inset Formula $\lambda$
\end_inset

, making substitution simpler.
 Whether a variable is bound or not depends on the variable context.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Agda implementation of metavariable substitution is listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:subst-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 A 
\emph on
metavariable substitution
\emph default
 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 assigns to each metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $m$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

 a term 
\begin_inset Formula $\Delta;m\vdash\sigma_{M}$
\end_inset

.
 In Agda, the type of substitutions between 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Delta$
\end_inset

 is defined as 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AgdaFunction{VecList}
\backslash
AgdaSpace{}
\end_layout

\begin_layout Plain Layout


\backslash
AgdaSymbol{(}
\backslash
AgdaDatatype{Tm}
\backslash
AgdaSpace{}
\end_layout

\begin_layout Plain Layout


\backslash
AgdaBound{Δ}
\backslash
AgdaSymbol{)}
\backslash
AgdaSpace{}
\end_layout

\begin_layout Plain Layout


\backslash
AgdaBound{Γ}
\end_layout

\end_inset


\end_layout

\end_inset

, where 
\begin_inset Formula $\AgdaFunction{VecList.t}\ \AgdaSpace{}\AgdaFunction{X}\ \AgdaFunction{\ensuremath{\ell}}$
\end_inset

 is (recursively) defined as the product type 
\begin_inset Formula $X\ a_{1}\times\dots\times X\ a_{n}$
\end_inset

 for any dependent type 
\begin_inset Formula $X:A\rightarrow\AgdaPrimitive{Set}$
\end_inset

 and list 
\begin_inset Formula $\ell=[a_{1},\dots,a_{n}]$
\end_inset

 of elements of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{id-renaming}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\underbrace{id}_{(1,2,\dots,n)}:n\Rightarrow n
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{compose-renamings}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{x:q\Rightarrow r\qquad y:p\Rightarrow q}{\underbrace{x\circ y}_{{\displaystyle (x_{y_{1}},\dots,x_{y_{p}})}}:p\Rightarrow r}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{wk-renamings}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{x:p\Rightarrow q}{\underbrace{\lamrenaming x}_{(x_{1},\dots,x_{p},q+1)}:p+1\Rightarrow q+1}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{renaming}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
\dfrac{\Gamma;n\vdash t\qquad x:n\Rightarrow p}{\Gamma;p\vdash\rename tx}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Renaming for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:ren-lambda"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{substitution-def}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{substitution}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma;n\vdash t\qquad\sigma:\Gamma\rightarrow\Delta}{\Delta;n\vdash t[\sigma]}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{composesubst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\sigma:\Gamma_{1}\rightarrow\Gamma_{2}\quad\delta:\Gamma_{2}\rightarrow\Gamma_{3}}{\underbrace{\sigma[\delta]}_{M\mapsto\sigma_{M}[\delta]}:\Gamma_{1}\rightarrow\Gamma_{3}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{lift-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\xrightarrow{\sigma}\Delta}{M:m,\Gamma\xrightarrow{\lamsubst{\sigma}{M:m}}M:m,\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Metavariable substitution for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:subst-lambda"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{composesubst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\sigma:\Gamma_{1}\rightarrow\Gamma_{2}\quad\delta:\Gamma_{2}\rightarrow\Gamma_{3}}{\underbrace{\sigma[\delta]}_{M\mapsto\sigma_{M}[\delta]}:\Gamma_{1}\rightarrow\Gamma_{3}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{wk-substitution}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\xrightarrow{\sigma}\Delta}{\Gamma\xrightarrow{\wk{\sigma}}M:m,\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{id-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\underbrace{1_{\Gamma}}_{M\mapsto M(id)}:\Gamma\rightarrow\Gamma
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{extend-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\frac{\begin{array}{c}
M:m\in\Gamma\quad\Delta;m\vdash t\\
\Gamma\backslash M\xrightarrow{\sigma}\Delta
\end{array}}{\Gamma\xrightarrow{M\mapsto t,\sigma}\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{replace-mvar}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\frac{M:m\in\Gamma\quad x:p\Rightarrow m}{\Gamma\xrightarrow{M\mapsto M(x)}\Gamma[M:p]}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "70col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{lift-subst}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "29col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\xrightarrow{\sigma}\Delta}{M:m,\Gamma\xrightarrow{\lamsubst{\sigma}{M:m}}M:m,\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
Main building blocks for metavariable substitutions 
\begin_inset CommandInset label
LatexCommand label
name "fig:building-blocks-subst"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This assignation extends (through a recursive definition) to any term 
\begin_inset Formula $\Gamma;n\vdash t$
\end_inset

, yielding a term 
\begin_inset Formula $\Delta;n\vdash t[\sigma]$
\end_inset

.
 The base case is
\begin_inset Formula 
\[
M(x_{1},\dots,x_{m})[\sigma]=\rename{\sigma_{M}}x,
\]

\end_inset

 where 
\begin_inset Formula $\rename -x$
\end_inset

 is variable renaming (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:ren-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
 For example, the identity substitution 
\begin_inset Formula $1_{\Gamma}:\Gamma\rightarrow\Gamma$
\end_inset

 is defined by the term 
\begin_inset Formula $M(1,\dots,m)$
\end_inset

 for each metavariable declaration 
\begin_inset Formula $M:m\in\Gamma$
\end_inset

.
 The composition 
\begin_inset Formula $\sigma[\sigma']:\Gamma_{1}\rightarrow\Gamma_{3}$
\end_inset

 of two substitutions 
\begin_inset Formula $\sigma:\Gamma_{1}\rightarrow\Gamma_{2}$
\end_inset

 and 
\begin_inset Formula $\sigma':\Gamma_{2}\rightarrow\Gamma_{3}$
\end_inset

 is defined as 
\begin_inset Formula $M\mapsto\sigma_{M}[\sigma']$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:building-blocks-subst"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we then define the main building blocks of substitution that the algorithm
 relies on.
 We use the following notations.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
unifier
\emph default
 of two terms 
\begin_inset Formula $\Gamma;n\vdash t,u$
\end_inset

 is a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Gamma'$
\end_inset

 such that 
\begin_inset Formula $t[\sigma]=u[\sigma]$
\end_inset

.
 A 
\emph on
most general unifier
\emph default
 of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 is a unifier 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Gamma'$
\end_inset

 that uniquely factors any other unifier 
\begin_inset Formula $\delta:\Gamma\rightarrow\Delta$
\end_inset

, in the sense that there exists a unique 
\begin_inset Formula $\delta':\Gamma'\rightarrow\Delta$
\end_inset

 such that 
\begin_inset Formula $\delta=\sigma[\delta']$
\end_inset

.
 We denote this situation by 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Gamma'$
\end_inset

, leaving the variable context 
\begin_inset Formula $n$
\end_inset

 implicit.
 Intuitively, the symbol 
\begin_inset Formula $\Rightarrow$
\end_inset

 separates the input and the output of the unification algorithm, which
 either returns a most general unifier, or fails when there is no unifier
 at all (for example, when unifying 
\begin_inset Formula $t_{1}\ t_{2}$
\end_inset

 with 
\begin_inset Formula $\lambda u$
\end_inset

).
 The type signature of our unification algorithm is thus
\end_layout

\begin_layout Standard
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
agdalccode{substfrom}
\backslash
agdalccode{unifyprototype}
\end_layout

\end_inset


\end_layout

\end_inset

where 
\begin_inset Formula $\AgdaDatatype{Maybe}\ X$
\end_inset

 is an inductive type with an error constructor 
\begin_inset Formula $\bot$
\end_inset

 and a success constructor 
\begin_inset Formula $\lfloor-\rfloor$
\end_inset

 taking as argument an element of type 
\begin_inset Formula $X$
\end_inset

.
\end_layout

\begin_layout Standard
The unification algorithm recursively inspects the structure of the given
 terms until reaching a metavariable at the top-level, as seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-lam-same-shape"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In the implementation, we exploit the 
\emph on
do
\emph default
 notation to propagate failure.
 For example, in the application case, the program fails if 
\begin_inset Formula $\AgdaFunction{unify}\ t\ t'$
\end_inset

 does, otherwise it continues with the success return values 
\begin_inset Formula $\Delta_{1},\sigma_{1}$
\end_inset

.
 
\end_layout

\begin_layout Standard
From a mathematical point of view, it is more convenient to handle failure
 by considering
\begin_inset Foot
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we interpret 
\begin_inset Formula $\bot$
\end_inset

 as a terminal object freely added to the category of metavariable contexts
 and substitutions between them.
\end_layout

\end_inset

 a formal error metavariable context 
\begin_inset Formula $\bot$
\end_inset

 in which the only term (in any variable context) is a formal error term
 
\begin_inset Formula $!$
\end_inset

, inducing a unique substitution 
\begin_inset Formula $!:\Gamma\rightarrow\bot$
\end_inset

, satisfying 
\begin_inset Formula $t[!]=\bang$
\end_inset

 for any term 
\begin_inset Formula $t$
\end_inset

, as demonstrated in the last case when unifying two different 
\emph on
rigid
\emph default
 term constructors (application, 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, or variables).
 With this extended meaning, the inductive rule for application remains
 sound, in a sense that will be clarified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Formally, failure propagation is modelled by the following rule.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\dfrac{}{\bot\vdash t=u\Rightarrow\bot\dashv\bot}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unification of two metavariables for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-flex-flex"

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Decomposing the rules
\begin_inset Formula 
\[
\dfrac{M:m\in\Gamma\qquad\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto P(z)\dashv P:p,\Gamma\backslash M}\quad\dfrac{\begin{array}{c}
M:m,M':m'\in\Gamma\quad M\neq M'\\
\highlighted{m\prunecat xy{r\dashv p}l{}}
\end{array}}{\Gamma\vdash M(x)=M'(y)\Rightarrow M\mapsto P(l),M'\mapsto P(r)\dashv P:p,\Gamma\backslash M\backslash M'}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-flex-flex-proto}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-flex-flex-same}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "57col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{M:m,\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto P(z)\dashv P:p,\Gamma}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{M,M'\in\Gamma\qquad\Gamma\vdash M(x)=M'(y)\Rightarrow\sigma\dashv\Delta}{P:p,\Gamma\vdash M(x)=M'(y)\Rightarrow\lamsubst{\sigma}{P:p}\ \dashv P:p,\Delta}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{M'\in\Gamma\qquad\highlighted{m\prunecat xy{r\dashv p}l{}}}{M:m,\Gamma\vdash M(x)=M'(y)\Rightarrow\lamsubst{\sigma}{P:p}\ \dashv P:p,\Delta}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{M:m\in\Gamma\qquad\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto P(z)\dashv P:p,\Gamma\backslash M}}{Flex-eq}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "43col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-flex-flex-diff}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "57col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{M:m,\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto P(z)\dashv P:p,\Gamma}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{M,M'\in\Gamma\qquad\Gamma\vdash M(x)=M'(y)\Rightarrow\sigma\dashv\Delta}{P:p,\Gamma\vdash M(x)=M'(y)\Rightarrow\lamsubst{\sigma}{P:p}\ \dashv P:p,\Delta}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{M'\in\Gamma\qquad\highlighted{m\prunecat xy{r\dashv p}l{}}}{M:m,\Gamma\vdash M(x)=M'(y)\Rightarrow\lamsubst{\sigma}{P:p}\ \dashv P:p,\Delta}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{\begin{array}{c}
M:m,M':m'\in\Gamma\quad M\neq M'\\
\highlighted{m\prunecat xy{r\dashv p}l{}}
\end{array}}{\begin{array}{l}
\Gamma\vdash M(x)=M'(y)\Rightarrow\\
\quad\left(\begin{array}{c}
M\mapsto P(l)\\
M'\mapsto P(r)
\end{array}\right)\dashv P:p,\Gamma\backslash M\backslash M'
\end{array}}}{Flex-neq}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unification of two metavariables applications 
\begin_inset Formula $M(x_{1},\dots,x_{m})$
\end_inset

 and 
\begin_inset Formula $M'(y_{1},\dots,y_{m'})$
\end_inset

 is detailed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The algorithm starts by testing whether 
\begin_inset Formula $M'$
\end_inset

 is in 
\begin_inset Formula $\Gamma\backslash M$
\end_inset

, which denotes the context 
\begin_inset Formula $\Gamma$
\end_inset

 without 
\begin_inset Formula $M$
\end_inset

.
 Note that this doesn't hold precisely when 
\begin_inset Formula $M=M'$
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We rely on the following notations.
\end_layout

\begin_layout Notation
Assume that 
\begin_inset Formula $M:m\in\Gamma$
\end_inset

.
 Then,
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\Gamma\backslash M$
\end_inset

 denotes the metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

 without 
\begin_inset Formula $M$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma[M:p]$
\end_inset

 replaces 
\begin_inset Formula $M:m$
\end_inset

 with is assigned 
\begin_inset Formula $M:p$
\end_inset

 in 
\begin_inset Formula $\Gamma$
\end_inset

.
\end_layout

\end_deeper
\end_inset

 In this case, we need to consider the 
\emph on
vector of common positions 
\emph default
of 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, that is, the maximal vector of (distinct) positions 
\begin_inset Formula $(z_{1},\dots,z_{p})$
\end_inset

 such that 
\begin_inset Formula $x_{\vec{z}}=y_{\vec{z}}$
\end_inset

.
 We denote
\begin_inset Foot
status open

\begin_layout Plain Layout
The similarity with the above introduced notation is no coincidence: as
 we will see (
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:equaliser-notation"
plural "false"
caps "true"
noprefix "false"

\end_inset

), both are (co)equalisers.
\end_layout

\end_inset

 such a situation by 
\begin_inset Formula $\highlighted{m\vdash x=y\Rightarrow z\dashv p}$
\end_inset

.
 The most general unifier 
\begin_inset Formula $\sigma$
\end_inset

 coincides with the identity substitution except that 
\begin_inset Formula $M:m$
\end_inset

 is replaced by a fresh metavariable 
\begin_inset Formula $P:p$
\end_inset

 in the context, and 
\begin_inset Formula $\sigma$
\end_inset

 maps 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $P(z)$
\end_inset

.
 
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $x,y,z$
\end_inset

 be three distinct variables, and let us consider unification of 
\begin_inset Formula $M(x,y)$
\end_inset

 and 
\begin_inset Formula $M(z,x)$
\end_inset

.
 Given a unifier 
\begin_inset Formula $\sigma$
\end_inset

, since 
\begin_inset Formula $M(x,y)[\sigma]=\rename{\sigma_{M}}{1\mapsto x,2\mapsto y}$
\end_inset

 and 
\begin_inset Formula $M(z,x)[\sigma]=\rename{\sigma_{M}}{1\mapsto z,2\mapsto x}$
\end_inset

 must be equal, 
\begin_inset Formula $\sigma_{M}$
\end_inset

 cannot depend on the variables 
\begin_inset Formula $1,2$
\end_inset

.
 It follows that the most general unifier is 
\begin_inset Formula $M\mapsto M'$
\end_inset

, replacing 
\begin_inset Formula $M$
\end_inset

 with a fresh constant metavariable 
\begin_inset Formula $M'$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This matches the recipe given above: the vector of common positions of 
\begin_inset Formula $(x,y)$
\end_inset

 and 
\begin_inset Formula $(z,x)$
\end_inset

 is indeed empty.
\end_layout

\end_inset

A similar argument shows that the most general unifier of 
\begin_inset Formula $M(x,y)$
\end_inset

 and 
\begin_inset Formula $M(z,y)$
\end_inset

 is 
\begin_inset Formula $M\mapsto M'(2)$
\end_inset

.
\end_layout

\begin_layout Standard
The corresponding rule 
\begin_inset Formula $\refrule{Flex-eq}$
\end_inset

 does not stipulate how to generate the fresh metavariable symbol 
\begin_inset Formula $P$
\end_inset

.
 But since 
\begin_inset Formula $M$
\end_inset

 is removed from 
\begin_inset Formula $\Gamma$
\end_inset

, the name 
\begin_inset Formula $M$
\end_inset

 becomes fresh and therefore provides a canonical choice.
 Accordingly, the implementation keeps 
\begin_inset Formula $M$
\end_inset

 but changes its arity to 
\begin_inset Formula $p$
\end_inset

, resulting in a context denoted by 
\begin_inset Formula $\Gamma[M:p]$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following rule is thus more faithful with the implementation, although
 it is equivalent to 
\begin_inset Formula $\refrule{Flex-eq}$
\end_inset

.
\begin_inset Formula 
\[
\dfrac{M:m\in\Gamma\qquad\highlighted{m\vdash x=y\Rightarrow z\dashv p}}{\Gamma\vdash M(x)=M(y)\Rightarrow M\mapsto M(z)\dashv\Gamma[M:p]}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $M\neq M'$
\end_inset

, consider the vectors of common values positions 
\begin_inset Formula $(l_{1},\dots,l_{p})$
\end_inset

 and 
\begin_inset Formula $(r_{1},\dots,r_{p})$
\end_inset

 between 
\begin_inset Formula $x_{1},\dots,x_{m}$
\end_inset

 and 
\begin_inset Formula $y_{1},\dots,y_{m'}$
\end_inset

, i.e., the pair of maximal lists 
\begin_inset Formula $(\vec{l},\vec{r})$
\end_inset

 of distinct positions such that 
\begin_inset Formula $x_{\vec{l}}=y_{\vec{r}}$
\end_inset

.
 We denote such a situation by 
\begin_inset Formula $\highlighted{m\prunecat xy{r\dashv p}l{}}$
\end_inset

.
 The most general unifier 
\begin_inset Formula $\sigma$
\end_inset

 coincides with the identity substitution except that the metavariables
 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $M'$
\end_inset

 are removed from the context and replaced by a single metavariable declaration
 
\begin_inset Formula $P:p$
\end_inset

.
 Then, 
\begin_inset Formula $\sigma$
\end_inset

 maps 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $P(l)$
\end_inset

 and 
\begin_inset Formula $M'$
\end_inset

 to 
\begin_inset Formula $P(r)$
\end_inset

.
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $x,y,z$
\end_inset

 be three distinct variables.
 The most general unifier of 
\begin_inset Formula $M(x,y)$
\end_inset

 and 
\begin_inset Formula $N(z,x)$
\end_inset

 is 
\begin_inset Formula $M\mapsto N'(\var 1),N\mapsto N'(\var 2)$
\end_inset

.
 The most general unifier of 
\begin_inset Formula $M(x,y)$
\end_inset

 and 
\begin_inset Formula $N(z)$
\end_inset

 is 
\begin_inset Formula $M\mapsto N',N\mapsto N'$
\end_inset

.
\end_layout

\begin_layout Standard
As previously, the corresponding rule 
\begin_inset Formula $\refrule{Flex-neq}$
\end_inset

 does not stipulate how to generate the fresh metavariable symbol 
\begin_inset Formula $P$
\end_inset

.
 But since both 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $M'$
\end_inset

 are removed from the context, either of them can be chosen as a fresh metavaria
ble.
 The implementation actually picks 
\begin_inset Formula $M'$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following rule is thus more faithful with the Agda code:, and can be
 thought of as a possible implementation of 
\begin_inset Formula $\refrule{Flex-neq}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
M:m,M':m'\in\Gamma\quad M\neq M'\\
\highlighted{m\prunecat xy{r\dashv p}l{}}
\end{array}}{\Gamma\vdash M(x)=M'(y)\Rightarrow\left(\begin{array}{c}
M\mapsto M'(l)\\
M'\mapsto M'(r)
\end{array}\right)\dashv\Gamma\backslash M[M':p]}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\vdash t=t'\Rightarrow\sigma\dashv\Delta}{\Gamma\vdash\lambda t=\lambda t'\Rightarrow\sigma\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\Gamma\vdash t=t'\Rightarrow\sigma_{1}\dashv\Delta_{1}\\
\Gamma\vdash u[\sigma_{1}]=u'[\sigma_{2}]\Rightarrow\sigma_{2}\dashv\Delta_{2}
\end{array}}{\Gamma\vdash t\ u=t'\ u'\Rightarrow\sigma_{1}[\sigma_{2}]\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{i\neq j}{\Gamma\vdash\lcvar i=\lcvar j\Rightarrow\bang\dashv\bot}\qquad\dfrac{}{\Gamma\vdash\lcvar i=\lcvar i\Rightarrow1_{\Gamma}\dashv\Gamma}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-last}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{o\neq o'\ \text{(\emph{rigid} term constructors)}}{\Gamma\vdash o(\vec{t})=o'(\vec{t'})\Rightarrow\bang\dashv\bot}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unification for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

): main phase 
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-lam-same-shape"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Unification with a metavariable application for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-flex"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-flex-def}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-flex-no-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\in u\qquad u\neq M(\dots)}{\Gamma,M:m\vdash M(x)=u\Rightarrow\bang\dashv\bot}}{Cycle}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\labellabelrule{\dfrac{M\notin u\qquad\Gamma\backslash M\prune u{\maybold M(\vec{x})}{\sigma}w\dashv\Delta}{\Gamma\vdash M(\vec{x})=u\Rightarrow\sigma,M\mapsto w\dashv\Delta}}{No-cycle}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unification of a metavariable application 
\begin_inset Formula $M(x_{1},\dots,x_{m})$
\end_inset

 with a term 
\begin_inset Formula $u$
\end_inset

 is detailed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-flex"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We have just discussed the case when 
\begin_inset Formula $u$
\end_inset

 is a metavariable.
 Let us detail the other case.
 The algorithm starts by checking whether 
\begin_inset Formula $M$
\end_inset

 can be removed from the metavariable context in which 
\begin_inset Formula $u$
\end_inset

 is typed.
 If not, then 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AgdaBound{u}
\backslash
AgdaSpace{}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaOperator{
\backslash
AgdaFunction{⑊?ₜ}}
\backslash
AgdaSpace{}%
\end_layout

\begin_layout Plain Layout


\backslash
AgdaBound{M}
\end_layout

\end_inset


\end_layout

\end_inset

 fails and the 
\emph on
do 
\emph default
notation propagates the error.
 This situation described by the failing rule 
\begin_inset Formula $\refrule{Cycle}$
\end_inset

 happens precisely when 
\begin_inset Formula $M$
\end_inset

 occurs in 
\begin_inset Formula $u$
\end_inset

: since 
\begin_inset Formula $u$
\end_inset

 is not a metavariable, there is no unifier because the size of both hand
 sides can never match after substitution.
 
\end_layout

\begin_layout Standard
We are left with the case when 
\begin_inset Formula $M$
\end_inset

 does not occur in 
\begin_inset Formula $u$
\end_inset

.
 The algorithm then enters a 
\emph on
non-cyclic phase
\emph default
, which specifically addresses such non-cyclic unification problems: this
 is what happens in the premise of the rule 
\begin_inset Formula $\refrule{No-cycle}$
\end_inset

.
 It uses
\begin_inset Foot
status open

\begin_layout Plain Layout
The similarity with the notation for common value positions is no coincidence:
 both are (co)pullbacks, as we will see in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:pushout-notation"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 the notation 
\begin_inset Formula $\Gamma\prune u{\maybold M(\vec{x})}{\sigma\dashv\Delta}w$
\end_inset

 for this non-cyclic phase, where 
\begin_inset Formula $u$
\end_inset

 is a term in the metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

, while 
\begin_inset Formula $M$
\end_inset

 is a fresh metavariable with respect to 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\vec{x}=(x_{1},\dots,x_{m})$
\end_inset

 are distinct variables in the (implicit) variable context of 
\begin_inset Formula $u$
\end_inset

.
 The output is the most general unifier of 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $M(\vec{x})$
\end_inset

, both considered in the extended metavariable context 
\begin_inset Formula $M:m,\Gamma$
\end_inset

.
 This substitution from 
\begin_inset Formula $M:m,\Gamma$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

 is explicitly defined as the extension of a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 with a term 
\begin_inset Formula $\Delta;m\vdash w$
\end_inset

 for substituting 
\begin_inset Formula $M$
\end_inset

.
 The type signature of the non-cyclic phase is thus
\end_layout

\begin_layout Standard
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-no-cycle-proto}
\end_layout

\end_inset


\end_layout

\end_inset

Note that contrary to the above notation, because of the nameless encoding,
 the fresh metavariable symbol 
\begin_inset Formula $M$
\end_inset

 is not explicit.
\end_layout

\begin_layout Remark
The symbol 
\begin_inset Formula $:>$
\end_inset

 evokes the 
\emph on
pruning
\emph default
 involved in this phase.
 Indeed, one intuition behind the non-cyclic unification of 
\begin_inset Formula $M(\vec{x})$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 consists in taking 
\begin_inset Formula $u[x_{i}\mapsto\var i]$
\end_inset

 as a definition for 
\begin_inset Formula $M$
\end_inset

.
 This only makes sense if the free variables of 
\begin_inset Formula $u$
\end_inset

 are among 
\begin_inset Formula $\vec{x}$
\end_inset

: if 
\begin_inset Formula $u$
\end_inset

 is a variable that does not occur in 
\begin_inset Formula $\vec{x}$
\end_inset

, then obviously there is no unifier.
 However, it is possible to remove the 
\emph on
outbound
\emph default
 variables in 
\begin_inset Formula $u$
\end_inset

 if they only occur in metavariable arguments, by restricting the arities
 of those metavariables.
 We accordingly call 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 the pruning substitution.
 As an example, if 
\begin_inset Formula $u$
\end_inset

 is a metavariable application 
\begin_inset Formula $N(\vec{x},\vec{y})$
\end_inset

, then although the free variables are not all included in 
\begin_inset Formula $\vec{x}$
\end_inset

, there is still a most general unifier, and the corresponding pruning substitut
ion essentially replaces 
\begin_inset Formula $N$
\end_inset

 with 
\begin_inset Formula $M$
\end_inset

, discarding the outbound variables 
\begin_inset Formula $\vec{y}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The non-cyclic phase proceeds recursively as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:unif-no-cycle-lam"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The metavariable case is straightforward.
 In the variable case, 
\begin_inset Formula $i\{x\}^{-1}$
\end_inset

 returns the index 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $i=x_{j}$
\end_inset

, or fails if no such 
\begin_inset Formula $j$
\end_inset

 exist.
 For 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, a fresh variable 
\begin_inset Formula $M'$
\end_inset

 is introduced for the body of the 
\begin_inset Formula $\lambda$
\end_inset

-abstraction which is additionally applied to the bound variable 
\begin_inset Formula $\var{n+1}$
\end_inset

, as it should not be pruned.
 Keeping in mind the intuition that 
\begin_inset Formula $M=\lambda M'$
\end_inset

, if 
\begin_inset Formula $M'$
\end_inset

 is to be substituted with 
\begin_inset Formula $t'$
\end_inset

, then 
\begin_inset Formula $M$
\end_inset

 should be substituted with 
\begin_inset Formula $\lambda t'$
\end_inset

, thus justifying the conclusion of the rule.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-no-cycle-flex}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\frac{M':m',\Gamma\vdash M(x)=M'(y)\Rightarrow t,\sigma\dashv\Delta}{\Gamma\prune{M(x)}{\maybold M'(y)}{\sigma}t\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-no-cycle-lam}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\Gamma\prune t{\maybold M'(x\uparrow)}{\sigma}{t'}\dashv\Delta}{\Gamma\prune{\lambda t}{\maybold M(x)}{\sigma}{\lambda t'}\dashv\Delta}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-no-cycle-var}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{i=x_{j}}{\Gamma\prune{\lcvar i}{\maybold M(x)}{1_{\Gamma}}{\lcvar j}\dashv\Gamma}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{i\notin\vec{x}}{\Gamma\prune{\lcvar i}{\maybold M(x)}{\bang}{\bang}\dashv\bot}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "55col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
agdalccode{unify-no-cycle-app}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Boxed
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align left
\begin_inset Formula 
\[
\dfrac{\begin{array}{c}
\Gamma\prune t{\maybold M_{1}(x)}{\sigma_{1}}{t'}\dashv\Delta_{1}\\
\Delta_{1}\prune{u[\sigma_{1}]}{\maybold M_{2}(x)}{\sigma}{u'}_{2}\dashv\Delta_{2}
\end{array}}{\Gamma\prune{t\ u}{\maybold M(x)}{\sigma}{t'[\sigma_{2}]\ u'}_{1}[\sigma_{2}]\dashv\Delta_{2}}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Non-cyclic unification for 
\begin_inset Formula $\lambda$
\end_inset

-calculus (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

) 
\begin_inset CommandInset label
LatexCommand label
name "fig:unif-no-cycle-lam"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
This ends our description of the unification algorithm, in the specific
 case of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 The purpose of this work is to present a generalisation, by parameterising
 the algorithm by a signature specifying a syntax.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Assume 
\begin_inset Formula $M$
\end_inset

 indeed appears at the top level in 
\begin_inset Formula $u$
\end_inset

, then the most general unifier replaces 
\begin_inset Formula $M$
\end_inset

 with a new metavariable whose arity is the number of common variables positions
 in both hand sides.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generalisation
\end_layout

\begin_layout Standard

\color red
To adapt
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:intro-generic"

\end_inset

Our algorithm is parameterised by a notion of signature generalising binding
 signatures
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "aczel2016general"
literal "false"

\end_inset

 to account for syntax with metavariables.
 
\end_layout

\begin_layout Standard
To recall, a binding signature 
\begin_inset Formula $(O,\alpha)$
\end_inset

 specifies for each natural number 
\begin_inset Formula $n$
\end_inset

 a set of 
\begin_inset Formula $n$
\end_inset

-ary operation symbols 
\begin_inset Formula $O_{n}$
\end_inset

 and for each 
\begin_inset Formula $o\in O_{n}$
\end_inset

, an arity 
\begin_inset Formula $\ntharvec o=(\nthar o1,\dots,\nthar on)$
\end_inset

 as a list of natural numbers specifying how many variables are bound in
 each argument.
 For example, pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus is specified by 
\begin_inset Formula $O_{1}=\{lam\}$
\end_inset

, 
\begin_inset Formula $O_{2}=\{app\}$
\end_inset

, 
\begin_inset Formula $\ntharvec{app}=(0,0)$
\end_inset

, 
\begin_inset Formula $\ntharvec{lam}=(1)$
\end_inset

, and 
\begin_inset Formula $O_{n}=\emptyset$
\end_inset

 for any natural number 
\begin_inset Formula $n\notin\{1,2\}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that variables cannot be specified by an arity.
 They are always implicitly included in the syntax specified by a binding
 signature.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our algorithm is parameterised by a 
\emph on
generalised binding signature
\emph default
, or GB-signature, a notion we will formally introduce in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:GB-signature"
plural "false"
caps "true"
noprefix "false"

\end_inset

, and is implemented in Agda code as shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:sig-agda"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 A GB-signature consists in a tuple 
\begin_inset Formula $({\cal A},O,\ntharvecfunct)$
\end_inset

 consisting of 
\end_layout

\begin_layout Itemize
a small category 
\begin_inset Formula ${\cal A}$
\end_inset

 whose objects are called 
\emph on
arities
\shape italic
\emph default
 
\emph on
or
\emph default
 variable contexts
\emph on
,
\shape default
\emph default
 and whose morphisms are called 
\shape italic
renamings
\shape default
;
\end_layout

\begin_layout Itemize
for each variable context 
\begin_inset Formula $a$
\end_inset

 and natural number 
\begin_inset Formula $n$
\end_inset

, a set of 
\begin_inset Formula $n$
\end_inset

-ary operation symbols 
\begin_inset Formula $\Oop na$
\end_inset

;
\end_layout

\begin_layout Itemize
for each operation symbol 
\begin_inset Formula $o\in\Oop na$
\end_inset

, a list of variable contexts 
\begin_inset Formula $\ntharvec o=(\nthar o1,\dots,\nthar on)$
\end_inset


\end_layout

\begin_layout Standard
such that 
\begin_inset Formula $O$
\end_inset

 and 
\begin_inset Formula $\ntharvecfunct$
\end_inset

 are functorial in a suitable sense (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:bgsig-functorial"
plural "false"
caps "true"
noprefix "false"

\end_inset

 below).
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We will call an element of 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

 an 
\emph on

\begin_inset Formula $o$
\end_inset

-index.

\emph default
 
\end_layout

\end_inset

Intuitively, 
\begin_inset Formula $\Oop na$
\end_inset

 is the set of 
\begin_inset Formula $n$
\end_inset

-ary operation symbols available in the variable context 
\begin_inset Formula $a$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
In the following, 
\begin_inset Formula $\AgdaFunction{Vec}\ \AgdaFunction{X}\ \AgdaFunction{n}$
\end_inset

 is the type of vectors of elements of X of size n.
 Given two vectors 
\begin_inset Formula $\ell=[a_{1},\dots,a_{n}]$
\end_inset

 and 
\begin_inset Formula $\ell'=[a'_{1},\dots,a'_{n}]$
\end_inset

 of objects of the same category, the type 
\begin_inset Formula $\ell\ \AgdaFunction{V.\ensuremath{\Rightarrow}}\ \ell'$
\end_inset

 is recursively defined as the type 
\begin_inset Formula $(a_{1}\Rightarrow a_{1}')\times\dots\times(a_{n}\Rightarrow a_{n}')$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\align left
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ExecuteMetaData[latex/main.tex]{signature}
\end_layout

\begin_layout Plain Layout


\backslash
ExecuteMetaData[latex/main.tex]{syntax}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Definition of signatures and associated syntax in Agda
\begin_inset CommandInset label
LatexCommand label
name "fig:sig-agda"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:syntax-bsig"

\end_inset

The syntax specified by a GB-signature 
\begin_inset Formula $({\cal A},O,\ntharvecfunct)$
\end_inset

 is inductively generated by the two following rules.
\begin_inset Formula 
\[
\labellabelrule{\dfrac{o\in\Oop na\quad\Gamma;\nthar o1\vdash t_{1}\quad\dots\quad\Gamma;\nthar on\vdash t_{n}}{\Gamma;a\vdash o(t_{1},\dots,t_{n})}}{Rig}
\]

\end_inset


\begin_inset Formula 
\[
\labellabelrule{\dfrac{M:m\in\Gamma\quad x\in\hom_{{\cal A}}(m,a)}{\Gamma;a\vdash M(x)}}{Flex}
\]

\end_inset

where a context 
\begin_inset Formula $\Gamma;a$
\end_inset

 consists of a variable context 
\begin_inset Formula $a$
\end_inset

 and a metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

, as a metavariable arity function from a finite set of metavariable symbols
 to the set of objects of 
\begin_inset Formula ${\cal A}$
\end_inset

.
 We call a term 
\emph on
rigid 
\emph default
if it is of the shape 
\begin_inset Formula $o(\dots)$
\end_inset

, 
\emph on
flexible
\emph default
 if it is 
\begin_inset Formula $M(\dots)$
\end_inset

.
\end_layout

\begin_layout Remark
The syntax in the empty metavariable context does not depend on the morphisms
 in 
\begin_inset Formula ${\cal A}$
\end_inset

.
 In fact, by restricting the morphisms in the category of arities to identity
 morphisms, any GB-signature induces an indexed container
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/lics/AltenkirchM09"
literal "false"

\end_inset

 generating the same syntax without metavariables.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex:gbsig-bsig"

\end_inset

Binding signatures can be compiled into GB-signatures.
 More specifically, a syntax specified by a binding signature 
\begin_inset Formula $(O,\alpha)$
\end_inset

 is also generated by the GB-signature 
\begin_inset Formula $(\mathbb{F}_{m},O',\nthaarvecfunct$
\end_inset

), where
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 is the category of finite cardinals and injections between them;
\end_layout

\begin_layout Itemize
\begin_inset Formula $O'_{n}(p)=\{v_{1},\dots,v_{p}\}\sqcup\{o_{p}|o\in O_{n}\}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\nthaarvec{v_{i}}=()$
\end_inset

 and 
\begin_inset Formula $\nthaarvec{o_{p}}=(p+\nthar o1,\dots,p+\nthar on)$
\end_inset

 for any 
\begin_inset Formula $i,p,n\in\mathbb{N},o\in O_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
Note that variables 
\begin_inset Formula $v_{i}$
\end_inset

 are explicitly specified as nullary operations and thus do not require
 a dedicated generating rule, contrary to what happens with binding signatures.
 Moreover, the choice of renamings (i.e., morphisms in the category of arities)
 is motivated by the 
\begin_inset Formula $\refrule{Flex}$
\end_inset

 rule.
 Indeed, if 
\begin_inset Formula $M$
\end_inset

 has arity 
\begin_inset Formula $m\in\mathbb{N}$
\end_inset

, then a choice of arguments in the variable context 
\begin_inset Formula $a\in\mathbb{N}$
\end_inset

 consists of a list of distinct variables in the variable context 
\begin_inset Formula $a$
\end_inset

, or equivalently, an injection between the cardinal sets 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $a$
\end_inset

, that is, a morphism in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 between 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Example
GB-signatures capture multi-sorted binding signatures such as simply-typed
 
\begin_inset Formula $\lambda$
\end_inset

-calculus, or polymorphic syntax such as System F (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:applications"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:bgsig-functorial"

\end_inset

In the notion of GB-signature, functoriality ensures that the generated
 syntax supports renaming: given a morphism 
\begin_inset Formula $f:a\rightarrow b$
\end_inset

 in 
\begin_inset Formula ${\cal A}$
\end_inset

 and a term 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, we can recursively define a term 
\begin_inset Formula $\Gamma;b\vdash\rename tf$
\end_inset

.
 The case of metavariables is simple: 
\begin_inset Formula $\rename{M(x)}f=M(f\circ x)$
\end_inset

.
 For an operation 
\begin_inset Formula $o(t_{1},\dots,t_{n})$
\end_inset

, functoriality provides the following components:
\end_layout

\begin_deeper
\begin_layout Itemize
an operation symbol 
\begin_inset Formula $\rename of\in\Oop nb$
\end_inset

;
\end_layout

\begin_layout Itemize
a morphism 
\begin_inset Formula $\ntharvecaction ofi:\nthar oi\rightarrow\nthar{\rename of}i$
\end_inset

 for each 
\begin_inset Formula $i\in\{1,\dots,n\}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Then, 
\begin_inset Formula $\rename{o(t_{1},\mydots,t_{n})}f$
\end_inset

 is defined as 
\begin_inset Formula $\rename of(\rename{t_{1}}{\ntharvecaction of1},\mydots,\rename{t_{n}}{\ntharvecaction ofn})$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
Unification can be formulated by following the same route as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:example-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 A metavariable substitution 
\begin_inset Formula $\sigma$
\end_inset

 from 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

 is a list of terms 
\begin_inset Formula $(\sigma_{1},\mydots,\sigma_{p})$
\end_inset

 such that 
\begin_inset Formula $\Delta;m_{i}\vdash\sigma_{i}$
\end_inset

.
 Given a term 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

, we can recursively define the substituted term 
\begin_inset Formula $\Delta;a\vdash t[\sigma]$
\end_inset

 by 
\begin_inset Formula $o(\vec{t})[\sigma]=o(\vec{t}[\sigma])$
\end_inset

 and 
\begin_inset Formula $M_{i}(x)[\sigma]=\rename{\sigma_{i}}x$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises our generic algorithm, parameterised by a GB-signature, and
 a few more parameters: a solver for the equation 
\begin_inset Formula 
\begin{equation}
o=\rename{o'}x,\label{eq:invert-eq}
\end{equation}

\end_inset

where 
\begin_inset Formula $o'$
\end_inset

 is the unknown (see the rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

, detailed below), and a construction of equalisers and pullbacks in 
\begin_inset Formula ${\cal A}$
\end_inset

, highlighted in blue.
 These are used to compute the most general unifier of two metavariable
 applications in the rules 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

.
 Specialised to pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus, they correspond to the rules 
\begin_inset Formula $\refULrule{Flex}$
\end_inset

 and 
\begin_inset Formula $\refPLrule{Flex}$
\end_inset

: indeed, the vector of common positions of 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

 can be characterised as their equaliser in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

, when thinking of lists as functions from a finite cardinal, while the
 vectors of common value positions can be characterised as a pullback.
\end_layout

\begin_layout Standard
The main differences with the example of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus presented above in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-pure-lambda"
plural "false"
caps "true"
noprefix "false"

\end_inset

 is that the vector notation is dropped for arguments of metavariables,
 since they are abstracted as morphisms in a category
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ex-arg-sets"
plural "false"
caps "true"
noprefix "false"

\end_inset

 for an example where metavariables arguments are sets rather than lists.
\end_layout

\end_inset

.
 Moreover, the case for operations and variables are merged in the non-cyclic
 phase with the rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 that both handle non-cyclic unification of 
\begin_inset Formula $M(x)$
\end_inset

 with 
\begin_inset Formula $o(\vec{t})$
\end_inset

.
 If 
\begin_inset Formula $o=\rename{o'}x$
\end_inset

 for some 
\begin_inset Formula $o'$
\end_inset

, then the rule 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 applies; otherwise, the rule 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 outputs an error.
 Let us explain how they specialise for a syntax specified by a binding
 signature as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "ex:gbsig-bsig"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In this case, 
\begin_inset Formula $x$
\end_inset

 is a list of distinct variables 
\begin_inset Formula $(x_{1},\dots,x_{m})$
\end_inset

.
 If 
\begin_inset Formula $o$
\end_inset

 is a variable 
\begin_inset Formula $v_{i}$
\end_inset

, then the side condition 
\begin_inset Formula $o=\rename{o'}x$
\end_inset

 means that 
\begin_inset Formula $i$
\end_inset

 is 
\begin_inset Formula $x_{j}$
\end_inset

 for some variable 
\begin_inset Formula $o'=v_{j}$
\end_inset

.
 Thus, those rules account for the rules 
\begin_inset Formula $\refPLrule{VarOk}$
\end_inset

 and 
\begin_inset Formula $\refPLrule{VarFail}$
\end_inset

.
 On the other hand, if 
\begin_inset Formula $o$
\end_inset

 is actually 
\begin_inset Formula $o_{n}$
\end_inset

, i.e., an operation symbol 
\begin_inset Formula $o$
\end_inset

 considered in the variable context 
\begin_inset Formula $n$
\end_inset

, then, by definition of the functorial action, 
\begin_inset Formula $o_{n}=\rename{o_{m}}x$
\end_inset

.
 Thus, the rule 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 always applies with 
\begin_inset Formula $o'=o_{m}$
\end_inset

.
 Moreover, 
\begin_inset Formula $\ntharvecaction oxi$
\end_inset

 is in fact the morphism from 
\begin_inset Formula $m+\nthar oi$
\end_inset

 to 
\begin_inset Formula $n+\nthar oi$
\end_inset

 defined as 
\begin_inset Formula $x+\nthar oi$
\end_inset

, corresponding to the list (
\begin_inset Formula $\vec{x},n+1,\dots,n+\nthar oi)$
\end_inset

.
 Thus, the rule 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 unfolds as 
\begin_inset Formula 
\[
\dfrac{\Gamma\prune{\vec{t}}{\mydots,M_{i}(\vec{x},\overbrace{\var{n+1},\mydots,\var{n+1+\nthar oi}}^{\mathclap{\text{bound variables}}}),\mydots}{\sigma}{\vec{u}}\dashv\Delta}{\Gamma\prune{o(\vec{t})}{M(\arg{\vec{x}})}{\sigma}{o(\vec{u})}\dashv\Delta}.
\]

\end_inset


\end_layout

\begin_layout Standard
Correctness of our generic algorithm relies on additional assumptions on
 the GB-signature that we introduce in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:pattern-friendly"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In particular all morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 must be monomorphic: this ensures that 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:invert-eq"
plural "false"
caps "true"
noprefix "false"

\end_inset

 has at most one solution (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:O-mono"
plural "false"
caps "true"
noprefix "false"

\end_inset

 below).
\end_layout

\begin_layout Subsection
Progress and termination
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:progress"

\end_inset


\end_layout

\begin_layout Standard
Each inductive rule in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

 provides an elementary step for the construction of the most general unifier.
 To ensure that this set of rules describes a terminating algorithm, we
 essentially need two properties: 
\emph on
progress
\emph default
, i.e., there is always one rule that applies given some input data
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
et aussi que ca preserve la propriete qu'une des branches est un coproduit
 +
\end_layout

\end_inset

, and 
\emph on
termination
\emph default
, i.e., there is no infinite sequence of rule applications.
 The former is ensured by Agda's type-checker.
 In this section we sketch the proof of the latter termination property,
 following a standard argument.
 Roughly, it consists in realising that for each rule, the premises are
 strictly smaller than the conclusion, for an adequate notion of input size.
 First, we define the size 
\begin_inset Formula $|\Gamma|$
\end_inset

 of a metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

 as the number of its declared metavariables.
 We extend this definition to the case where 
\begin_inset Formula $\Gamma=\bot$
\end_inset

, by taking 
\begin_inset Formula $|\bot|=0$
\end_inset

.
 We also recursively define the size 
\begin_inset Formula $||t||$
\end_inset

 of a term 
\begin_inset Formula $t$
\end_inset

 by 
\begin_inset Formula $||M(\arg x)||=1$
\end_inset

 and 
\begin_inset Formula $||o(\vec{t})||=1+||\vec{t}||$
\end_inset

, with 
\begin_inset Formula $||\vec{t}||=\sum_{i}||t_{i}||$
\end_inset

.
 Note that no term is of empty size.
 
\end_layout

\begin_layout Standard
Let us first quickly justify termination of the non-cyclic phase.
 We define the size of a judgment 
\begin_inset Formula $\Gamma\prune{\vec{t}}{\text{\ensuremath{\overrightarrow{M(x)}}}}{\sigma}{\vec{w}}\dashv\Delta$
\end_inset

 as 
\begin_inset Formula $||\vec{t}||$
\end_inset

.
 It is straightforward to check that the sizes of the premises are strictly
 smaller than the size of the conclusion, for the two recursive rules 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 of the non-cyclic phase, thanks to the following lemmas.
\end_layout

\begin_layout Lemma
For any term 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

 and substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

, if 
\begin_inset Formula $\sigma$
\end_inset

 is a 
\emph on
metavariable renaming
\emph default
, i.e., 
\begin_inset Formula $\sigma_{M}$
\end_inset

 is a metavariable application for any 
\begin_inset Formula $M:m\in\Gamma$
\end_inset

, then 
\begin_inset Formula $||t[\sigma]||=||t||$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
If there is a finite derivation tree of 
\begin_inset Formula $\Gamma\prune{\vec{t}}{\text{\ensuremath{\overrightarrow{M(x)}}}}{\sigma}{\vec{w}}\dashv\Delta$
\end_inset

 and 
\begin_inset Formula $\Delta\neq\bot$
\end_inset

, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\bot$
\end_inset

 n'est pas connexe car 
\begin_inset Formula $\bot+\bot=\bot$
\end_inset


\end_layout

\end_inset

 then 
\begin_inset Formula $|\Gamma|=|\Delta|$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 is a metavariable renaming.
\end_layout

\begin_layout Personal Question
Can we define it truly recursively?
\end_layout

\begin_layout Standard
The size invariance in the above lemma is actually used in the termination
 proof of the main unification phase, where the size of a judgment 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 is defined as the pair 
\begin_inset Formula $(|\Gamma|,||t||)$
\end_inset

.
 More precisely, it is used in the following lemma that ensures size decreasing
 (with respect to the lexicographic order) in the two recursive rules 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 and 
\begin_inset Formula $\refrule{U-RigRig}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There are two recursive rules: 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unify-stepwise"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unifying-rec"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Contrary to the non-cyclic phase, the first one is not structurally recursive
 since a substitution is applied to the argument.
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
If there is a finite derivation tree of 
\begin_inset Formula $\Gamma\vdash\vec{t}=\vec{u}\Rightarrow\sigma\dashv\Delta$
\end_inset

, then 
\begin_inset Formula $|\Gamma|\geq|\Delta|$
\end_inset

, and moreover if 
\begin_inset Formula $|\Gamma|=|\Delta|$
\end_inset

 and 
\begin_inset Formula $\Delta\neq\bot$
\end_inset

, then 
\begin_inset Formula $\sigma$
\end_inset

 is a metavariable renaming.
 
\end_layout

\begin_layout Section
Categorical semantics
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:cat-settings"

\end_inset

It remains to prove that each rule is sound, e.g., for the rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

, if the output of the premises are most general unifiers, then so is the
 conclusion.
 To do so, the next sections rely on the categorical semantics of pattern
 unification that we introduce in this section.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we relate pattern unification to a coequaliser construction, and in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:GB-sig"
plural "false"
caps "false"
noprefix "false"

\end_inset

, we provide a formal definition of GB-signatures with Initial Algebra Semantics
 for the generated syntax.
 
\end_layout

\begin_layout Subsection
Pattern unification as a coequaliser construction
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:categorification"

\end_inset


\end_layout

\begin_layout Standard
In this section, we assume given a GB-signature 
\begin_inset Formula $S=({\cal A},O,\ntharvecfunct)$
\end_inset

 and explain how most general unifiers can be thought of as equalisers in
 a multi-sorted Lawvere theory, as is well-known in the first-order case
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/daglib/0068768,10.5555/92134"
literal "false"

\end_inset

.
 We furthermore provide a formal justification for the error metavariable
 context 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Lemma
Metavariable contexts and substitutions (with their composition) between
 them define a category 
\begin_inset Formula $\Th S$
\end_inset

.
\end_layout

\begin_layout Standard
This relies on functoriality of GB-signatures that we will spell out formally
 in the next section.
 There, we will see in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:mcon-kleisli"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that this category fully faithfully embeds in a Kleisli category for a
 monad generated by 
\begin_inset Formula $S$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset Formula $\Th S$
\end_inset

 is the opposite category of a multi-sorted Lawvere theory: the sorts are
 the objects of 
\begin_inset Formula ${\cal A}$
\end_inset

.
 This theory is not freely generated by operations unless 
\begin_inset Formula ${\cal A}$
\end_inset

 is discrete, in which case we recover (multi-sorted) first-order unification.
 Even the GB-signature induced (as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "ex:gbsig-bsig"
plural "false"
caps "true"
noprefix "false"

\end_inset

) by an empty binding signature is not 
\begin_inset Quotes eld
\end_inset

free
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Since a substitution is precisely a list of terms sharing the same metavariable
 context 
\begin_inset Formula $\Gamma$
\end_inset

, a unification problem for two list of terms is equivalently given by a
 pair of parallel substitutions 
\begin_inset Formula $\xymatrix{\Gamma\coeqr{\sigma_{1}}{\sigma_{2}} & \Delta}
$
\end_inset

.
\end_layout

\begin_layout Lemma
The most general unifier of two lists of terms 
\begin_inset Formula $\Delta;n_{i}\vdash t_{i},u_{i}$
\end_inset

, if it exists, is characterised as the coequaliser of 
\begin_inset Formula $\vec{t}$
\end_inset

 as 
\begin_inset Formula $\vec{u}$
\end_inset

 as substitutions from 
\begin_inset Formula $(N_{1}:n_{1},\dots)$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:equaliser-notation"

\end_inset

This justifies a common interpretation as (co)equalisers of the two variants
 of the notation 
\begin_inset Formula $-\vdash-=-\Rightarrow-\dashv-$
\end_inset

 involved in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Pattern unification is often stated as the existence of a coequaliser on
 the condition that there is a unifier.
 It turns out that we can get rid of this condition by considering the category
 
\begin_inset Formula $\Th S$
\end_inset

 freely extended with a terminal object 
\begin_inset Formula $\bot$
\end_inset

, as we now explain.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Thus, a unification problem can be stated as a pair of parallel Kleisli
 morphisms 
\begin_inset Formula $\xymatrix{ya\coeqr{t}{u} & T\Gamma}
$
\end_inset

,
\end_layout

\begin_layout Plain Layout
corresponding (by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:free-alg-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and the Yoneda Lemma) to selecting a pair of elements in 
\begin_inset Formula $T\Gamma_{a}$
\end_inset

, or equivalently, a pair of terms 
\begin_inset Formula $\Gamma;a\vdash t,u$
\end_inset

.
 A unifier is nothing but a Kleisli morphism coequalising this pair.
 The property required by the most general unifier means that it is the
 coequaliser in the full subcategory spanned by objects of the shape 
\begin_inset Formula $\underline{\Gamma}$
\end_inset

, that we denote by 
\begin_inset Formula $\Th S$
\end_inset

, as it is (up to equivalence) the opposite category of a multi-sorted Lawvere
 theory.
 With this in mind, we can now interpret the notation 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 as a coequaliser.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it either takes place in 
\begin_inset Formula $\op{{\cal A}}$
\end_inset

 or in the category 
\begin_inset Formula $\Th S$
\end_inset

 freely extended with a terminal object 
\begin_inset Formula $\bot$
\end_inset

.
 This trick allows us to state pattern unification as a coequaliser even
 when there is no unifier, as we now explain.
 Thus, a unification problem can be stated as a pair of parallel Kleisli
 morphisms 
\begin_inset Formula $\xymatrix{ya\coeqr{t}{u} & T\Gamma}
$
\end_inset

,
\end_layout

\begin_layout Plain Layout
corresponding (by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:free-alg-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and the Yoneda Lemma) to selecting a pair of elements in 
\begin_inset Formula $T\Gamma_{a}$
\end_inset

, or equivalently, a pair of terms 
\begin_inset Formula $\Gamma;a\vdash t,u$
\end_inset

.
 A unifier is nothing but a Kleisli morphism coequalising this pair.
 The property required by the most general unifier means that it is the
 coequaliser in the full subcategory spanned by objects of the shape 
\begin_inset Formula $\underline{\Gamma}$
\end_inset

, that we denote by 
\begin_inset Formula $\Th S$
\end_inset

, as it is (up to equivalence) the opposite category of a multi-sorted Lawvere
 theory.
 With this in mind, we can now interpret the notation 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 as a coequaliser.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it either takes place in 
\begin_inset Formula $\op{{\cal A}}$
\end_inset

 or in the category 
\begin_inset Formula $\Th S$
\end_inset

 freely extended with a terminal object 
\begin_inset Formula $\bot$
\end_inset

.
 This trick allows us to state pattern unification as a coequaliser even
 when there is no unifier, as we now explain.
 
\end_layout

\end_inset


\end_layout

\begin_layout Definition
Given a category 
\begin_inset Formula $\mathscr{B}$
\end_inset

, let 
\begin_inset Formula $\catbot{\B}$
\end_inset

 denote the category 
\begin_inset Formula $\mathscr{B}$
\end_inset

 extended freely with a terminal object 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Notation
We denote by 
\begin_inset Formula $\bang$
\end_inset

 any terminal morphism to 
\begin_inset Formula $\bot$
\end_inset

 in 
\begin_inset Formula $\B_{\bot}$
\end_inset

.
\end_layout

\begin_layout Standard
Adding a terminal object results in adding a terminal cocone to all diagrams.
 As a consequence, we have the following lemma.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $J$
\end_inset

 be a diagram in a category 
\begin_inset Formula $\mathscr{B}$
\end_inset

.
 The following are equivalent:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $J$
\end_inset

 has a colimit as long as there exists a cocone;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $J$
\end_inset

 has a colimit in 
\begin_inset Formula $\catbot{\B}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Long Proof
Straightforward, because a colimit is defined as an initial cocone.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The following result is also useful.
\end_layout

\begin_layout Lemma
Given a category 
\begin_inset Formula $\mathscr{B}$
\end_inset

, the canonical embedding functor 
\begin_inset Formula $\mathscr{B}\rightarrow\catbot{\mathscr{B}}$
\end_inset

 creates colimits.
\end_layout

\begin_layout Standard
This ensures in particular that coproducts in 
\begin_inset Formula $\Th S$
\end_inset

, which are computed as union of metavariable contexts, are also coproducts
 in 
\begin_inset Formula $\Thbot S$
\end_inset

.
 
\end_layout

\begin_layout Standard
The main property of this extension for our purposes is the following corollary.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:completeness-algo"

\end_inset

Any coequaliser in 
\begin_inset Formula $\Th S$
\end_inset

 is also a coequaliser in 
\begin_inset Formula $\Thbot S$
\end_inset

.
 Moreover, whenever there is no unifier of two lists of terms, then the
 coequaliser of the corresponding parallel arrows in 
\begin_inset Formula $\Thbot S$
\end_inset

 exists: it is the terminal cocone on 
\begin_inset Formula $\bot$
\end_inset

.
\end_layout

\begin_layout Standard
Categorically speaking, our pattern unification algorithm provides an explicit
 proof of the following statement, where the conditions for a signature
 to be 
\emph on
pattern-friendly 
\emph default
are introduced in the next section (
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:pattern-friendly"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Theorem
Given any pattern-friendly signature 
\begin_inset Formula $S$
\end_inset

, the category 
\begin_inset Formula $\Thbot S$
\end_inset

 has coequalisers.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:res-monad"

\end_inset

 The main property that justifies unification of two metavariables as an
 equaliser or a pullback in 
\begin_inset Formula ${\cal A}$
\end_inset

 is that given any metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

, the functor 
\begin_inset Formula $T\Gamma:{\cal A}\rightarrow\Set$
\end_inset

 preserves them, i.e., 
\begin_inset Formula $T\Gamma\in\C$
\end_inset

.
 In fact, the argument works not only in the category of metavariable contexts
 and substitutions, but also in the (larger) category of objects of 
\begin_inset Formula $\C$
\end_inset

 and Kleisli morphisms between them.
 However, counter-examples can be found in the total Kleisli category.
 Consider indeed the unification problem 
\begin_inset Formula $M(x,y)=M(y,x)$
\end_inset

, in the example of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 We can define
\begin_inset Foot
status open

\begin_layout Plain Layout
Define 
\begin_inset Formula $P_{n}$
\end_inset

 as the set of two-elements sets of 
\begin_inset Formula $\{0,\dots,n-1\}$
\end_inset

.
\end_layout

\end_inset

 a functor 
\begin_inset Formula $P$
\end_inset

 that does not preserve finite connected colimits such that 
\begin_inset Formula $T(P)$
\end_inset

 is the syntax extended with a binary commutative metavariable 
\begin_inset Formula $M'(-,-)$
\end_inset

.
 Then, the most general unifier, computed in the total Kleisli category,
 replaces 
\begin_inset Formula $M$
\end_inset


\color red
 
\color inherit
with 
\begin_inset Formula $P$
\end_inset

.
 But in the Kleisli category restricted to coproducts of representable functors,
 or more generally, to objects of 
\begin_inset Formula $\C$
\end_inset

, the coequaliser replaces 
\begin_inset Formula $M$
\end_inset

 with a constant metavariable, as expected.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Initial Algebra Semantics for GB-signatures
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:GB-sig"

\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:GB-signature"

\end_inset

A 
\emph on
generalised binding signature
\emph default
, or 
\emph on
GB-signature, 
\emph default
is a tuple 
\begin_inset Formula $({\cal A},O,\ntharvecfunct)$
\end_inset

 consisting of
\end_layout

\begin_deeper
\begin_layout Itemize
a small category 
\begin_inset Formula ${\cal A}$
\end_inset

 of arities and renamings between them;
\end_layout

\begin_layout Itemize
a functor 
\begin_inset Formula $O_{-}(-):\mathbb{N}\times{\cal A}\rightarrow\Set$
\end_inset

 of operation symbols;
\end_layout

\begin_layout Itemize
a functor 
\begin_inset Formula $\alpha:\int J\rightarrow{\cal A}$
\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\int J$
\end_inset

 denotes the category of elements of 
\begin_inset Formula $J:\mathbb{N}\times{\cal A}\rightarrow\Set$
\end_inset

 mapping 
\begin_inset Formula $(n,a)$
\end_inset

 to 
\begin_inset Formula $\Oop na\times\{1,\dots.,n\}$
\end_inset

, defined as follows:
\end_layout

\begin_layout Itemize
objects are tuples 
\begin_inset Formula $(n,a,o,i)$
\end_inset

 such that 
\begin_inset Formula $o\in\Oop na$
\end_inset

 and 
\begin_inset Formula $i\in\{1,\dots,n\}$
\end_inset

;
\end_layout

\begin_layout Itemize
a morphism between 
\begin_inset Formula $(n,a,o,i)$
\end_inset

 and 
\begin_inset Formula $(n',a',o',i')$
\end_inset

 is a morphism 
\begin_inset Formula $f:a\rightarrow a'$
\end_inset

 such that 
\begin_inset Formula $n=n'$
\end_inset

, 
\begin_inset Formula $i=i'$
\end_inset

 and 
\begin_inset Formula $\rename of=o'$
\end_inset

 where 
\begin_inset Formula $o\{f\}$
\end_inset

 denotes the image of 
\begin_inset Formula $o$
\end_inset

 by the function 
\begin_inset Formula $O_{n}(f):O_{n}(a)\rightarrow O_{n}(a')$
\end_inset

.
 
\color red
introduce the reverse partial notation for the P-RIG rule ?
\end_layout

\end_deeper
\begin_layout Standard
We now introduce our conditions for the generic unification algorithm to
 be correct.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:pattern-friendly"

\end_inset

A GB-signature 
\begin_inset Formula $S=({\cal A},O,\ntharvecfunct)$
\end_inset

 is said 
\emph on
pattern-friendly 
\emph default
if 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits;
\end_layout

\begin_layout Enumerate
all morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 are monomorphic;
\end_layout

\begin_layout Enumerate
each 
\begin_inset Formula $O_{n}(-):{\cal A}\rightarrow\Set$
\end_inset

 preserves finite connected limits;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\alpha$
\end_inset

 preserves finite connected limits.
\end_layout

\end_deeper
\begin_layout Remark
The first condition is equivalent to the existence of equalisers and pullbacks
 in 
\begin_inset Formula ${\cal A}$
\end_inset

, since any finite connected limit can be constructed from those.
\end_layout

\begin_layout Standard
These conditions ensure the following two properties.
\end_layout

\begin_layout Property
\begin_inset CommandInset label
LatexCommand label
name "assu:main-properties"

\end_inset

The following properties hold.
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

label=(
\backslash
roman{enumi}), ref=
\backslash
theproperty.(
\backslash
roman{enumi})
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "assu:O-mono"

\end_inset

The action of 
\begin_inset Formula $O_{n}:{\cal A}\rightarrow\Set$
\end_inset

 on any renaming is an injection: given any 
\begin_inset Formula $o\in\Oop nb$
\end_inset

 and renaming 
\begin_inset Formula $f:a\rightarrow b$
\end_inset

, there is at most one 
\begin_inset Formula $o'\in\Oop na$
\end_inset

 such that 
\begin_inset Formula $o=\rename{o'}f$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "assu:L-finite-conncted"

\end_inset

Let 
\begin_inset Formula ${\cal L}$
\end_inset

 be the functor 
\begin_inset Formula $\op{{\cal A}}\xrightarrow{}\Th S$
\end_inset

 mapping a morphism 
\begin_inset Formula $x\in\hom_{{\cal A}}(b,a)$
\end_inset

 to the substitution 
\begin_inset Formula $(X:a)\rightarrow(X:b)$
\end_inset

 selecting (by the Yoneda Lemma) the term 
\begin_inset Formula $X(x)$
\end_inset

.
 Then, 
\begin_inset Formula ${\cal L}$
\end_inset

 preserves finite connected colimits: it maps pullbacks and equalisers in
 
\begin_inset Formula ${\cal A}$
\end_inset

 to pushouts and coequalisers in 
\begin_inset Formula $\Th S$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
(i) Since 
\begin_inset Formula $O_{n}$
\end_inset

 preserves finite connected limits, it preserves monomorphisms because a
 morphism 
\begin_inset Formula $f:a\rightarrow b$
\end_inset

 is monomorphic if and only if the following square is a pullback 
\begin_inset Note Note
status open

\begin_layout Plain Layout
the pullback of 
\begin_inset Formula $a\xrightarrow{f}b\xleftarrow{f}a$
\end_inset

 is the identity cone 
\begin_inset Formula $a\leftarrow a\rightarrow a$
\end_inset

 
\end_layout

\end_inset

(see 
\begin_inset CommandInset citation
LatexCommand cite
after "Exercise III.4.4"
key "MacLane:cwm"
literal "false"

\end_inset

).
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	A & A 
\backslash

\backslash
 	A & B 	
\backslash
arrow["f", from=1-2, to=2-2] 	
\backslash
arrow[equal, from=1-1, to=1-2] 	
\backslash
arrow["f"', from=2-1, to=2-2] 	
\backslash
arrow[Rightarrow, no head, from=1-1, to=2-1] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Proof
(ii) The proof is deferred to the end of this section.
\end_layout

\begin_layout Standard
The first property is used for soundness of the rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

.
 The second one is used to justify unification of two metavariables applications
 as pullbacks and equalisers in 
\begin_inset Formula ${\cal A}$
\end_inset

, in the rules 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:functor-L-intuition"

\end_inset

A metavariable application 
\begin_inset Formula $\Gamma;a\vdash M(x)$
\end_inset

 corresponds to the composition 
\begin_inset Formula ${\cal L}x[in_{M}]$
\end_inset

, where 
\begin_inset Formula $in_{M}$
\end_inset

 is the coproduct injection 
\begin_inset Formula $(X:m)\cong(M:m)\hookrightarrow\Gamma$
\end_inset

.
\end_layout

\begin_layout Standard
The rest of this section can be safely skipped at first reading: we provide
 Initial Algebra Semantics for the generated syntax that we exploit to prove
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Any GB-signature 
\begin_inset Formula $S=({\cal A},O,\ntharvecfunct)$
\end_inset

, generates an endofunctor 
\begin_inset Formula $F_{S}$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

, that we denote by just 
\begin_inset Formula $F$
\end_inset

 when the context is clear, defined by
\begin_inset Formula 
\[
F_{S}(X)_{a}=\coprod_{n\in\mathbb{N}}\coprod_{o\in\Oop na}X_{\nthar o1}\times\dots\times X_{\nthar on}.
\]

\end_inset


\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Formula $F$
\end_inset

 is finitary and generates a free monad 
\begin_inset Formula $T$
\end_inset

.
 Moreover, 
\begin_inset Formula $TX$
\end_inset

 is the initial algebra of 
\begin_inset Formula $Z\mapsto X+FZ$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Formula $F$
\end_inset

 is finitary because filtered colimits commute with finite limits 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem IX.2.1"
key "MacLane:cwm"
literal "false"

\end_inset

 and colimits.
 The free monad construction is due to 
\begin_inset CommandInset citation
LatexCommand cite
key "Reiterman"
literal "false"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:free-alg-syntax"

\end_inset

The syntax generated by a GB-signature (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:syntax-bsig"
plural "false"
caps "true"
noprefix "false"

\end_inset

) is recovered as free algebras for 
\begin_inset Formula $F$
\end_inset

.
 More precisely, given a metavariable context 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{p}:m_{p})$
\end_inset

, 
\begin_inset Formula 
\[
T(\underline{\Gamma})_{a}\cong\{t\ |\ \Gamma;a\vdash t\}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\underline{\Gamma}:{\cal A}\rightarrow\Set$
\end_inset

 is defined as the coproduct of representable functors 
\begin_inset Formula $\coprod_{i}ym_{i}$
\end_inset

, mapping 
\begin_inset Formula $a$
\end_inset

 to 
\begin_inset Formula $\coprod_{i}\hom_{{\cal A}}(m_{i},a)$
\end_inset

.
\end_layout

\begin_layout Notation
Given a metavariable context 
\begin_inset Formula $\Gamma$
\end_inset

.
 We sometimes denote 
\begin_inset Formula $\underline{\Gamma}$
\end_inset

 just by 
\begin_inset Formula $\Gamma$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},...,M_{p}:m_{p})$
\end_inset

 and 
\begin_inset Formula $\Delta$
\end_inset

 are metavariable contexts, a Kleisli morphism 
\begin_inset Formula $\sigma:\Gamma\rightarrow T\Delta$
\end_inset

 is equivalently given (by the Yoneda Lemma and the universal property of
 coproducts) by a metavariable substitution from 
\begin_inset Formula $\Gamma$
\end_inset

 to 
\begin_inset Formula $\Delta$
\end_inset

.
 Moreover, Kleisli composition corresponds to composition of substitutions.
 This provides a formal link between the category of metavariable contexts
 
\begin_inset Formula $\Th S$
\end_inset

 and the Kleisli category of 
\begin_inset Formula $T$
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:mcon-kleisli"

\end_inset

The category 
\begin_inset Formula $\Th S$
\end_inset

 is equivalent to the full subcategory of 
\begin_inset Formula $\Kl T$
\end_inset

 spanned by coproducts of representable functors.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
We will exploit this characterisation to prove various properties of this
 category when the signature is 
\emph on
pattern-friendly
\emph default
.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:res-F"

\end_inset

Given a GB-signature 
\begin_inset Formula $S=({\cal A},O,\ntharvecfunct)$
\end_inset

 such that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits, 
\begin_inset Formula $F_{S}$
\end_inset

 restricts as an endofunctor on the full subcategory 
\begin_inset Formula $\C$
\end_inset

 of 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 consisting of functors preserving finite connected limits if and only if
 the last two conditions of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:pattern-friendly"
plural "false"
caps "true"
noprefix "false"

\end_inset

 holds.
\end_layout

\begin_layout Proof
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "app:resF-direct"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
We now assume given a pattern-friendly signature 
\begin_inset Formula $S=({\cal A},O,\ntharvecfunct)$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:lims-coprod-pw"

\end_inset


\begin_inset Formula $\C$
\end_inset

 is closed under limits, coproducts, and filtered colimits.
 Moreover, it is cocomplete.
\end_layout

\begin_layout Proof
Cocompleteness follows from 
\begin_inset CommandInset citation
LatexCommand cite
after "Remark 1.56"
key "Adamek"
literal "false"

\end_inset

, since 
\begin_inset Formula $\C$
\end_inset

 is the category of models of a limit sketch, and is thus locally presentable,
 by
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Proposition 1.51"
key "Adamek"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the claimed closure property, all we have to check is that limits, coproduct
s, and filtered colimits of functors preserving finite connected limits
 still preserve finite connected limits.
 The case of limits is clear, since limits commute with limits.
 Coproducts and filtered colimits also commute with finite connected limits
 
\begin_inset CommandInset citation
LatexCommand cite
after "Example 1.3.(vi)"
key "classificationaccessible"
literal "false"

\end_inset

.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:-T-res"

\end_inset


\begin_inset Formula $T$
\end_inset

 restricts as a monad on 
\begin_inset Formula $\C$
\end_inset

 freely generated by the restriction of 
\begin_inset Formula $F$
\end_inset

 as an endofunctor on 
\begin_inset Formula $\C$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:res-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Proof
The result follows from the construction of 
\begin_inset Formula $T$
\end_inset

 using colimits of initial chains, thanks to the closure properties of 
\begin_inset Formula $\C$
\end_inset

.
 More specifically, 
\begin_inset Formula $TX$
\end_inset

 can be constructed as the colimit of the chain 
\begin_inset Formula $\emptyset\rightarrow H\emptyset\rightarrow HH\emptyset\rightarrow\dots$
\end_inset

, where 
\begin_inset Formula $\emptyset$
\end_inset

 denotes the constant functor mapping anything to the empty set, and 
\begin_inset Formula $HZ=FZ+X$
\end_inset

.
\end_layout

\begin_layout Standard
We now turn to the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
By right continuity of the homset bifunctor, any representable functor is
 in 
\begin_inset Formula $\C$
\end_inset

 and thus the embedding 
\begin_inset Formula $\C\rightarrow[\mathcal{A},\Set]$
\end_inset

 factors the Yoneda embedding 
\begin_inset Formula $\op{\mathcal{A}}\rightarrow[\mathcal{A},\Set]$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:K-finite-connected"

\end_inset

Let 
\begin_inset Formula $\D$
\end_inset

 denote the opposite category of 
\begin_inset Formula ${\cal A}$
\end_inset

 and 
\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 the factorisation of 
\begin_inset Formula $\C\rightarrow[{\cal A},\Set]$
\end_inset

 by the Yoneda embedding.
 Then, 
\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 preserves finite connected colimits.
\end_layout

\begin_layout Proof
This essentially follows from the fact functors in 
\begin_inset Formula $\C$
\end_inset

 preserves finite connected limits.
 Let us detail the argument: let 
\begin_inset Formula $y:\op{\mathcal{A}}\rightarrow[\mathcal{A},\Set]$
\end_inset

 denote the Yoneda embedding and 
\begin_inset Formula $J:\C\rightarrow[\mathcal{A},\Set]$
\end_inset

 denote the canonical embedding, so that 
\begin_inset Formula 
\begin{equation}
y=J\circ K.\label{eq:def-y-1}
\end{equation}

\end_inset

Now consider a finite connected limit 
\begin_inset Formula $\lim F$
\end_inset

 in 
\begin_inset Formula $\mathcal{A}$
\end_inset

.
 Then, 
\begin_inset Formula 
\begin{align*}
\C(K\lim F,X) & \cong[{\cal A},\Set](JK\lim F,JX)\tag{\ensuremath{J} is fully faithful}\\
 & \cong[\mathcal{A},\Set](y\lim F,JX)\tag{By Equation \prettyref{eq:def-y-1}}\\
 & \cong JX(\lim F)\tag{By the Yoneda Lemma.}\\
 & \cong\lim(JX\circ F)\tag{\ensuremath{X} preserves finite connected limits}\\
 & \cong\lim([\mathcal{A},\Set](yF-,JX)]\tag{By the Yoneda Lemma}\\
 & \cong\lim([\mathcal{A},\Set](JKF-,JX)]\tag{By Equation \prettyref{eq:def-y-1}}\\
 & \cong\lim\C(KF-,X)\tag{\ensuremath{J} is full and faithful}\\
 & \cong\C(\colim KF,X)\tag{By left continuity of the hom-set bifunctor}
\end{align*}

\end_inset

These isomorphisms are natural in 
\begin_inset Formula $X$
\end_inset

 and thus 
\begin_inset Formula $K\lim F\cong\colim KF$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Unification of two metavariables as pullbacks or equalisers in 
\begin_inset Formula ${\cal A}$
\end_inset

 crucially relies on 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

, which holds because we restrict to functors preserving finite connected
 limits.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As anticipated in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:res-monad"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is crucial to consider the monad 
\begin_inset Formula $T$
\end_inset

 restricted to 
\begin_inset Formula $\C$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout

[Proof of 
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

 Let 
\begin_inset Formula $T_{|\C}$
\end_inset

 be the monad 
\begin_inset Formula $T$
\end_inset

 restricted to 
\begin_inset Formula $\C$
\end_inset

, following 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:-T-res"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Since 
\begin_inset Formula $K:\D\rightarrow\C$
\end_inset

 preserves finite connected colimits (
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

), composing it with the left adjoint 
\begin_inset Formula $\C\rightarrow\Kl{T_{|\C}}$
\end_inset

 yields a functor 
\begin_inset Formula $\D\rightarrow\Kl{T_{|\C}}$
\end_inset

 also preserving those colimits.
 Since it factors as 
\begin_inset Formula $\D\xrightarrow{{\cal L}}\Th S\hookrightarrow\Kl{T_{|\C}}$
\end_inset

, where the right functor is full and faithful, 
\begin_inset Formula ${\cal L}$
\end_inset

 also preserves finite connected colimits.
\end_layout

\begin_layout Section
Soundness of the unification phase
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:coequalising-phase"

\end_inset


\end_layout

\begin_layout Standard
In this section, we assume a pattern-friendly GB-signature 
\begin_inset Formula $S$
\end_inset

 and discuss soundness of the main rules of the main unification phase in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, which computes a coequaliser in 
\begin_inset Formula $\Thbot S$
\end_inset

.
 More specifically, we discuss the rule sequential rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:usplit"
plural "false"
caps "true"
noprefix "false"

\end_inset

), the rule 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

 unifying metavariable with itself (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-flex-same-metavar"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and the failing rule 
\begin_inset Formula $\refrule{U-Cyclic}$
\end_inset

 for cyclic unification of a metavariable with a term which includes it
 deeply (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:flex-rig-cyclic"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Sequential unification (rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:usplit"

\end_inset

The rule 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 follows from a stepwise construction of coequalisers valid in any category,
 as noted by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite[Theorem 9]{DBLP:books/daglib/0068768}
\end_layout

\end_inset

: if the first two diagrams below are coequalisers, then the last one as
 well.
\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/coeq-pointwise.json
\end_layout

\end_inset


\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsOCxbMCwxLCJBXzEiXSxbMSwxLCJcXEdhbW1hIl0sWzIsMSwiXFxEZ
Wx0YV8xIl0sWzMsMSwiQV8yIl0sWzQsMCwiXFxHYW1tYSJdLFs1LDEsIlxcRGVsdGFfMSJdLFs0LDIsI
lxcR2FtbWEiXSxbNiwxLCJcXERlbHRhXzIiXSxbMCwxLCJ0XzEiLDAseyJjdXJ2ZSI6LTF9XSxbMCwxL
CJ1XzEiLDIseyJjdXJ2ZSI6MX1dLFsxLDIsIlxcc2lnbWFfMSIsMCx7InN0eWxlIjp7ImJvZHkiOnsib
mFtZSI6ImRhc2hlZCJ9fX1dLFszLDQsInRfMiJdLFs0LDUsIlxcc2lnbWFfMSJdLFszLDYsInVfMiIsM
l0sWzYsNSwiXFxzaWdtYV8xIiwyXSxbNSw3LCJcXHNpZ21hXzIiLDAseyJzdHlsZSI6eyJib2R5Ijp7I
m5hbWUiOiJkYXNoZWQifX19XV0=
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}[row sep=tiny]
\end_layout

\begin_layout Plain Layout

	&&&&[-20pt] 
\backslash
Gamma 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	{A_1} & 
\backslash
Gamma & {
\backslash
Delta_1} & {A_2} &&[-20pt] {
\backslash
Delta_1} & {
\backslash
Delta_2} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	&&&&[-10pt] 
\backslash
Gamma
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_1}", curve={height=-6pt}, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_1}"', curve={height=6pt}, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}", dashed, from=2-2, to=2-3]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{t_2}", from=2-4, to=1-5]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}", from=1-5, to=2-6]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{u_2}"', from=2-4, to=3-5]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_1}"', from=3-5, to=2-6]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma_2}", dashed, from=2-6, to=2-7]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\xymatrix{A_{1}+A_{2}\coeqr{t_{1},t_{2}}{u_{1},u_{2}} & \Gamma\ar@{-->}[r]^{\sigma_{2}\circ\sigma_{1}} & \Delta_{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Lemma
\begin_inset Formula 
\[
\xymatrix{A_{1}+A_{2}\coeqr{t_{1},t_{2}}{u_{1},u_{2}} & \Gamma\ar@{-->}[r]^{\sigma_{2}\circ\sigma_{1}} & \Delta_{2}}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

[Theorem 9, 
\backslash
cite{DBLP:books/daglib/0068768}]
\end_layout

\end_inset

In any category, denoting morphism  composition 
\begin_inset Formula $f\circ g$
\end_inset

 by 
\begin_inset Formula $g[f]$
\end_inset

, the following rule applies.
\begin_inset Formula 
\[
\unificationstepwise{}
\]

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsMyxbMCwwLCJBXzErQV8yIl0sWzEsMCwiQiJdLFsyLDAsIkQiXSxbM
CwxLCJmXzEsZl8yIiwwLHsiY3VydmUiOi0yfV0sWzAsMSwiZl8xJyxmXzInIiwyLHsiY3VydmUiOjJ9X
SxbMSwyLCJ2XFxjaXJjIHUiXV0=
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd} 	{A_1+A_2} & 
\backslash
Gamma & 
\backslash
Delta_2 	
\backslash
arrow["{t_1,t_2}"above, curve={height=-12pt}, from=1-1, to=1-2] 	
\backslash
arrow["{u_1,u_2}"', curve={height=12pt}, from=1-1, to=1-2] 	
\backslash
arrow["{
\backslash
sigma_2
\backslash
circ 
\backslash
sigma_1}", from=1-2, to=1-3, dashed] 
\backslash
end{tikzcd}
\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
We therefore get the rule
\begin_inset Formula 
\[
\unificationrigrig
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Flex-Flex, same metavariable (rule 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:flex-flex-same-metavar"

\end_inset

Here we detail unification of 
\begin_inset Formula $M(x)$
\end_inset

 and 
\begin_inset Formula $M(y)$
\end_inset

, for 
\begin_inset Formula $x,y\in\hom_{{\cal A}}(m,a)$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:functor-L-intuition"
plural "false"
caps "true"
noprefix "false"

\end_inset

, 
\begin_inset Formula $M(\arg x)={\cal L}\arg x[in_{M}]$
\end_inset

 and 
\begin_inset Formula $M(\arg y)={\cal L}\arg y[in_{M}]$
\end_inset

.
 We exploit the following lemma with 
\begin_inset Formula $u={\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula $v={\cal L}\arg y$
\end_inset

.
\end_layout

\begin_layout Lemma
In any category, denoting morphism composition 
\begin_inset Formula $g\circ f$
\end_inset

 by 
\begin_inset Formula $f[g]$
\end_inset

, the following rule applies:
\begin_inset Formula 
\[
\dfrac{B\vdash u=v\Rightarrow h\dashv C}{B+D\dashv u[in_{B}]=v[in_{B}]\Rightarrow h+1_{D}\dashv C+D}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\end_inset

In other words, if the below left diagram is a coequaliser, then so is the
 below right diagram.
 
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
[
\end_layout

\begin_layout Plain Layout


\backslash
xymatrix@R=2pt{A
\backslash
ar@<+.5ex>[r]^{u}
\backslash
ar@<-.5ex>[r]_{v} & B
\backslash
ar@{-->}[r]^{h} & C}
\backslash
quad
\backslash
begin{array}{c}
\backslash
xymatrix@C=1.5em@R=2pt{ & B
\backslash
ar[rd]^{in_{B}}
\backslash

\backslash
A
\backslash
ar[ru]^{u}
\backslash
ar[rd]_{v} &  & B+D
\backslash
ar@{-->}[r]^{h+1_{D}} & C+D
\backslash

\backslash
 & B
\backslash
ar[ru]_{in_{B}}}
\backslash
end{array}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\xymatrix{A\ar@<+.5ex>[r]^{u}\ar@<-.5ex>[r]_{v} & B\ar@{-->}[r]^{h} & C}
\qquad\begin{array}{c}
\xymatrix{ & B\ar[rd]^{in_{B}}\\
A\ar[ru]^{u}\ar[rd]_{v} &  & B+D\ar@{-->}[r]^{h+1_{D}} & C+D\\
 & B\ar[ru]_{in_{B}}
}
\end{array}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It follows that it is enough to compute the coequaliser of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

.
 Furthermore, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is the image by 
\begin_inset Formula ${\cal L}$
\end_inset

 of the equaliser of 
\begin_inset Formula $\arg x$
\end_inset

 and 
\begin_inset Formula $\arg y$
\end_inset

, thus justifying the rule 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

.
\end_layout

\begin_layout Subsection
Flex-rigid, cyclic (rule 
\begin_inset Formula $\refrule{U-Cyclic}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:flex-rig-cyclic"

\end_inset

The rule 
\begin_inset Formula $\refrule{U-Cyclic}$
\end_inset

 handles unification of 
\begin_inset Formula $M(\arg x)$
\end_inset

 and a term 
\begin_inset Formula $u$
\end_inset

 such that 
\begin_inset Formula $u$
\end_inset

 is rigid and 
\begin_inset Formula $M$
\end_inset

 occurs in 
\begin_inset Formula $u$
\end_inset

.
 In this section, we show that indeed there is no unifier.
 More precisely, we prove 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:occurcheck-final"
plural "false"
caps "true"
noprefix "false"

\end_inset

 below, stating that if there is a unifier of a term 
\begin_inset Formula $u$
\end_inset

 and a metavariable application 
\begin_inset Formula $M(x)$
\end_inset

, then either 
\begin_inset Formula $M$
\end_inset

 occurs at top-level in 
\begin_inset Formula $u$
\end_inset

, or it does not occur at all.
 The argument follows the basic intuition that 
\begin_inset Formula $\sigma_{M}=u[M\mapsto\sigma_{M}]$
\end_inset

 is impossible if 
\begin_inset Formula $M$
\end_inset

 occurs deeply in 
\begin_inset Formula $u$
\end_inset

 because the sizes of both hand sides can never match.
 To make this statement precise, we need some recursive definitions and
 properties of size.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:size-occur-check"

\end_inset

The size
\begin_inset Foot
status open

\begin_layout Plain Layout
The difference with the notion of size introduced in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:progress"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is that metavariables are of size 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Formula $|t|\in\mathbb{N}$
\end_inset

 of a term 
\begin_inset Formula $t$
\end_inset

 is recursively defined by 
\begin_inset Formula $|M(\arg x)|=0$
\end_inset

 and 
\begin_inset Formula $|o(\vec{t})|=1+|\vec{t}|$
\end_inset

, with 
\begin_inset Formula $|\vec{t}|=\sum_{i}t_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
We will also need to count the occurrences of a metavariables in a term.
\end_layout

\begin_layout Definition
For any term 
\begin_inset Formula $t$
\end_inset

 we define 
\begin_inset Formula $|t|_{M}$
\end_inset

 recursively by 
\begin_inset Formula $|M(\arg x)|_{M}=1$
\end_inset

, 
\begin_inset Formula $|N(\arg x)|_{M}=0$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 if 
\begin_inset Formula $N\neq M$
\end_inset

, and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $|o(\vec{t})|_{M}=|\vec{t}|_{M}$
\end_inset

 with the sum convention as above for 
\begin_inset Formula $|\vec{t}|_{M}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:sizeM-factor"

\end_inset

For any term 
\begin_inset Formula $\text{\ensuremath{\Gamma,M:m;a\vdash}}t$
\end_inset

, if 
\begin_inset Formula $|t|_{M}=0$
\end_inset

, then 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

.
 Moreover, for any 
\begin_inset Formula $\Gamma=(M_{1}:m_{1},\dots,M_{n}:m_{n})$
\end_inset

, well-formed term 
\begin_inset Formula $t$
\end_inset

 in context 
\begin_inset Formula $\Gamma;a$
\end_inset

, and substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma]|=|t|+\sum_{i}|t|_{M_{i}}\times|\sigma_{i}|$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:size-consequences"

\end_inset

For any term 
\begin_inset Formula $t$
\end_inset

 in context 
\begin_inset Formula $\Gamma,M:m;a$
\end_inset

, substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

, morphism 
\begin_inset Formula $x\in\hom_{{\cal A}}(m,a)$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 in context 
\begin_inset Formula $\Delta;u$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma,M\mapsto u]|\geq|t|+|u|\times|t|_{M}$
\end_inset

 and 
\begin_inset Formula $|M(x)[u]|=|u|$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:occurcheck-final"

\end_inset

Let 
\begin_inset Formula $t$
\end_inset

 be a term in context 
\begin_inset Formula $\Gamma,M:m;a$
\end_inset

 and 
\begin_inset Formula $x\in\hom_{{\cal A}}(m,a)$
\end_inset

 such that 
\begin_inset Formula $(\sigma,M\mapsto u):(\Gamma,M:m)\rightarrow\Delta$
\end_inset

 unifies 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $M(x)$
\end_inset

.
 Then, either 
\begin_inset Formula $t=M(y)$
\end_inset

 for some 
\begin_inset Formula $y\in\hom_{{\cal A}}(m,a)$
\end_inset

, or 
\begin_inset Formula $\Gamma;a\vdash t$
\end_inset

.
 
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $t[\sigma,u]=M(x)[u]$
\end_inset

, we have 
\begin_inset Formula $|t[\sigma,u]|=|M(x)[u]|$
\end_inset

.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:size-consequences"
plural "false"
caps "true"
noprefix "false"

\end_inset

 implies 
\begin_inset Formula $|u|\geq|t|+|u|\times|t|_{M}$
\end_inset

.
 Therefore, either 
\begin_inset Formula $|t|_{M}=0$
\end_inset

 and we conclude by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:sizeM-factor"
plural "false"
caps "true"
noprefix "false"

\end_inset

, or 
\begin_inset Formula $|t|_{M}>0$
\end_inset

 and 
\begin_inset Formula $|t|=0$
\end_inset

, so that 
\begin_inset Formula $t$
\end_inset

 is 
\begin_inset Formula $M(\arg y)$
\end_inset

 for some 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Section
Soundness of the non-cyclic phase
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:pruning-phase"

\end_inset

In this section, we assume a pattern-friendly GB-signature 
\begin_inset Formula $S$
\end_inset

 and prove soundness of the main rule of the non-cyclic phase.
 This phase handles unification of a list of terms 
\begin_inset Formula $\Gamma;n_{i}\vdash t_{i}$
\end_inset

 with a list of fresh metavariable applications 
\begin_inset Formula $M_{1}(x_{1}),\dots,M_{p}(x_{p})$
\end_inset

, in the extended metavariable context 
\begin_inset Formula $\Gamma,M_{1}:m_{1},\dots,M_{p}:x_{p}$
\end_inset

.
 Categorically speaking, we are looking at the following coequalising diagram
 in 
\begin_inset Formula $\Th S$
\end_inset

.
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% pushout-coeq.json
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}[row sep=-4pt, column sep=+4em]
\end_layout

\begin_layout Plain Layout

 & 
\backslash
Gamma 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 {
\backslash
overrightarrow{N:n}} && {
\backslash
Gamma,
\backslash
overrightarrow{{M}:{m}}} 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 & 
\backslash
overrightarrow{M:m}
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["
\backslash
overrightarrow{M(x)}"' {xshift=8pt,yshift=-2pt}, from=2-1, to=3-2]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["
\backslash
vec{t}", from=2-1, to=1-2]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["{in_1}" {xshift=-4pt}, from=1-2, to=2-3]
\end_layout

\begin_layout Plain Layout

 
\backslash
arrow["{in_2}"' {xshift=-4pt}, from=3-2, to=2-3]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\backslash
]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\refrule{P-Split}$
\end_inset

 rule is a straightforward adaption of the 
\begin_inset Formula $\refrule{U-Split}$
\end_inset

 rule specialised to those specific coequaliser diagrams.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:cocone-pruning"

\end_inset

A unifier 
\begin_inset Formula $\Gamma,\overrightarrow{M:m}\rightarrow\Delta$
\end_inset

 splits into two components: a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 and a substitution 
\begin_inset Formula $\vec{u}$
\end_inset

 from 
\begin_inset Formula $\overrightarrow{N:n}$
\end_inset

 to 
\begin_inset Formula $\overrightarrow{M:m}$
\end_inset

 such that 
\begin_inset Formula $t_{i}[\sigma]=\rename{u_{i}}{x_{i}}$
\end_inset

 for each 
\begin_inset Formula $i\in\{1,\dots,p\}$
\end_inset

.
 Moreover, the coequaliser 
\begin_inset Formula $\sigma,\vec{u}:(\Gamma,\overrightarrow{M:m})\rightarrow\Delta$
\end_inset

 is equivalently characterised as a pushout
\begin_inset Formula 
\[
\xymatrix{\overrightarrow{N:n}\ar[r]^{\overrightarrow{M(x)}}\ar[d]_{\vec{t}} & \overrightarrow{M:m}\ar[d]^{\vec{u}}\\
\Gamma\ar[r]_{\sigma} & \Delta
}
\]

\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "rem:pushout-notation"

\end_inset

This justifies a common interpretation as pushouts of the two variants of
 the notation 
\begin_inset Formula $-\prunecat ----{}$
\end_inset

 involved in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:generic-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, in 
\begin_inset Formula $\op{{\cal A}}$
\end_inset

 and 
\begin_inset Formula $\Th S$
\end_inset

.
\end_layout

\begin_layout Standard
In the following sections, we detail soundness of the rules for the rigid
 case (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:case-KA-RiTC"
plural "false"
caps "true"
noprefix "false"

\end_inset

) and then for the flex case (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:pruning-metavar"
plural "false"
caps "true"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection
Rigid (rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:case-KA-RiTC"

\end_inset


\end_layout

\begin_layout Personal Question
Maybe it would be clearer to use the epimorphic properties of coequalisers
 exposed in 
\begin_inset CommandInset citation
LatexCommand cite
after "Chapter 9"
key "DBLP:books/daglib/0068768"
literal "false"

\end_inset

?
\end_layout

\begin_layout Standard
The rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 handle non-cyclic unification of 
\begin_inset Formula $M(x)$
\end_inset

 with 
\begin_inset Formula $\Gamma;a\vdash o(\vec{t})$
\end_inset

 in the metavariable context 
\begin_inset Formula $\Gamma,M:m$
\end_inset

 for some 
\begin_inset Formula $o\in\Oop na$
\end_inset

.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:cocone-pruning"
plural "false"
caps "true"
noprefix "false"

\end_inset

, a unifier is given by a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 and a term 
\begin_inset Formula $u$
\end_inset

 such that 
\begin_inset Formula 
\begin{equation}
o(\vec{t}[\sigma])=\rename ux.\label{eq:unif-prig}
\end{equation}

\end_inset

Now, 
\begin_inset Formula $u$
\end_inset

 is either some 
\begin_inset Formula $M(\arg y)$
\end_inset

 or 
\begin_inset Formula $o'(\vec{v})$
\end_inset

.
 But in the first case, 
\begin_inset Formula $\rename ux=\rename{M(y)}x=M(\arg x\circ\arg y)$
\end_inset

, contradicting 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:unif-prig"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 Therefore, 
\begin_inset Formula $u=o'(\vec{v})$
\end_inset

 for some 
\begin_inset Formula $o'\in\Oop nm$
\end_inset

 and 
\begin_inset Formula $\vec{v}=(v_{1},\dots,v_{n})$
\end_inset

 is a list of terms such that 
\begin_inset Formula $\Delta;\nthar{o'}i\vdash v_{i}$
\end_inset

.
 Then, 
\begin_inset Formula $\rename ux=(\rename{o'}x)(\rename{v_{1}}{\ntharvecaction{o'}x1},\dots,)$
\end_inset

.
 It follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:unif-prig"
plural "false"
caps "true"
noprefix "false"

\end_inset

 that 
\begin_inset Formula $o=\rename{o'}x$
\end_inset

, and 
\begin_inset Formula $t_{i}[\sigma]=\rename{v_{i}}{\ntharvecaction{o'}xi}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We introduce some notation for the latter condition.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Notation
Given 
\begin_inset Formula $f\in\hom_{\D}(a,b)$
\end_inset

 and 
\begin_inset Formula $o\in Ka\rightarrow O$
\end_inset

, we write 
\begin_inset Formula $o_{|f}\Rightarrow\bang$
\end_inset

 to mean that 
\begin_inset Formula $Kf$
\end_inset

 does not factor 
\begin_inset Formula $o$
\end_inset

.
 Otherwise, if 
\begin_inset Formula $o=o'\circ Kf$
\end_inset

, then we write 
\begin_inset Formula $o_{|f}\Rightarrow\underline{o'}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Remark
Note that if there were more than one possible 
\begin_inset Formula $o'$
\end_inset

, then the most general unifier would not exist.
 But such a 
\begin_inset Formula $o'$
\end_inset

, if it exists, is unique because 
\begin_inset Formula $K\arg x$
\end_inset

 is epimorphic, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:epis"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In fact, this is the only place where we use this property.
 As a consequence, we could weaken the condition that morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 are monomorphic and require instead that the image of such a morphism by
 
\begin_inset Formula $O$
\end_inset

 is monomorphic.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{
\end_layout

\end_inset

Note that there is at most one 
\begin_inset Formula $o'$
\end_inset

 such that 
\begin_inset Formula $o=\rename{o'}x$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:O-mono"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 In this case,
\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset

In case 
\begin_inset Formula $o=\acton{\arg x}{o'}$
\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 a unifier is equivalently given by a substitution 
\begin_inset Formula $\sigma:\Gamma\rightarrow\Delta$
\end_inset

 and a list of terms 
\begin_inset Formula $\vec{v}=(v_{1},\dots,v_{n})$
\end_inset

 such that 
\begin_inset Formula $\Delta;\nthar{o'}i\vdash v_{i}$
\end_inset

 and 
\begin_inset Formula $t_{i}[\sigma]=\rename{v_{i}}{\ntharvecaction{o'}xi}$
\end_inset

.
 But, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:cocone-pruning"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this is precisely the data for a unifier of 
\begin_inset Formula $\vec{t}$
\end_inset

 and 
\begin_inset Formula $M_{1}(x_{i}^{o'}),\dots,M_{n}(x_{n}^{o'})$
\end_inset

.
 This actually induces an isomorphism between the two categories of unifiers,
 thus justifying the rules 
\begin_inset Formula $\refrule{P-Rig}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Flex (rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:pruning-metavar"

\end_inset


\end_layout

\begin_layout Standard
The rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 handles unification of 
\begin_inset Formula $\Gamma,N:n;a\vdash N(x)$
\end_inset

 and 
\begin_inset Formula $M(y)$
\end_inset

 where 
\begin_inset Formula $M$
\end_inset

 is fresh in 
\begin_inset Formula $\Gamma,N:n$
\end_inset

.
 
\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $M(y)$
\end_inset

, as a substitution 
\begin_inset Formula $(A:a)\rightarrow(M:m)$
\end_inset

, is isomorphic to 
\begin_inset Formula ${\cal L}y$
\end_inset

, while 
\begin_inset Formula $N(\arg x)={\cal L}\arg x[in_{N}]$
\end_inset

, by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:functor-L-intuition"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Thanks to the following lemma, it is actually enough to compute the pushout
 of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset Note Note
status open

\begin_layout Plain Layout
% YADE DIAGRAM diagrams/pushout-in.json
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
In any category, denoting morphism composition by 
\begin_inset Formula $f\circ g=g[f]$
\end_inset

, the following rule applies
\begin_inset Formula 
\[
\dfrac{X\prune gf{\sigma}u\dashv Z}{X+Y\prune{g[in_{1}]}f{\sigma+Y}{u[in_{1}]}\dashv Z+Y}
\]

\end_inset


\end_layout

\begin_layout Lemma
In other words, if the diagram below left is a pushout, then so is the right
 one.
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJBIl0sWzAsMSwiWCJdLFsxLDAsIkIiXSxbMSwxLCJaI
l0sWzAsMSwiZyIsMl0sWzAsMiwiZiJdLFsxLDMsIlxcc2lnbWEiLDIseyJzdHlsZSI6eyJib2R5Ijp7I
m5hbWUiOiJkYXNoZWQifX19XSxbMiwzLCJ1IiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFza
GVkIn19fV1d
\end_layout

\begin_layout Plain Layout


\backslash
[
\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	A & B 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	X & Z
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["g"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["f", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["
\backslash
sigma"', dashed, from=2-1, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["u", dashed, from=1-2, to=2-2]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
qquad
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzcd}
\end_layout

\begin_layout Plain Layout

	A & B 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	X & Z 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	{X+Y} & {Z+Y}
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["g"', from=1-1, to=2-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["f", from=1-1, to=1-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{in_1}"', from=2-1, to=3-1]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{
\backslash
sigma+Y}"', dashed, from=3-1, to=3-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["u", dashed, from=1-2, to=2-2]
\end_layout

\begin_layout Plain Layout

	
\backslash
arrow["{in_1}", dashed, from=2-2, to=3-2]
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzcd}
\end_layout

\begin_layout Plain Layout


\backslash
]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "assu:L-finite-conncted"
plural "false"
caps "true"
noprefix "false"

\end_inset

, the pushout of 
\begin_inset Formula ${\cal L}\arg x$
\end_inset

 and 
\begin_inset Formula ${\cal L}\arg y$
\end_inset

 is the image by 
\begin_inset Formula ${\cal L}$
\end_inset

 of the pullback of 
\begin_inset Formula $\arg x$
\end_inset

 and 
\begin_inset Formula $\arg y$
\end_inset

 in 
\begin_inset Formula ${\cal A}$
\end_inset

, thus justifying the rule 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

.
\end_layout

\begin_layout Section
Completeness
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:completeness"

\end_inset


\end_layout

\begin_layout Standard
In this section, we explain why soundness (
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:pruning-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:coequalising-phase"
plural "false"
caps "true"
noprefix "false"

\end_inset

) and termination (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:progress"
plural "false"
caps "true"
noprefix "false"

\end_inset

) entail completeness.
 Intuitively, one may worry that the algorithm fails in cases where it should
 not.
 In fact, soundness already ensures that this cannot happen because failure
 is really handled as a coequaliser, on par with most general unifiers.
 As explained in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:categorification"
plural "false"
caps "true"
noprefix "false"

\end_inset

, this is done by considering the category 
\begin_inset Formula $\Thbot S$
\end_inset

 extending category 
\begin_inset Formula $\Th S$
\end_inset

 with a (dignified) error object 
\begin_inset Formula $\bot$
\end_inset

.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:completeness-algo"
plural "false"
caps "true"
noprefix "false"

\end_inset

 implies that since the algorithm terminates and computes the coequaliser
 in 
\begin_inset Formula $\Thbot S$
\end_inset

, it always finds the most general unifier in 
\begin_inset Formula $\Th S$
\end_inset

 if it exists, and otherwise returns failure (i.e., the map to the terminal
 object 
\begin_inset Formula $\bot$
\end_inset

).
 
\end_layout

\begin_layout Section
Applications
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:applications"

\end_inset

In this section, we present various examples of pattern-friendly signatures.
 We start in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ex-arg-sets"
plural "false"
caps "true"
noprefix "false"

\end_inset

 with a variant of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus where metavariable arguments are sets rather than lists.
 Then, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

, we present simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus, as an example of syntax specified by a multi-sorted binding signature.
 Next, we introduce an example of unification for ordered syntax in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ordered-calculus"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and finally we present an example of polymorphic such as System F, in
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In the examples, we motivate the definition of the category 
\begin_inset Formula ${\cal A}$
\end_inset

 based on what we expect from metavariable arities, following 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:ar-A"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
fullshort{
\end_layout

\end_inset

We also adopt 
\begin_inset CommandInset ref
LatexCommand formatted
reference "rem:shape-examples"
plural "false"
caps "false"
noprefix "false"

\end_inset

 , where the endofunctor 
\begin_inset Formula $F$
\end_inset

 is defined as
\begin_inset Formula 
\[
F(X)_{a}\cong\coprod_{\ell\in V}\coprod_{o\in O_{\ell}}\prod_{j\in\gamma_{\ell}}X_{H_{\ell,j}(a,o)}
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\backslash
rqshape}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection
Binding signatures
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "subsec:bidning-sig"

\end_inset

As a first step, let us parameterise the unification algorithm by a binding
 signature 
\begin_inset CommandInset citation
LatexCommand cite
key "BindingSignatures"
literal "false"

\end_inset

.
 A syntax is then specified by a set of symbols 
\begin_inset Formula $O$
\end_inset

 together with a list of natural numbers 
\begin_inset Formula $\vec{\alpha}_{o}$
\end_inset

 for each 
\begin_inset Formula $o\in O$
\end_inset

 specifying the number of arguments (the size of the list) and the number
 of bound variables in each argument.
 For example, pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus is specified by 
\begin_inset Formula $O=\{app,lam\}$
\end_inset

 with 
\begin_inset Formula $\vec{\alpha}_{app}=(0,0)$
\end_inset

 and 
\begin_inset Formula $\vec{\alpha}_{lam}=(1)$
\end_inset

.
 The unification algorithm described in the previous section straightforwardly
 generalises to any syntax specified by a binding signature.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises the generic algorithm that we will later interpret in a more
 general setting, where metavariable arguments are morphisms in a category.
 Since nothing enforces them to be lists
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ex-arg-sets"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
shortfull{
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Section 8.2"
key "longgenericunif"
literal "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ex-arg-sets"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

 for an example where arguments are sets.
\end_layout

\end_inset

, the vector notation is dropped for these arguments in the figure, but
 we still use it in the following specialisation to syntax specified by
 a binding signature.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises the generic algorithm that we will later interpret in a more
 broader setting.
 In this general setting, metavariable arguments are morphisms in a category:
 nothing enforces them to be lists.
\end_layout

\begin_layout Plain Layout
In the figure, the vector notation for the arguments of metavariables is
 dropped because in the general setting we consider in this paper, nothing
 enforces them to be lists .
 We still use the vector notation in the following specialisation to a syntax
 specified by a binding signature.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In the rule 
\begin_inset Formula $\refrule{U-RigRig}$
\end_inset

, the expression 
\begin_inset Formula $o(\vec{t})$
\end_inset

 can be an operation or a variable, in which case 
\begin_inset Formula $\vec{t}$
\end_inset

 is the empty list.
 If 
\begin_inset Formula $o$
\end_inset

 is an operation, the exact nature of 
\begin_inset Formula $\vec{t}$
\end_inset

 depends on the arity 
\begin_inset Formula $(\alpha_{1},\dots,\alpha_{p})$
\end_inset

 of 
\begin_inset Formula $o$
\end_inset

: then 
\begin_inset Formula $\vec{t}$
\end_inset

 is a list of terms of size 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $\Gamma;n+\alpha_{i}\vdash t_{i}$
\end_inset

 for each 
\begin_inset Formula $i\in\{1,\dots,p\}$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the variable context of 
\begin_inset Formula $o(\vec{t})$
\end_inset

.
 The rigid case for operations in the non-cyclic phase consists in the following
 rule.
\begin_inset Formula 
\[
\dfrac{\Gamma\prune{\vec{t}}{M_{1}(\vec{x},\overbrace{v_{n+1},\mydots,v_{n+1+\alpha_{1}}}^{\mathclap{\text{bound variables}}}),\mydots,M_{p}(\mydots)}{\sigma}{\vec{u}}\dashv\Delta}{\Gamma\prune{o(\vec{t})}{M(\arg{\vec{x}})}{\sigma}{o(\vec{u})}\dashv\Delta}
\]

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The notation 
\begin_inset Formula ${\cal L}^{+}\vec{x}^{o}$
\end_inset

 indeed essentially unfolds to 
\begin_inset Formula $\maybold M_{1}(\vec{x})+\maybold M_{2}(\vec{x})$
\end_inset

 in the application case, and to 
\begin_inset Formula $\maybold M'(\vec{x},|C|)$
\end_inset

 in the abstraction case.
 The rule 
\begin_inset Formula $\refrule{P-Fail}$
\end_inset

 applies when there is no such 
\begin_inset Formula $o'$
\end_inset

, a situation which we denote by 
\begin_inset Formula $o\neq\vec{x}\cdot\dots$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Note that the premises of the rules 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

 are not explicitly defined in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

, although for a syntax specified by a binding signature, they have the
 same meaning as in the previous section.
 In fact, the generic algorithm works in a more general setting, as we are
 going to explain in the next section, so that they need to be customised
 for each specific situation.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
we propose an interpretation of typing rules to define the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 accounting for the syntax:
\begin_inset Formula 
\[
\Gamma
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Metavariable arguments as sets
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:ex-arg-sets"

\end_inset

If we think of the arguments of a metavariable as specifying the available
 variables, then it makes sense to assemble them in a set rather than in
 a list.
 This motivates considering the category 
\begin_inset Formula ${\cal A}=\mathbb{I}$
\end_inset

 whose objects are natural numbers and a morphism 
\begin_inset Formula $n\rightarrow p$
\end_inset

 is a subset of 
\begin_inset Formula $\{1,\dots,p\}$
\end_inset

 of cardinal 
\begin_inset Formula $n$
\end_inset

.
 For instance, 
\begin_inset Formula $\mathbb{I}$
\end_inset

 can be taken as subcategory of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 consisting of strictly increasing injections, or as the subcategory of
 the augmented simplex category consisting of injective functions.
 Then, a metavariable takes as argument a set of variables, rather than
 a list of distinct variables.
 In this approach, unifying two metavariables (see the rules 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

 and 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

) amount to computing a set intersection.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{full}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Arities as sets
\end_layout

\begin_layout Standard
In this example, we describe pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with metavariables whose arities are sets of free variables.
 They do not take any explicit argument and they cannot be applied to bound
 variables.
 
\end_layout

\begin_layout Standard
We adopt a locally nameless approach, with two kinds of variables: the named
 ones, chosen in an infinite set 
\begin_inset Formula ${\cal V}$
\end_inset

 of names (e.g., 
\begin_inset Formula $\mathbb{N}$
\end_inset

), and the unnamed ones, as before, which will be used for binding.
 We thus choose 
\begin_inset Formula $\mathcal{A}$
\end_inset

 to be 
\begin_inset Formula $\mathbb{S}\times\mathbb{F}_{m}$
\end_inset

 where 
\begin_inset Formula $\mathbb{S}$
\end_inset

 is the category of finite subsets of 
\begin_inset Formula $\mathcal{V}$
\end_inset

 and inclusions (not injections!) between them.
 Pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus can be specified by an endofunctor 
\begin_inset Formula $F$
\end_inset

 defined by 
\begin_inset Formula $F(X)_{A,n}=n+A+X_{A,n+1}+X_{A,n}\times X_{A,n}$
\end_inset

.
\end_layout

\begin_layout Standard
A metavariable arity, as an object of 
\begin_inset Formula ${\cal A}$
\end_inset

, consists of two components: a finite set of named variables, and a number
 of arguments among unnamed variables.
 Let us define pure arities as those whose second component is 
\begin_inset Formula $0$
\end_inset

.
 A metavariable is said pure if its arity is, and a metavariable context
 is said pure if each metavariable is.
 
\end_layout

\begin_layout Standard
The pure metavariables are the ones mentioned at the beginning of this section.
 Unifying a pure metavariable with itself, as in the rule 
\begin_inset Formula $\refrule{U-Flex}$
\end_inset

, is a no-op, while unifying a pure metavariable with another one (rule
 
\begin_inset Formula $\refrule{P-Flex}$
\end_inset

) produces a new pure metavariable whose arity is the intersection of the
 input metavariable arities.
 Exploiting this observation, an easy induction shows that the most general
 unifier targets a pure metavariable context.
\end_layout

\begin_layout Lemma
Assume an endofunctor for syntax as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:endo-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 If 
\begin_inset Formula $\Gamma\vdash t=u\Rightarrow\sigma\dashv\Delta$
\end_inset

 or 
\begin_inset Formula $\Gamma\prune t{\coprod_{i}{\cal L}f_{i}}{\sigma}u\dashv\Delta$
\end_inset

, and 
\begin_inset Formula $\Delta\neq\bot$
\end_inset

, then 
\begin_inset Formula $\Delta$
\end_inset

 is pure whenever 
\begin_inset Formula $\Gamma$
\end_inset

 is.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\color red
I don't know if that's useful
\color inherit
: the metavariable arity rather specify which closest bound variables it
 can use.A metavariable can be substituted with another if the arity of the
 latter is included in the arity of the former.
 This motivates considering the category 
\begin_inset Formula ${\cal A}=\mathbb{S}$
\end_inset

 whose objects are finite subsets of 
\begin_inset Formula $\mathbb{N}$
\end_inset

, and morphisms are inclusions.
 In this approach, the rule 
\begin_inset Formula $\textsc{U-FlexFlex}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:algo-summary"
plural "false"
caps "true"
noprefix "false"

\end_inset

 unifying a metavariable with itself is a no-op, while unifying a metavariable
 with another one (rule 
\begin_inset Formula $\textsc{P-Flex}$
\end_inset

) amounts to computing the intersection of their arities.
\end_layout

\begin_layout Plain Layout
We can adapt the specification of pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus to this setting: 
\begin_inset Formula $F(X)_{A}=A+X_{A}\times X_{A}+X_{A+1}$
\end_inset

, where 
\begin_inset Formula $A\mapsto A+1$
\end_inset

 is the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping a subset 
\begin_inset Formula $A$
\end_inset

 of 
\begin_inset Formula $\mathbb{N}$
\end_inset

 to 
\begin_inset Formula $\{0\}\cup\{a+1|a\in A\}$
\end_inset

.
 Let us describe inductively the syntax.
 A variable context 
\begin_inset Formula $C$
\end_inset

 is then a finite subset of 
\begin_inset Formula $\mathbb{N}$
\end_inset

.
\begin_inset Formula 
\[
\dfrac{x\in C}{\Gamma;C\vdash x}\qquad\dfrac{\Gamma;C\vdash t\quad\Gamma;C\vdash u}{\Gamma;C\vdash t\ u}\qquad\dfrac{\Gamma;C+1\vdash t}{\Gamma;C\vdash\lambda t}
\]

\end_inset


\begin_inset Formula 
\[
\dfrac{M:A\in\Gamma\quad A\subset C}{\Gamma;C\vdash M}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
Note that a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $\{0\}$
\end_inset

 can be used either at top level in the variable context 
\begin_inset Formula $\{0\}$
\end_inset

, or in 
\begin_inset Formula $\lambda t$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Thinking of metavariables as sets rather than
\end_layout

\begin_layout Plain Layout
Consider 
\begin_inset Formula $\mathbb{S}$
\end_inset

 the category where objects are natural numbers and a morphism 
\begin_inset Formula $n\rightarrow p$
\end_inset

 is a subset of 
\begin_inset Formula $\{0,\dots,p-1\}$
\end_inset

 of cardinal 
\begin_inset Formula $n$
\end_inset

.
 For instance, 
\begin_inset Formula $\mathbb{S}$
\end_inset

 can be taken as subcategory of 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 consisting of strictly increasing injections, or as the subcategory of
 the augmented simplex category consisting of injective functions.
 Again, we can define the endofunctor for 
\begin_inset Formula $\lambda$
\end_inset

-calculus as before.
 Then, a metavariable takes as argument a set of available variables, rather
 than a list of distinct variables.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{full}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Subsection
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "subsec:quantum-lambda"

\end_inset

Ca nemarche pasIn this section we explain how we can define pattern unification
 for quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/popl/PaganiSV14"
literal "false"

\end_inset

.
 We denote by 
\begin_inset Formula $S$
\end_inset

 the set of types, which is inductively generated as follows
\begin_inset Formula 
\[
A,B,C\in S::=\mathbf{qubit}|A\multimap B|!(A\multimap B)|1|A\otimes B|A+B|A^{\ell}
\]

\end_inset

where 
\begin_inset Formula $A^{\ell}$
\end_inset

 is intuitively the type of finite lists of elements of type 
\begin_inset Formula $A$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
We denote by 
\begin_inset Formula $!S$
\end_inset

 the set of non-linear types, that is, types of the shape 
\begin_inset Formula $!-$
\end_inset

.
 In fact 
\begin_inset Formula $!S$
\end_inset

 is isomorphic to 
\begin_inset Formula $S\times S$
\end_inset

, since any non linear type must be of the shape 
\begin_inset Formula $!(A\multimap B)$
\end_inset

.
 We denote by 
\begin_inset Formula $\boldsymbol{S}$
\end_inset

 the set of linear types.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We consider metavariable arities of the shape 
\begin_inset Formula $\Delta\vdash A$
\end_inset

, where 
\begin_inset Formula $\Delta$
\end_inset

 is the multiset of the argument types, and 
\begin_inset Formula $A$
\end_inset

 is the output type of the metavariable.
 We denote by 
\begin_inset Formula $!\Delta$
\end_inset

 the non linear part of 
\begin_inset Formula $\Delta$
\end_inset

, i.e., its sub-multiset consisting of its non-linear types, that is, types
 of the shape 
\begin_inset Formula $!A$
\end_inset

.
 We denote by 
\begin_inset Formula $\boldsymbol{\Delta}$
\end_inset

 the linear part of 
\begin_inset Formula $\Delta$
\end_inset

.
 Substituting a metavariable of arity 
\begin_inset Formula $\Delta_{1}\vdash A_{1}$
\end_inset

 with a metavariable of arity 
\begin_inset Formula $\Delta_{2}\vdash A_{2}$
\end_inset

 requires that 
\begin_inset Formula $A_{1}=A_{2}$
\end_inset

, 
\begin_inset Formula $\boldsymbol{\Delta_{1}}=\boldsymbol{\Delta_{2}}$
\end_inset

, and an injective renaming 
\begin_inset Formula $\bang\Delta_{1}\hookrightarrow\bang\Delta_{2}$
\end_inset

.
 Therefore, we choose 
\begin_inset Formula ${\cal A}$
\end_inset

 to be the category whose objects are metavariable arities 
\begin_inset Formula $\Delta\vdash A$
\end_inset

 and the set of morphisms between 
\begin_inset Formula $\Delta_{1}\vdash A_{1}$
\end_inset

 and 
\begin_inset Formula $\Delta_{2}\vdash A_{2}$
\end_inset

 is empty if 
\begin_inset Formula $A_{1}\neq A_{2}$
\end_inset

 or 
\begin_inset Formula $\boldsymbol{\Delta_{1}}\neq\boldsymbol{\Delta_{2}}$
\end_inset

, or is the set of injective renamings between 
\begin_inset Formula $!\Delta_{1}$
\end_inset

 and 
\begin_inset Formula $\bang\Delta_{2}$
\end_inset

 otherwise.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
A metavariable could have linear arguments, and non linear ones.
 We therefore consider metavariable arities 
\begin_inset Formula $\Gamma;!\Delta\vdash A$
\end_inset

, where 
\begin_inset Formula $\Gamma$
\end_inset

 is a finite multi-set of linear types, 
\begin_inset Formula $!\Delta$
\end_inset

 is a multi-set of non linear types, and 
\begin_inset Formula $A$
\end_inset

 is the output type of the metavariable.
 Substituting a metavariable of arity 
\begin_inset Formula $\Gamma_{1};!\Delta_{1}\vdash A_{1}$
\end_inset

 with a metavariable of arity 
\begin_inset Formula $\Gamma_{2};!\Delta_{2}\vdash A_{2}$
\end_inset

 requires that 
\begin_inset Formula $\Gamma_{1}=\Gamma_{2}$
\end_inset

, 
\begin_inset Formula $A_{1}=A_{2}$
\end_inset

, and an injective renaming 
\begin_inset Formula $!\Delta_{1}\hookrightarrow!\Delta_{2}$
\end_inset

.
 Therefore, we choose 
\begin_inset Formula ${\cal A}=\bang S\times\mathbb{R}[\underline{S}]\times S$
\end_inset

, where 
\begin_inset Formula $\mathbb{R}[\underline{S}]$
\end_inset

 is the category of multisets in 
\begin_inset Formula $\underline{S}$
\end_inset

 and injective renamings between them.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The components of the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 are specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:quantum-endo"
plural "false"
caps "true"
noprefix "false"

\end_inset

, except for the promotion, which we discuss below.
 We use the following notations.
\end_layout

\begin_layout Notation
\begin_inset Formula $\delta(P)$
\end_inset

 denotes either a singleton set or the empty set, depending on whether the
 property 
\begin_inset Formula $P$
\end_inset

 is true.
\end_layout

\begin_layout Notation
\begin_inset Formula $|\Delta|_{!C}$
\end_inset

 denotes the number of occurrences of 
\begin_inset Formula $!C$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

.
 By convention, we take it to be 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $!C$
\end_inset

 does not make sense (i.e., when 
\begin_inset Formula $C$
\end_inset

 is not 
\begin_inset Formula $A\multimap B$
\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
, listed in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:quantum-endo"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 A type 
\begin_inset Formula $\boldsymbol{A}$
\end_inset

 in bold face is implicitly assumed to be linear; a multiset 
\begin_inset Formula $\boldsymbol{\Gamma}$
\end_inset

 in bold face is implicitly assumed to consist of linear types only.
 A context 
\begin_inset Formula $!\Delta$
\end_inset

 in the typing rules consists of non linear types only.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The first rule handles the term constants in 
\begin_inset Formula ${\cal C}=\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}$
\end_inset

, that all have typing rules of the following shape
\begin_inset Formula 
\[
\dfrac{c\in{\cal C}}{!\Delta\vdash c:A_{c}\multimap B_{c}}
\]

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Here, the context 
\begin_inset Formula $!\Delta$
\end_inset

 consists only of non linear types.
 We take
\begin_inset Formula 
\[
O_{c}(\Delta\vdash C)=\delta(\Delta\vdash C=\bang\Delta\vdash A_{c}\multimap B_{c})\qquad\gamma_{c}=0
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula ${\cal A}(\emptyset\vdash A_{c}\multimap B_{c},\Gamma\vdash C)$
\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{c}}y(\emptyset\vdash A_{c}\multimap B_{c})
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
where 
\begin_inset Formula $\delta(P)$
\end_inset

 denotes either a singleton set or the empty set, depending on whether 
\begin_inset Formula $P$
\end_inset

 is true.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, 
\begin_inset Formula ${\cal A}(\emptyset\vdash\tau,\Delta\vdash C)$
\end_inset

 is non-empty and a singleton set precisely when 
\begin_inset Formula $A=\tau$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\Delta}=\emptyset$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Now, we introduce the linear variable case
\begin_inset Formula 
\[
\infer[ax]{\bang{\Delta},x:A\entail x:A}{\text{\ensuremath{A} linear}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
we take
\begin_inset Formula 
\[
O_{v}(\Delta\vdash C)=\delta(\boldsymbol{\Delta}=C)\qquad\gamma_{v}=0
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{\boldsymbol{A}}y(\boldsymbol{A}\vdash\boldsymbol{A})}
\]

\end_inset

where 
\begin_inset Formula $|\Delta|_{\boldsymbol{A}}$
\end_inset

 counts the number of occurrences of 
\begin_inset Formula $\boldsymbol{A}$
\end_inset

 inIndeed, 
\begin_inset Formula $y(\boldsymbol{A}\vdash\boldsymbol{A})$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is a singleton set (accounting for the variable 
\begin_inset Formula $x$
\end_inset

) and non empty precisely when 
\begin_inset Formula $\Delta$
\end_inset

 is of the shape 
\begin_inset Formula $!\Delta,x:\boldsymbol{A}$
\end_inset

, and 
\begin_inset Formula $\tau=\boldsymbol{A}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us handle the non linear variable case.
\begin_inset Formula 
\[
\infer[axd]{\bang{\Delta},x:\bang(A\loli B)\entail x:A\loli B}{}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
We take
\begin_inset Formula 
\[
O_{v!}(\Delta\vdash C)=\delta(\Delta=\bang\Delta)\times|\Delta|_{!C}\qquad\gamma_{v!}=0
\]

\end_inset

where 
\begin_inset Formula $|\Delta|_{!C}$
\end_inset

 counts the number of occurrences of 
\begin_inset Formula $!C$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

.
 By convention, we take it to be 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $!C$
\end_inset

 does not make sense.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Indeed, 
\begin_inset Formula $y(!(A\multimap B)\vdash A\multimap B)$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is the number (as a cardinal set) of occurences of 
\begin_inset Formula $!(A\multimap B)$
\end_inset

 in 
\begin_inset Formula $\Delta$
\end_inset

, whenever 
\begin_inset Formula $\tau=A\multimap B$
\end_inset

 (otherwise, it is the empty set).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us now handle the 
\begin_inset Formula $\lambda$
\end_inset

-abstraction rule.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\infer[\loli_{I}]{\Delta\entail\lambda x^{A}.M:A\loli B}{\Delta,x:A\entail M:B}
\]

\end_inset

Denoting linear contexts with a bold face, we take
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
O_{l}(\Delta\vdash C)=\{l_{A,B}|C=A\multimap B)\qquad H_{l,1}(\Delta\vdash C,l_{A,B})=(\Delta,A\vdash B)
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
F(X)=\dots+{\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)
\]

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
where 
\begin_inset Formula $\underline{\Delta},A\vdash B$
\end_inset

 denotes the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping 
\begin_inset Formula $\Delta'\vdash A'$
\end_inset

 to 
\begin_inset Formula $\Delta',A\vdash B$
\end_inset

.
 Note that 
\begin_inset Formula $y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset

 evaluated at 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 is non-empty only when 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma}$
\end_inset

 and 
\begin_inset Formula $\tau=A\multimap B$
\end_inset

, in which case it is a singleton set.
 This is why we have to quantify over 
\begin_inset Formula $\boldsymbol{\Gamma}$
\end_inset

, so that it works for any 
\begin_inset Formula $\Delta$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Let us now discuss promotion for values.
\begin_inset Formula 
\[
\infer[p]{\bang\Delta\entail V:\bang{(A\loli B)}}{\bang\Delta\entail V:A\loli B}
\]

\end_inset

This typing rule can be split as described in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

, depending on what 
\begin_inset Formula $V$
\end_inset

 is: a variable, a 
\begin_inset Formula $\lambda$
\end_inset

-abstraction, or a term constant 
\begin_inset Formula $c\in{\cal C}=\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules for values
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\dots+\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{}{!\Delta,x:\bang(A\multimap B)\vdash x:\bang(A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash\bang(A\multimap B))}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{!\Delta,x:A\vdash M:B}{!\Delta\vdash\lambda x^{A}.M:\bang(A\multimap B)}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}X_{\underline{\Delta},A\vdash B}\times y(\emptyset\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{}{!\Delta\vdash c:\bang(A_{c}\multimap B_{c})}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{c}}y(\emptyset\vdash\bang(A_{c}\multimap B_{c}))$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Let us explain how the coproduct components are inferred.
 Each premise is straightforwardly translated.
 For example, in the elimination rule for abstraction, the premise 
\begin_inset Formula $\bang\Delta,\Gamma\entail M:A\loli B$
\end_inset

 becomes 
\begin_inset Formula $X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}$
\end_inset

, where 
\begin_inset Formula $\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B$
\end_inset

 is the endofunctor on 
\begin_inset Formula ${\cal A}$
\end_inset

 mapping 
\begin_inset Formula $\Delta\vdash\tau$
\end_inset

 to 
\begin_inset Formula $!\Delta,\boldsymbol{\Gamma}\vdash A\multimap B$
\end_inset

.
 Conclusions are always of the shape 
\begin_inset Formula $!\Delta,\Gamma\vdash t:\tau$
\end_inset

, or 
\begin_inset Formula $!\Delta,\Gamma,\Sigma\vdash t:\tau$
\end_inset

 where 
\begin_inset Formula $\Gamma,\Sigma$
\end_inset

 consist of linear types.
 This justifies the global quantification over 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Sigma$
\end_inset

, and the multiplication by a representable functor 
\begin_inset Formula $y(\boldsymbol{\Gamma}\vdash\tau)$
\end_inset

 or 
\begin_inset Formula $y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash\tau)$
\end_inset

, which evaluated at 
\begin_inset Formula $\Delta\vdash A$
\end_inset

 is non-empty (and a singleton set) precisely when 
\begin_inset Formula $A=\tau$
\end_inset

 and 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma}$
\end_inset

, or 
\begin_inset Formula $\boldsymbol{\Delta}=\boldsymbol{\Gamma},\boldsymbol{\Sigma}$
\end_inset

 in the second case.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float table
wide true
sideways true
status open

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $!\Delta$
\end_inset

 is non linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $!\Delta$
\end_inset

 is non linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{c\in\{\punit,{\tt split}^{A},\ensuremath{}\meas,\new,U\}}{!\Delta\vdash c:A_{c}\multimap B_{c}}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{c}}y(\emptyset\vdash A_{c}\multimap B_{c})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{A}}y(\boldsymbol{A}\vdash\boldsymbol{A})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{adjustbox}{rotate=90}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\dots+\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:B}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_E]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma,
\backslash
Sigma
\backslash
entail   
\backslash
letunitterm{M}{N}:A }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash1}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\boldsymbol{\Sigma}}\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_I]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
tensterm{M}{N}:A
\backslash
tensor B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash B}\times y(\boldsymbol{\Gamma},\boldsymbol{\boldsymbol{\Sigma}}\vdash A\otimes B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail    
\backslash
lettensterm{x^{A}}{y^{B}}{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
tensor B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A,y:B
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B,C}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\otimes B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},A,B\vdash C}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^
\backslash
ell]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injl{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A}\times y(\boldsymbol{\Gamma}\vdash A\oplus B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^r]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injr{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\oplus B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
match{P}{x^A}{M}{y^B}N:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail P:A
\backslash
sumtype B   &   
\backslash
deduce{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,y:B
\backslash
entail N:C}{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A
\backslash
entail M:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B,C}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\oplus B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},A\vdash C}\times X_{\underline{!\Delta},\boldsymbol{\Sigma},B\vdash C}\times y(\boldsymbol{\Gamma},\boldsymbol{\Sigma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tlist{-
\backslash
!}_{
\backslash
!
\backslash
!I}]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   M:
\backslash
tlist{A} }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit
\backslash
oplus(A{
\backslash
otimes}
\backslash
tlist A) } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash1\oplus(A\otimes A^{l})}\times y(\boldsymbol{\Gamma}\vdash A^{l})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[{
\backslash
tt rec}]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma
\backslash
entail 
\backslash
letrec{f^{A
\backslash
multimap B}}{x}{M}{N}:C }
\end_layout

\begin_layout Plain Layout

{  
\backslash
deduce
\end_layout

\begin_layout Plain Layout

{ 
\backslash
bang
\backslash
Delta,f:
\backslash
bang{(A
\backslash
multimap B)},x:A
\backslash
entail M:B   }
\end_layout

\begin_layout Plain Layout

{  
\backslash
bang
\backslash
Delta,
\backslash
Gamma,f:
\backslash
bang{(A
\backslash
multimap B)}
\backslash
entail N:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B,C}X_{\underline{!\Delta},!(A\multimap B),A\vdash B}\times X_{\underline{!\Delta},\boldsymbol{\Gamma},!(A\multimap B)\vdash C}\times y(\boldsymbol{\Gamma}\vdash C)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{\ell}(\Delta\vdash C)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{\ell,j}(\Delta\vdash C,o)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{c\in{\cal C}}{!\Delta\vdash c:A_{c}\multimap B_{c}}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\delta(\Delta\vdash C=\bang\Delta\vdash A_{c}\multimap B_{c})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[ax]{\bang{\Delta},x:A\entail x:A}{\text{\ensuremath{A} linear}}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{}{}}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta(\boldsymbol{\Delta}=C)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[axd]{\bang{\Delta},x:\bang(A\loli B)\entail x:A\loli B}{}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta(\Delta=\bang\Delta)\times|\Delta|_{!C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\infer[\loli_{I}]{\Delta\entail\lambda x^{A}.M:A\loli B}{\Delta,x:A\entail M:B}$
\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\dfrac{}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{A,B}|C=A\multimap B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,1}=\Delta,A\vdash B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:C}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli C   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\Gamma,\Sigma,A}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\multimap C\\
H_{-,1}=\bang\Delta,\Sigma\vdash A
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_E]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma,
\backslash
Sigma
\backslash
entail   
\backslash
letunitterm{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{u_{\Gamma,\Sigma}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash1\\
H_{-,1}=\bang\Delta,\Sigma\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_I]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
tensterm{M}{N}:A
\backslash
tensor B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{t_{A,B,\Gamma,\Sigma}|\Delta\vdash C=\bang\Delta,\Gamma,\Sigma\vdash A\otimes B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\\
H_{-,1}=\bang\Delta,\Sigma\vdash B
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tensor_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail    
\backslash
lettensterm{x^{A}}{y^{B}}{M}{N}:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
tensor B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A,y:B
\backslash
entail N:C } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{t'_{A,B,\Gamma,\Sigma}|\Delta=\bang\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\otimes B\\
H_{-,1}=\bang\Delta,\Sigma,A,B\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^
\backslash
ell]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injl{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{inl_{A,B}|C=A\oplus B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_{I}^r]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   
\backslash
injr{M}:A
\backslash
sumtype B }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:B } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{inr_{A,B}|C=A\oplus B\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
oplus_E]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail 
\backslash
match{P}{x^A}{M}{y^B}N:C }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail P:A
\backslash
sumtype B   &   
\backslash
deduce{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,y:B
\backslash
entail N:C}{
\backslash
bang
\backslash
Delta,
\backslash
Sigma,x:A
\backslash
entail M:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{\frac{}{}}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{m_{A,B,\Gamma,\Sigma}|\Delta=!\Delta,\Gamma,\Sigma\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\bang\Delta,\Gamma\vdash A\oplus B\\
H_{-,1}=\bang\Delta,\Sigma,A\vdash C\\
H_{-,2}=\bang\Delta,\Sigma,B\vdash C
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tlist{-
\backslash
!}_{
\backslash
!
\backslash
!I}]{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail   M:
\backslash
tlist{A} }{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:
\backslash
tunit
\backslash
oplus(A{
\backslash
otimes}
\backslash
tlist A) } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{tail_{A}|C=A^{\ell}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H_{-,0}=\Delta\vdash1\oplus(A\otimes A^{\ell})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[{
\backslash
tt rec}]{   
\backslash
bang{
\backslash
Delta},
\backslash
Gamma
\backslash
entail 
\backslash
letrec{f^{A
\backslash
multimap B}}{x}{M}{N}:C }
\end_layout

\begin_layout Plain Layout

{  
\backslash
deduce
\end_layout

\begin_layout Plain Layout

{ 
\backslash
bang
\backslash
Delta,f:
\backslash
bang{(A
\backslash
multimap B)},x:A
\backslash
entail M:B   }
\end_layout

\begin_layout Plain Layout

{  
\backslash
bang
\backslash
Delta,
\backslash
Gamma,f:
\backslash
bang{(A
\backslash
multimap B)}
\backslash
entail N:C} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{\frac{\frac{}{}}{}}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{rec_{A,B}|A,B\in S\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\begin{array}{l}
H_{-,0}=\Delta,f:\bang(A\multimap B)\vdash C\\
H_{-,1}=\bang\Delta,f:\bang(A\multimap B),A\vdash B
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{adjustbox}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Some components of the endofunctor specifying the quantum 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:quantum-endo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
end{adjustbox}
\end_layout

\begin_layout Plain Layout

%
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)_{\Gamma;!\Delta\vdash\tau}=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{ (\ensuremath{\Gamma=\{A\}}, \ensuremath{\tau=A})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A\in\bang S}y(A;\emptyset\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|!\Delta|_{!A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B\in S}y(\emptyset;!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
See note below
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{1,\tau}\delta_{\Gamma,\emptyset}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset;\emptyset\vdash1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{\Gamma,A;!\Delta\vdash B}$
\end_inset

 or 
\begin_inset Formula $X_{\Gamma;!\Delta,A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rules (
\begin_inset Formula $\Gamma$
\end_inset

,
\begin_inset Formula $\Sigma$
\end_inset

 linear)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)_{\Delta\vdash\tau}=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $F(X)=\ ?$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[ax]{
\backslash
bang{
\backslash
Delta},x:A
\backslash
entail x:A}{
\backslash
text{$A$ linear}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\boldsymbol{\Delta},\{A\}}\delta_{\tau,A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A\in\boldsymbol{S}}y(A\vdash A)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[axd]{
\backslash
bang{
\backslash
Delta},x:
\backslash
bang (A
\backslash
loli B)
\backslash
entail x:A
\backslash
loli B}{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|!\Delta|_{!(A\multimap B)}\delta_{\boldsymbol{\Delta},\emptyset}\delta_{\tau,A\multimap B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{A,B\in S}y(!(A\multimap B)\vdash A\multimap B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[p]{
\backslash
bang
\backslash
Delta
\backslash
entail V:
\backslash
bang{(A
\backslash
loli B)}}{   
\backslash
bang
\backslash
Delta
\backslash
entail V:A
\backslash
loli B   &   V
\backslash
textrm{ value} } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
See note below
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
tunit_I]{   
\backslash
bang{
\backslash
Delta}
\backslash
entail 
\backslash
punit:
\backslash
tunit }{} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\tau,1}\delta_{\boldsymbol{\Delta},\emptyset}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(\emptyset\vdash1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_I]{
\backslash
Delta
\backslash
entail
\backslash
lambda x^A.M:A
\backslash
loli B}{   
\backslash
Delta,x:A
\backslash
entail M:B} 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{\Delta,A\vdash B}\delta_{\tau,A\multimap B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},A,B}}X_{\underline{\Delta},A\vdash B}\times y(\boldsymbol{\Gamma}\vdash A\multimap B)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
infer[
\backslash
loli_E]{
\backslash
bang{
\backslash
Delta},
\backslash
Gamma,
\backslash
Sigma
\backslash
entail MN:B}{   
\backslash
bang
\backslash
Delta,
\backslash
Gamma
\backslash
entail M:A
\backslash
loli B   &   
\backslash
bang
\backslash
Delta,
\backslash
Sigma
\backslash
entail N:A } 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $X_{!\Delta,\Gamma\vdash A\multimap B}\times X_{!\Delta,\Sigma\vdash A}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta_{\Delta,(!\Delta,\Gamma,\Sigma)}\delta_{\tau,B}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula ${\displaystyle \coprod_{\boldsymbol{\Gamma},\boldsymbol{\Sigma},A,B}X_{\underline{!\Delta},\boldsymbol{\Gamma}\vdash A\multimap B}\times X_{\underline{!\Delta},\boldsymbol{\Sigma}\vdash A}\times y(\boldsymbol{\Gamma},\boldsymbol{\Delta}\vdash B)}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:simply-typed-so"

\end_inset

 In this section, we present the example of simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 Our treatment generalises to any multi-sorted binding signature
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "FioreHur"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $T$
\end_inset

 denote the set of simple types generated by a set of atomic types and a
 binary arrow type construction 
\begin_inset Formula $-\Rightarrow-$
\end_inset

.
 Let us now describe the category 
\begin_inset Formula ${\cal A}$
\end_inset

 of arities, or variable contexts, and renamings between them.
 An arity 
\begin_inset Formula $\vec{\sigma}\arSep\tau$
\end_inset

 consists of a list of input types 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and an output type 
\begin_inset Formula $\tau$
\end_inset

.
 A term 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $\vec{\sigma}\arSep\tau$
\end_inset

 considered as a variable context is intuitively a well-typed term 
\begin_inset Formula $t$
\end_inset

 of type 
\begin_inset Formula $\tau$
\end_inset

 potentially using variables whose types are specified by 
\begin_inset Formula $\vec{\sigma}$
\end_inset

.
 A valid choice of arguments for a metavariable 
\begin_inset Formula $M:(\vec{\sigma}\arSep\tau)$
\end_inset

 in variable context 
\begin_inset Formula $\vec{\sigma}'\arSep\tau'$
\end_inset

 first requires 
\begin_inset Formula $\tau=\tau'$
\end_inset

, and consists of an injective renaming 
\begin_inset Formula $\vec{r}$
\end_inset

 between 
\begin_inset Formula $\vec{\sigma}=(\sigma_{1},\dots,\sigma_{m})$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma}'=(\sigma'_{1},\dots,\sigma'_{n})$
\end_inset

, that is, a choice of distinct positions 
\begin_inset Formula $(r_{1},\dots,r_{m})$
\end_inset

 in 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

 such that 
\begin_inset Formula $\vec{\sigma}=\sigma'_{\vec{r}}$
\end_inset

.
\end_layout

\begin_layout Standard
This discussion determines the category of arities as 
\begin_inset Formula ${\cal A}=\mathbb{F}_{m}[T]\times T$
\end_inset

 , where 
\begin_inset Formula $\mathbb{F}_{m}[T]$
\end_inset

 is the category of finite lists of elements of 
\begin_inset Formula $T$
\end_inset

 and injective renamings between them.
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

 summarises the definition of the endofunctor 
\begin_inset Formula $F$
\end_inset

 on 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 specifying the syntax, where 
\begin_inset Formula $|\vec{\sigma}|_{\tau}$
\end_inset

 denotes the number (as a cardinal set) of occurrences of 
\begin_inset Formula $\tau$
\end_inset

 in 
\begin_inset Formula $\vec{\sigma}$
\end_inset

.
\end_layout

\begin_layout Standard
The induced signature is pattern-friendly and so the generic pattern unification
 algorithm applies.
 Equalisers and pullbacks are computed following the same pattern as in
 pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus.
 For example, to unify 
\begin_inset Formula $M(\vec{x})$
\end_inset

 and 
\begin_inset Formula $M(\vec{y})$
\end_inset

, we first compute the vector 
\begin_inset Formula $\vec{z}$
\end_inset

 of common positions between 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

, thus satisfying 
\begin_inset Formula $x_{\vec{z}}=y_{\vec{z}}$
\end_inset

.
 Then, the most general unifier maps 
\begin_inset Formula $M:(\vec{\sigma}\arSep\tau)$
\end_inset

 to the term 
\begin_inset Formula $P(\vec{z})$
\end_inset

, where the arity 
\begin_inset Formula $\vec{\sigma}'\arSep\tau'$
\end_inset

 of the fresh metavariable 
\begin_inset Formula $P$
\end_inset

 is the only possible choice such that 
\begin_inset Formula $P(\vec{z})$
\end_inset

 is a valid term in the variable context 
\begin_inset Formula $\vec{\sigma}\arSep\tau$
\end_inset

, that is, 
\begin_inset Formula $\tau'=\tau$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma}'=\sigma_{\vec{z}}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Examples of generalised binding signatures (
\begin_inset CommandInset ref
LatexCommand formatted
reference "def:GB-signature"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:all-syntax"

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simply-typed 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{n}(\vec{\sigma}\arSep\tau)=\mydots+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{o}=(\mydots)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $()$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\vdash t:\tau'\Rightarrow\tau\quad\Gamma\vdash u:\tau'}{\Gamma\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in T\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{l}
\vec{\sigma}\arSep(\tau'\Rightarrow\ensuremath{\tau})\\
\vec{\sigma}\arSep\tau'
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\vec{\sigma},\tau_{1}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:ordered-calculus"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{n}(\vec{\sigma}\Fsep\vec{\omega}\arSep\tau)=\mydots+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{o}=(\mydots)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{\Gamma\Fsep\cdot\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\text{\text{ and }\ensuremath{\vec{\omega}=()}}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $()$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{}{\Gamma\Fsep x:\tau\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v^{>}|\text{\ensuremath{\vec{\omega}=()}}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $()$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega\vdash t:\tau'\Rightarrow\tau\quad\Gamma\Fsep\cdot\vdash u:\tau'}{\Gamma\Fsep\Omega\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in T\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{l}
\vec{\sigma}\Fsep\vec{\omega}\arSep(\tau'\Rightarrow\ensuremath{\tau})\\
\vec{\sigma}\Fsep()\arSep\tau'
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega_{1}\vdash t:\tau'\twoheadrightarrow\tau\quad\Gamma\Fsep\Omega_{2}\vdash u:\tau'}{\Gamma\Fsep\Omega_{1},\Omega_{2}\vdash t^{>}\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}^{\vec{\omega}_{1},\vec{\omega}_{2}}|\tau'\in T\text{ and }\text{\ensuremath{\vec{\omega}=\vec{\omega}_{1},\vec{\omega}_{2}}}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{l}
\vec{\sigma}\Fsep\vec{\omega}_{1}\arSep(\tau'\Rightarrow\ensuremath{\tau})\\
\vec{\sigma}\Fsep\vec{\omega}_{2}\arSep\tau'
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma,x:\tau_{1}\Fsep\Omega\vdash t:\tau_{2}}{\Gamma\Fsep\Omega\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\vec{\sigma},\tau_{1}\Fsep\vec{\omega}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{\Gamma\Fsep\Omega,x:\tau_{1}\vdash t:\tau_{2}}{\Gamma\Fsep\Omega\vdash\lambda^{>}x.t:\tau_{1}\twoheadrightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}^{>}|\tau=(\tau_{1}\twoheadrightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\vec{\sigma},\tau_{1}\Fsep\vec{\omega}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{1em}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
System F
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typing rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O_{n}(p|\vec{\sigma}\vdash\tau)=\mydots+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\alpha_{o}=(\mydots)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{x:\tau\in\Gamma}{n\Fsep\Gamma\vdash x:\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{v_{i}|i\in|\vec{\sigma}|_{\tau}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n\Fsep\Gamma\vdash t:\tau'\Rightarrow\tau\quad n\Fsep\Gamma\vdash u:\tau'}{n\Fsep\Gamma\vdash t\ u:\tau}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{a_{\tau'}|\tau'\in S_{n}\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(\begin{array}{l}
n\Fsep\vec{\sigma}\arSep\tau'\Rightarrow\ensuremath{\tau}\\
n\Fsep\vec{\sigma}\arSep\tau'
\end{array}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}\dfrac{n\Fsep\Gamma,x:\tau_{1}\vdash t:\tau_{2}}{n\Fsep\Gamma\vdash\lambda x.t:\tau_{1}\Rightarrow\tau_{2}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{l_{\tau_{1},\tau_{2}}|\tau=(\tau_{1}\Rightarrow\tau_{2})\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n\Fsep\vec{\sigma},\tau_{1}\arSep\tau_{2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n\Fsep\Gamma\vdash t:\forall\tau_{1}\quad\tau_{2}\in S_{n}}{n\Fsep\Gamma\vdash t\cdot\tau_{2}:\tau_{1}[\tau_{2}]}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{A_{\tau_{1},\tau_{2}}|\tau=\tau_{1}[\tau_{2}]\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n\Fsep\vec{\sigma}\arSep\forall\tau_{1})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\dfrac{n+1\Fsep wk(\Gamma)\vdash t:\tau}{n\Fsep\Gamma\vdash\Lambda t:\forall\tau}\vphantom{\dfrac{\dfrac{}{}}{\dfrac{}{}}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{\Lambda_{\tau'}|\tau=\forall\tau'\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n+1\Fsep wk(\vec{\sigma})\arSep\tau')$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:ordered-calculus"

\end_inset


\end_layout

\begin_layout Standard
Our setting handles linear ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus, consisting of 
\begin_inset Formula $\lambda$
\end_inset

-terms using all the variables in context.
 In this context, a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $m\in\mathbb{N}$
\end_inset

 can only be used in the variable context 
\begin_inset Formula $m$
\end_inset

, and there is no freedom in choosing the arguments of a metavariable applicatio
n, since all the variables must be used, in order.
 Thus, there is no need to even mention those arguments in the syntax.
 It is thus not surprising that ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus is already handled by first-order unification, where metavariables
 do not take any argument, by considering ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus as a multi-sorted Lawvere theory where the sorts are the variable
 contexts, and the syntax is generated by operations 
\begin_inset Formula $L_{n}\times L_{m}\rightarrow L_{n+m}$
\end_inset

 and abstractions 
\begin_inset Formula $L_{n+1}\rightarrow L_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Our generalisation can handle calculi combining ordered and unrestricted
 variables, such as the calculus underlying ordered linear logic described
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Polakow00lfm"
literal "false"

\end_inset

.
 In this section we detail this specific example.
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $T$
\end_inset

 of types is generated by a set of atomic types and two binary arrow type
 constructions 
\begin_inset Formula $\Rightarrow$
\end_inset

 and 
\begin_inset Formula $\twoheadrightarrow$
\end_inset

.
 The syntax extends pure 
\begin_inset Formula $\lambda$
\end_inset

-calculus with a distinct application 
\begin_inset Formula $t^{>}\ u$
\end_inset

 and abstraction 
\begin_inset Formula $\lambda^{>}u$
\end_inset

.
 Variables contexts are of the shape 
\begin_inset Formula $\vec{\sigma}\Fsep\vec{\omega}\arSep\tau$
\end_inset

, where 
\begin_inset Formula $\vec{\sigma}$
\end_inset

, 
\begin_inset Formula $\vec{\omega}$
\end_inset

, and 
\begin_inset Formula $\tau$
\end_inset

 are taken in 
\begin_inset Formula $T$
\end_inset

.
 The idea is that a term in such a context has type 
\begin_inset Formula $\tau$
\end_inset

 and must use all the variables of 
\begin_inset Formula $\vec{\omega}$
\end_inset

 in order, but is free to use any of the variables in 
\begin_inset Formula $\vec{\sigma}$
\end_inset

.
 Assuming a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $\vec{\sigma}\Fsep\vec{\omega}\arSep\tau$
\end_inset

, the above discussion about ordered 
\begin_inset Formula $\lambda$
\end_inset

-calculus justifies that there is no need to specify the arguments for 
\begin_inset Formula $\vec{\omega}$
\end_inset

 when applying 
\begin_inset Formula $M$
\end_inset

.
 Thus, a metavariable application 
\begin_inset Formula $M(\vec{x})$
\end_inset

 in the variable context 
\begin_inset Formula $\vec{\sigma}'\Fsep\vec{\omega}'\arSep\tau'$
\end_inset

 is well-formed if 
\begin_inset Formula $\tau=\tau'$
\end_inset

 and 
\begin_inset Formula $\vec{x}$
\end_inset

 is an injective renaming from 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 to 
\begin_inset Formula $\vec{\sigma}'$
\end_inset

.
 Therefore, we take 
\begin_inset Formula ${\cal A}=\mathbb{F}_{m}[T]\times T^{*}\times T$
\end_inset

 for the category of arities, where 
\begin_inset Formula $T^{*}$
\end_inset

 denote the discrete category whose objects are lists of elements of 
\begin_inset Formula $T$
\end_inset

.
 The remaining components of the GB-signature are specified in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

: we alternate typing rules for the unrestricted and the ordered fragments
 (variables, application, abstraction).
\end_layout

\begin_layout Standard
Pullbacks and equalisers are computed essentially as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 For example, the most general unifier of 
\begin_inset Formula $M(\vec{x})$
\end_inset

 and 
\begin_inset Formula $M(\vec{y})$
\end_inset

 maps 
\begin_inset Formula $M$
\end_inset

 to 
\begin_inset Formula $P(\vec{z})$
\end_inset

 where 
\begin_inset Formula $\vec{z}$
\end_inset

 is the vector of common positions of 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

, and 
\begin_inset Formula $P$
\end_inset

 is a fresh metavariable of arity 
\begin_inset Formula $\sigma_{\vec{z}}\Fsep\vec{\omega}\arSep\tau$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Intuitively, given 
\begin_inset Formula $X\in\Set$
\end_inset

, the set 
\begin_inset Formula $X_{n}$
\end_inset

 is the set of expressions with exactly 
\begin_inset Formula $n$
\end_inset

 (distinct) variables.
 Then, we can consider the linear lambda-calculus, as an endofunctor on
 
\begin_inset Formula $\Set$
\end_inset

 mapping 
\begin_inset Formula $X$
\end_inset

 to 
\begin_inset Formula $F(X)$
\end_inset

 where 
\begin_inset Formula $F(X)_{n}=y1+\coprod_{p+q=n}X_{p}\times X_{q}+(n+1)\times X_{n+1}$
\end_inset

.
 Note that we could also specify a non-linear binder by replacing 
\begin_inset Formula $(n+1)\times X_{n+1}$
\end_inset

 with 
\begin_inset Formula $\coprod_{p>n}\left(\begin{array}{c}
p\\
n
\end{array}\right)X_{p}$
\end_inset

.
 We could also have a non linear application by replacing 
\begin_inset Formula $\coprod_{p+q=n}X_{p}\times X_{q}$
\end_inset

 with 
\begin_inset Formula $X_{n}\times X_{n}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Then, 
\begin_inset Formula $F^{*}(0)$
\end_inset

 is the linear lambda-calculus.
 
\begin_inset Formula $F^{*}(yn)$
\end_inset

 is the syntax of linear 
\begin_inset Formula $\lambda$
\end_inset

-calculus extended with one 
\begin_inset Formula $n$
\end_inset

-ary metavariable applied to 
\begin_inset Formula $n$
\end_inset

 (distinct) variables.
 
\end_layout

\begin_layout Plain Layout
Note that 
\begin_inset Formula $F(X)$
\end_inset

 is of the shape 
\begin_inset Formula $I+\coprod_{i}X_{p_{i,1}}\times\dots\times X_{p_{i,m_{i}}}\times yn_{i}$
\end_inset

 and each 
\begin_inset Formula $X\mapsto X_{p_{i,1}}\times\dots\times X_{p_{i,m_{i}}}\times yn_{i}$
\end_inset

 is left adjoint to 
\begin_inset Formula $X\mapsto X_{n_{i}}\times(yp_{i,1}+\dots+yp_{i,m_{i}})$
\end_inset

.
 
\color red
No
\color inherit

\begin_inset Formula $\bang$
\end_inset


\color red
 But almost, i.e., if there exists a morphism 
\begin_inset Formula $A\rightarrow X_{p}\times y_{n}$
\end_inset

, then in fact 
\begin_inset Formula $A=A_{n}yn$
\end_inset

 and there exists a morphism 
\begin_inset Formula $A_{n}\times yp\rightarrow X$
\end_inset

, but the converse is false.
 
\end_layout

\begin_layout Remark
We could have done the non-linear version in this setting as well, but the
 abstract syntax is more convoluted (see the binomial coefficient) and metavaria
bles must still be linear.
\end_layout

\begin_layout Example
linear lambda calculus, quantum lambda calculus
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Intrinsic polymorphic syntax
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "subsec:system-F"

\end_inset


\end_layout

\begin_layout Standard
We present intrinsic System F, in the spirit of
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HamanaPoly"
literal "false"

\end_inset

.
 The syntax of types in type variable context 
\begin_inset Formula $n$
\end_inset

 is inductively generated as follows, following the De Bruijn level convention.
\begin_inset Formula 
\[
\dfrac{1\leq i\leq n}{n\vdash\var i}\qquad\dfrac{n\vdash t\quad n\vdash u}{n\vdash t\Rightarrow u}\qquad\dfrac{n+1\vdash t}{n\vdash\forall t}
\]

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $S:\mathbb{F}_{m}\rightarrow\Set$
\end_inset

 be the functor mapping 
\begin_inset Formula $n$
\end_inset

 to the set 
\begin_inset Formula $S_{n}$
\end_inset

 of types for system 
\begin_inset Formula $F$
\end_inset

 taking free type variables in 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

.
 In other words, 
\begin_inset Formula $S_{n}=\{\tau|n\vdash\tau\}$
\end_inset

.
 Intuitively, a metavariable arity 
\begin_inset Formula $n\Fsep\vec{\sigma}\arSep\tau$
\end_inset

 specifies the number 
\begin_inset Formula $n$
\end_inset

 of free type variables, the list of input types 
\begin_inset Formula $\vec{\sigma}$
\end_inset

, and the output type 
\begin_inset Formula $\tau$
\end_inset

, all living in 
\begin_inset Formula $S_{n}$
\end_inset

.
 This provides the underlying set of objects of the category 
\begin_inset Formula ${\cal A}$
\end_inset

 of arities.
 A term 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $n\Fsep\vec{\sigma}\arSep\tau$
\end_inset

 considered as a variable context is intuitively a well-typed term of type
 
\begin_inset Formula $\tau$
\end_inset

 potentially involving ground variables of type 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 and type variables in 
\begin_inset Formula $\{1,\dots,n\}$
\end_inset

.
\end_layout

\begin_layout Standard
A metavariable 
\begin_inset Formula $M:(n\Fsep\sigma_{1},\dots,\sigma_{p}\arSep\tau)$
\end_inset

 in the variable context 
\begin_inset Formula $n'\Fsep\vec{\sigma}'\arSep\tau'$
\end_inset

 must be supplied with
\end_layout

\begin_layout Itemize
a choice 
\begin_inset Formula $(\eta_{1},\dots,\eta_{n})$
\end_inset

 of 
\begin_inset Formula $n$
\end_inset

 distinct type variables among 
\begin_inset Formula $\{1,\dots n'\}$
\end_inset

, such that 
\begin_inset Formula $\tau[\vec{\eta}]=\tau'$
\end_inset

, and 
\end_layout

\begin_layout Itemize
an injective renaming 
\begin_inset Formula $\vec{\sigma}[\vec{\eta}]\rightarrow\vec{\sigma}'$
\end_inset

, i.e., a list of distinct positions 
\begin_inset Formula $r_{1},\dots,r_{p}$
\end_inset

 such that 
\begin_inset Formula $\vec{\sigma}[\vec{\eta}]=\sigma'_{\vec{r}}$
\end_inset

.
\end_layout

\begin_layout Standard
This defines the data for a morphism in 
\begin_inset Formula ${\cal A}$
\end_inset

 between 
\begin_inset Formula $(n\Fsep\vec{\sigma}\arSep\tau)$
\end_inset

 and 
\begin_inset Formula $(n'\Fsep\vec{\sigma}'\arSep\tau')$
\end_inset

.
 The intrinsic syntax of system 
\begin_inset Formula $F$
\end_inset

 can then be specified as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:all-syntax"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 The induced GB-signature is pattern-friendly.
 For example, morphisms in 
\begin_inset Formula ${\cal A}$
\end_inset

 are easily seen to be monomorphic; we detail in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "app:A-finite-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

 the proof of the following statement.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:A-finite-connected"

\end_inset


\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits.
\end_layout

\begin_layout Standard
Pullbacks and equalisers in 
\begin_inset Formula ${\cal A}$
\end_inset

 are essentially computed as in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:simply-typed-so"
plural "false"
caps "true"
noprefix "false"

\end_inset

, by computing the vector of common (value) positions.
 For example, given a metavariable 
\begin_inset Formula $M$
\end_inset

 of arity 
\begin_inset Formula $m\Fsep\vec{\sigma}\arSep\tau$
\end_inset

, to unify 
\begin_inset Formula $M(\vec{w}\Fsep\vec{x})$
\end_inset

 with 
\begin_inset Formula $M(\vec{y}\Fsep\vec{z})$
\end_inset

, we compute the vector of common positions 
\begin_inset Formula $\vec{p}$
\end_inset

 between 
\begin_inset Formula $\vec{w}$
\end_inset

 and 
\begin_inset Formula $\vec{y}$
\end_inset

, and the vector of common positions 
\begin_inset Formula $\vec{q}$
\end_inset

 between 
\begin_inset Formula $\vec{x}$
\end_inset

 and 
\begin_inset Formula $\vec{z}$
\end_inset

.
 Then, the most general unifier maps 
\begin_inset Formula $M$
\end_inset

 to the term 
\begin_inset Formula $P(\vec{p}\Fsep\vec{q})$
\end_inset

, where 
\begin_inset Formula $P$
\end_inset

 is a fresh metavariable.
 Its arity 
\begin_inset Formula $m'\Fsep\vec{\sigma}'\arSep\tau'$
\end_inset

 is the only possible one for 
\begin_inset Formula $P(\vec{p}|\vec{q})$
\end_inset

 to be well-formed in the variable context 
\begin_inset Formula $m\Fsep\vec{\sigma}\arSep\tau$
\end_inset

, that is, 
\begin_inset Formula $m'$
\end_inset

 is the size of 
\begin_inset Formula $\vec{p}$
\end_inset

, while 
\begin_inset Formula $\tau'=\tau[p_{i}\mapsto i]$
\end_inset

 and 
\begin_inset Formula $\vec{\sigma}'=\text{\ensuremath{\sigma_{\vec{q}}}}[p_{i}\mapsto i]$
\end_inset

.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
We presented a generic unification algorithm for Miller's pattern fragment
 with its associated categorical semantics, parameterised by a new notion
 of signature for syntax with metavariables.
 In the future, we plan to a implement a reusable library based on this
 work.
 We also plan to see how this work applies to dependently-typed languages,
 going beyond polymorphic syntax.
 Finally, we are interesting in further extending the setting to cover unificati
on modulo equations, or linear syntax without restriction on the order the
 variables are used.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "biblio,bib"
options "ACM-Reference-Format"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
startappendix
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
secappendix{
\end_layout

\end_inset

Proof of
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Appendix
Proof of Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:res-F"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "app:resF-direct"

\end_inset


\end_layout

\begin_layout Notation
Given a functor 
\begin_inset Formula $F:I\rightarrow\B$
\end_inset

, we denote the limit (resp.
 colimit) of 
\begin_inset Formula $F$
\end_inset

 by 
\begin_inset Formula $\int_{i:I}F(i)$
\end_inset

 or 
\begin_inset Formula $\lim F$
\end_inset

 (resp.
 
\begin_inset Formula $\int^{i:I}F(i)$
\end_inset

 or 
\begin_inset Formula $\colim F$
\end_inset

) and the canonical projection 
\begin_inset Formula $\lim F\rightarrow Fi$
\end_inset

 by 
\begin_inset Formula $p_{i}$
\end_inset

 for any object 
\begin_inset Formula $i$
\end_inset

 of 
\begin_inset Formula $I$
\end_inset

.
\end_layout

\begin_layout Standard
This section is dedicated to the proof of the following lemma.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:F-restricts-simpl"

\end_inset

Given a GB-signature 
\begin_inset Formula $S=({\cal A},O,\ntharvecfunct)$
\end_inset

 such that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits, 
\begin_inset Formula $F_{S}$
\end_inset

 restricts as an endofunctor on the full subcategory 
\begin_inset Formula $\C$
\end_inset

 of 
\begin_inset Formula $[{\cal A},\Set]$
\end_inset

 consisting of functors preserving finite connected limits if and only if
 each 
\begin_inset Formula $O_{n}\in\C$
\end_inset

, and 
\begin_inset Formula $\alpha:\int J\rightarrow{\cal A}$
\end_inset

 preserves finite limits.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
We first introduce a bunch of intermediate lemmas.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:coprod-filtered"

\end_inset

If 
\begin_inset Formula $\B$
\end_inset

 is a small category with finite connected limits, then a functor 
\begin_inset Formula $G:\B\rightarrow\Set$
\end_inset

 preserves those limits if and only if 
\begin_inset Formula $\int\B$
\end_inset

 is a coproduct of filtered categories.
\end_layout

\begin_layout Proof
This is a direct application of 
\begin_inset CommandInset citation
LatexCommand cite
after "Theorem 2.4 and Example 2.3.(iii)"
key "classificationaccessible"
literal "false"

\end_inset

.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:J-preserve"

\end_inset

Assume 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits.
 Then 
\begin_inset Formula $J:\mathbb{N}\times\mathcal{A}\rightarrow{\cal \Set}$
\end_inset

 preserves finite connected limits if and only if each 
\begin_inset Formula $O_{n}:{\cal A\rightarrow\Set}$
\end_inset

 does.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proof
This follows from 
\begin_inset Formula $\int J\cong\coprod_{n\in\mathbb{N}}\coprod_{j\in\{1,\dots,n\}}\int O_{n}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:data-functor-elt"

\end_inset

Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 be a functor.
 For any functor 
\begin_inset Formula $G:I\rightarrow\int F$
\end_inset

, denoting by 
\begin_inset Formula $H$
\end_inset

 the composite functor 
\begin_inset Formula $I\xrightarrow{G}\int F\rightarrow\B$
\end_inset

, there exists a unique 
\begin_inset Formula $x\in\lim(F\circ H)$
\end_inset

 such that 
\begin_inset Formula $Gi=(Hi,p_{i}(x))$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Formula $\int F$
\end_inset

 is isomorphic to the opposite of the comma category 
\begin_inset Formula $y/F$
\end_inset

, where 
\begin_inset Formula $y:\op{\B}\rightarrow[\B,\Set]$
\end_inset

 is the Yoneda embedding.
 The statement follows from the universal property of a comma category.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:lim-elt"

\end_inset

Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 and 
\begin_inset Formula $G:I\rightarrow\int F$
\end_inset

 such that 
\begin_inset Formula $F$
\end_inset

 preserves the limit of 
\begin_inset Formula $H:I\xrightarrow{G}\int F\xrightarrow{}\B$
\end_inset

.
 Then, there exists a unique 
\begin_inset Formula $x\in F\lim H$
\end_inset

 such that 
\begin_inset Formula $Gi=(Hi,Fp_{i}(x))$
\end_inset

 and moreover, 
\begin_inset Formula $(\lim H,x)$
\end_inset

 is the limit of 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 preserving a limit 
\begin_inset Formula $\lim G$
\end_inset

.
 Let 
\begin_inset Formula $x\in F\lim G$
\end_inset

, thus inducing a functor 
\begin_inset Formula $G_{x}:D\rightarrow\int F$
\end_inset

 by the previous lemma.
 Then, the limit of 
\begin_inset Formula $G_{x}$
\end_inset

 is 
\begin_inset Formula $(\lim D,x)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
The unique existence of 
\begin_inset Formula $x\in F\lim H$
\end_inset

 such that 
\begin_inset Formula $Gi=(Hi,Fp_{i}(x))$
\end_inset

 follows from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:data-functor-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and the fact that 
\begin_inset Formula $F$
\end_inset

 preserves 
\begin_inset Formula $\lim H$
\end_inset

.
 Let 
\begin_inset Formula $\C$
\end_inset

 denote the full subcategory of 
\begin_inset Formula $[\B,\Set]$
\end_inset

 of functors preserving 
\begin_inset Formula $\lim G$
\end_inset

.
 Note that 
\begin_inset Formula $\int F$
\end_inset

 is isomorphic to the opposite of the comma category 
\begin_inset Formula $K/F$
\end_inset

, where 
\begin_inset Formula $K:\op{\B}\rightarrow\C$
\end_inset

 is the Yoneda embedding, which preserves 
\begin_inset Formula $\colim G$
\end_inset

, by an argument similar to the proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:K-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
 We conclude from the fact that the forgetful functor from a comma category
 
\begin_inset Formula $L/R$
\end_inset

 to the product of the categories creates colimits that 
\begin_inset Formula $L$
\end_inset

 preserve.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:preserves-elt"

\end_inset

Let 
\begin_inset Formula $I$
\end_inset

 be a small category, 
\begin_inset Formula $\B$
\end_inset

 and 
\begin_inset Formula $\B'$
\end_inset

 be categories with 
\begin_inset Formula $I$
\end_inset

-limits (i.e., limits of any diagram over 
\begin_inset Formula $I$
\end_inset

).
 Let 
\begin_inset Formula $F:\B\rightarrow\Set$
\end_inset

 be a functor preserving those colimits.
 Then, 
\begin_inset Formula $\int F$
\end_inset

 has 
\begin_inset Formula $I$
\end_inset

-limits, preserved by the projection 
\begin_inset Formula $\int F\rightarrow\B$
\end_inset

.
 Moreover, a functor 
\begin_inset Formula $G:\int F\rightarrow\B'$
\end_inset

 preserves them if and only if for any 
\begin_inset Formula $d:I\rightarrow\B$
\end_inset

 and 
\begin_inset Formula $x\in F\lim d$
\end_inset

, the canonical morphism 
\begin_inset Formula $G(\lim d,x)\rightarrow\int_{i:I}G(d_{i},Fp_{i}(x))$
\end_inset

 is an isomorphism.
\end_layout

\begin_layout Proof
By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:lim-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

, a diagram 
\begin_inset Formula $d':I\rightarrow\int F$
\end_inset

 is equivalently given by 
\begin_inset Formula $d:I\rightarrow\B$
\end_inset

 and 
\begin_inset Formula $x\in F\lim d$
\end_inset

, recovering 
\begin_inset Formula $d'$
\end_inset

 as 
\begin_inset Formula $d'_{i}=(d_{i},Fp_{i}(x))$
\end_inset

, and moreover 
\begin_inset Formula $\lim d'=(\lim d,x)$
\end_inset

.
 
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:can-iso-app"

\end_inset

Assuming that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits and each 
\begin_inset Formula $O_{n}$
\end_inset

 preserves finite connected limits, the finite limit preservation on 
\begin_inset Formula $\alpha:\int J\rightarrow{\cal A}$
\end_inset

 of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-simpl"
plural "false"
caps "true"
noprefix "false"

\end_inset

 can be reformulated as follows: given a finite connected diagram 
\begin_inset Formula $d:D\rightarrow{\cal A}$
\end_inset

 and element 
\begin_inset Formula $o\in\Oop n{\lim d}$
\end_inset

, the following canonical morphism is an isomorphism
\begin_inset Formula 
\[
\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j
\]

\end_inset

for any 
\begin_inset Formula $j\in\{1,\dots,n\}$
\end_inset

.
\end_layout

\begin_layout Proof
This is a direct application of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:J-preserve"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

[Limits commute with dependent pairs]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lem:lim-commute-dependent-pairs"

\end_inset

Given functors 
\begin_inset Formula $K:I\rightarrow\Set$
\end_inset

 and 
\begin_inset Formula $G:\int K\rightarrow\Set$
\end_inset

, the following canonical morphism is an isomorphism
\begin_inset Formula 
\[
\int_{i:I}\coprod_{x\in Ki}G(i,x)\rightarrow\coprod_{\alpha\in\lim K}\int_{i:I}G(i,p_{i}(\alpha))
\]

\end_inset


\end_layout

\begin_layout Proof
It is straightforward to check that both sets share the same universal property.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout

[Proof of 
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:F-restricts-simpl"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

Let 
\begin_inset Formula $d:I\rightarrow{\cal A}$
\end_inset

 be a finite connected diagram and 
\begin_inset Formula $X$
\end_inset

 be a functor preserving finite connected limits.
 Then,
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{align*}
\int_{i:I}F(X)_{d_{i}} & =\int_{i:I}\coprod_{n}\coprod_{o\in\Oop n{d_{i}}}X_{\nthar o1}\times\dots\times X_{\nthar on}\\
 & \cong\coprod_{n}\int_{i:I}\coprod_{o\in\Oop n{d_{i}}}X_{\nthar o1}\times\dots\times X_{\nthar on}\tag{Coproducts commute with connected limits}\\
 & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}\int_{i:I}X_{\nthar{p_{i}(o)}1}\times\dots\times X_{\nthar{p_{i}(o)}n}\tag{By \prettyref{lem:lim-commute-dependent-pairs}}\\
 & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}\int_{i:I}X_{\nthar{p_{i}(o)}1}\times\dots\times\int_{i:I}X_{\nthar{p_{i}(o)}n}\tag{By commutation of limits}
\end{align*}

\end_inset

Thus, since 
\begin_inset Formula $X$
\end_inset

 preserves finite connected limits by assumption,
\begin_inset Formula 
\begin{align}
\int_{i}F(X)_{d_{i}} & =\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\label{eq:F-restrict-1}
\end{align}

\end_inset


\end_layout

\begin_layout Proof
Now, let us prove the only if statement first.
 Assuming that 
\begin_inset Formula $\alpha:\int J\rightarrow{\cal A}$
\end_inset

 and each 
\begin_inset Formula $O_{n}$
\end_inset

 preserves finite connected limits.
 Then,
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{align*}
\int_{i}F(X)_{d_{i}} & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\tag{By Equation \prettyref{eq:F-restrict-1}}\\
 & \cong\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\int_{i:I}\nthar{\rename o{p_{i}}}1}\times\dots\times X_{\int_{i:I}\nthar{\rename o{p_{i}}}n}\tag{By assumption on \ensuremath{O_{n}}}\\
 & \cong\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\nthar o1}\times\dots\times X_{\nthar on}\tag{By Corollary \prettyref{cor:can-iso-app}}\\
 & =F(X)_{\lim d}
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Conversely, let us assume that 
\begin_inset Formula $F$
\end_inset

 restricts to an endofunctor on 
\begin_inset Formula $\C$
\end_inset

.
 Then, 
\begin_inset Formula $F(1)=\coprod_{n}O_{n}$
\end_inset

 preserves finite connected limits.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:coprod-filtered"
plural "false"
caps "true"
noprefix "false"

\end_inset

, each 
\begin_inset Formula $O_{n}$
\end_inset

 preserves finite connected limits.
 By 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:can-iso-app"
plural "false"
caps "true"
noprefix "false"

\end_inset

, it is enough to prove that given a finite connected diagram 
\begin_inset Formula $d:D\rightarrow{\cal A}$
\end_inset

 and element 
\begin_inset Formula $o\in\Oop n{\lim d}$
\end_inset

, the following canonical morphism is an isomorphism
\begin_inset Formula 
\[
\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\end_layout

\begin_layout Standard
Now, we have
\begin_inset Formula 
\begin{align*}
\int_{i:I}F(X)_{d_{i}} & \cong F(X)_{\lim d}\tag{By assumption}\\
 & =\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\nthar o1}\times\dots\times X_{\nthar on}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
On the other hand,
\begin_inset Formula 
\begin{align*}
\int_{i:I}F(X)_{d_{i}} & \cong\coprod_{n}\coprod_{o\in\int_{i}\Oop n{d_{i}}}X_{\int_{i:I}\nthar{p_{i}(o)}1}\times\dots\times X_{\int_{i:I}\nthar{p_{i}(o)}n}\tag{By Equation \prettyref{eq:F-restrict-1}}\\
 & =\coprod_{n}\coprod_{o\in\Oop n{\lim d}}X_{\int_{i:I}\nthar{\rename o{p_{i}}}1}\times\dots\times X_{\int_{i:I}\nthar{\rename o{p_{i}}}n}\tag{\ensuremath{O_{n}} preserves finite connected limits}
\end{align*}

\end_inset

It follows from those two chains of isomorphisms that each function 
\begin_inset Formula $X_{\nthar oj}\rightarrow X_{\int_{i:I}\nthar{\rename o{p_{i}}}j}$
\end_inset

 is a bijection, or equivalently (by the Yoneda Lemma), that 
\begin_inset Formula $\C(K\nthar oj,X)\rightarrow\C(K\int_{i:I}\nthar{\rename o{p_{i}}}j,X)$
\end_inset

 is an isomorphism.
 Since the Yoneda embedding is fully faithful, 
\begin_inset Formula $\nthar oj\rightarrow\int_{i:D}\nthar{\rename o{p_{i}}}j$
\end_inset

 is an isomorphism.
\end_layout

\end_deeper
\begin_layout Appendix
Proof of Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:A-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "app:A-finite-F"

\end_inset

In this section, we show that the category 
\begin_inset Formula ${\cal A}$
\end_inset

 of arities for System F (
\begin_inset CommandInset ref
LatexCommand formatted
reference "subsec:system-F"
plural "false"
caps "true"
noprefix "false"

\end_inset

) has finite connected limits.
 First, note that 
\begin_inset Formula ${\cal A}$
\end_inset

 is the op-lax colimit of the functor from 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 to the category of small categories mapping 
\begin_inset Formula $n$
\end_inset

 to 
\begin_inset Formula $\mathbb{F}_{m}[S_{n}]\times S_{n}$
\end_inset

.
 Let us introduce the category 
\begin_inset Formula ${\cal A}'$
\end_inset

 whose definition follows that of 
\begin_inset Formula ${\cal A}$
\end_inset

, but without the output types: objects are pairs of a natural number 
\begin_inset Formula $n$
\end_inset

 and an element of 
\begin_inset Formula $S_{n}$
\end_inset

.
 Formally, this is the op-lax colimit of 
\begin_inset Formula $n\mapsto\mathbb{F}_{m}[S_{n}]$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:A'-lim"

\end_inset


\begin_inset Formula ${\cal A}'$
\end_inset

 has finite connected limits, and the projection functor 
\begin_inset Formula ${\cal A}'\rightarrow\mathbb{F}_{m}$
\end_inset

 preserves them.
\end_layout

\begin_layout Proof
The crucial point is that 
\begin_inset Formula ${\cal A}'$
\end_inset

 is not only op-fibred over 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 by construction, it is also fibred over 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

.
 Intuitively, if 
\begin_inset Formula $\vec{\sigma}\in\mathbb{F}_{m}[S_{n}]$
\end_inset

 and 
\begin_inset Formula $f:n'\rightarrow n$
\end_inset

 is a morphism in 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

, then 
\begin_inset Formula $f_{!}\vec{\sigma}\in\mathbb{F}_{m}[S_{n'}]$
\end_inset

 is essentially 
\begin_inset Formula $\vec{\sigma}$
\end_inset

 restricted to elements of 
\begin_inset Formula $S_{n}$
\end_inset

 that are in the image of 
\begin_inset Formula $S_{f}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note that 
\begin_inset Formula $f_{!}:\mathbb{F}_{m}[S_{n}]\rightarrow\mathbb{F}_{m}[S_{n'}]$
\end_inset

 is right adjoint to 
\begin_inset Formula $\vec{\sigma}\mapsto\vec{\sigma}[f]$
\end_inset

, and is thus continuous.
\end_layout

\end_inset

 We can now apply 
\begin_inset CommandInset citation
LatexCommand cite
after "Corollary 4.3"
key "grayfib"
literal "false"

\end_inset

, since each 
\begin_inset Formula $\mathbb{F}_{m}[S_{n}]$
\end_inset

 has finite connected limits.
\begin_inset Note Note
status open

\begin_layout Plain Layout
is it?
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are now ready to prove that 
\begin_inset Formula ${\cal A}$
\end_inset

 has finite connected limits.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout

[
\end_layout

\end_inset

Proof of 
\begin_inset CommandInset ref
LatexCommand formatted
reference "lem:A-finite-connected"
plural "false"
caps "true"
noprefix "false"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

]
\end_layout

\end_inset

Since 
\begin_inset Formula $S:\mathbb{F}_{m}\rightarrow\Set$
\end_inset

 preserves finite connected limits, 
\begin_inset Formula $\int S$
\end_inset

 has finite connected limits and the projection functor to 
\begin_inset Formula $\mathbb{F}_{m}$
\end_inset

 preserves them by 
\begin_inset CommandInset ref
LatexCommand formatted
reference "cor:preserves-elt"
plural "false"
caps "true"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Proof
Now, the 2-category of small categories with finite connected limits and
 functors preserving those between them is the category of algebras for
 a 2-monad on the category of small categories 
\begin_inset CommandInset citation
LatexCommand cite
key "BLACKWELL19891"
literal "false"

\end_inset

.
 Thus, it includes the weak pullback of 
\begin_inset Formula ${\cal A}'\rightarrow\mathbb{F}_{m}\leftarrow\int S$
\end_inset

.
 But since 
\begin_inset Formula $\int S\rightarrow\mathbb{F}_{m}$
\end_inset

 is a fibration, and thus an isofibration, by 
\begin_inset CommandInset citation
LatexCommand cite
key "JoyalStreetPullbacks"
literal "false"

\end_inset

 this weak pullback can be computed as a pullback, which is 
\begin_inset Formula ${\cal A}$
\end_inset

.
\end_layout

\end_body
\end_document
